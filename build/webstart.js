/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/lezer-python/dist/index.es.js":
/*!****************************************************!*
  !*** ./node_modules/lezer-python/dist/index.es.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parser": () => /* binding */ parser
/* harmony export */ });
/* harmony import */ var lezer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lezer */ "./node_modules/lezer/dist/index.es.js");


// This file was generated by lezer-generator. You probably shouldn't edit it.
const 
  printKeyword = 1,
  newline = 164,
  newlineBracketed = 165,
  newlineEmpty = 166,
  eof = 167,
  continueBody = 168,
  endBody = 169,
  ParenthesizedExpression = 21,
  TupleExpression = 48,
  ComprehensionExpression = 49,
  ArrayExpression = 53,
  ArrayComprehensionExpression = 56,
  DictionaryExpression = 57,
  DictionaryComprehensionExpression = 60,
  SetExpression = 61,
  SetComprehensionExpression = 62,
  compoundStatement = 231;

const newline$1 = 10, carriageReturn = 13, space = 32, tab = 9, hash = 35, parenOpen = 40, dot = 46;

const bracketed = [
  ParenthesizedExpression, TupleExpression, ComprehensionExpression, ArrayExpression, ArrayComprehensionExpression,
  DictionaryExpression, DictionaryComprehensionExpression, SetExpression, SetComprehensionExpression
], parentStatement = [compoundStatement];

const caches = new WeakMap;

// Per-input-stream indentation cache. `prev` maps indentation depths
// to the last position at which a statement indented to that depth
// was seen. There's an extra set of slots for the _current_
// indentation, since that needs to be available alongside a previous
// indentation position at the same level.
class Cache {
  constructor() {
    this.last = this.lastIndent = -1;
    this.prev = [];
  }

  get(pos) {
    if (this.last == pos) return this.lastIndent
    for (let i = 0; i < this.prev.length; i++) if (this.prev[i] == pos) return i
    return -1
  }

  set(pos, indent) {
    if (pos == this.last) return
    if (this.last > -1) this.setPrev(this.last, this.lastIndent);
    this.last = pos;
    this.lastIndent = indent;
  }

  setPrev(pos, indent) {
    while (this.prev.length < indent) this.prev.push(-1);
    this.prev[indent] = pos;
  }

  static for(input) {
    let found = caches.get(input);
    if (!found) caches.set(input, found = new Cache);
    return found
  }
}

const maxIndent = 50;

function getIndent(input, pos) {
  let cache = Cache.for(input), found = cache.get(pos);
  if (found > -1) return found

  // This shouldn't happen very often (or even at all) in normal
  // parsing, since the indentations are stored by the newline
  // tokenizer ahead of time. But it's kind of tricky to prove whether
  // that always happens in incremental parsing scenarios, so here's a
  // fallback anyway.
  let before = input.read(Math.max(0, pos - maxIndent), pos);
  let count = 0, start = before.length;
  for (; start > 0; start--) {
    let next = before.charCodeAt(start - 1);
    if (next == newline$1 || next == carriageReturn) break
  }
  for (let i = start; i < before.length; i++) {
    let ch = before.charCodeAt(i);
    if (ch == space) count++;
    else if (ch == tab) count += 8 - (count % 8);
    else break
  }
  cache.setPrev(pos, count);
  return count
}

const newlines = new lezer__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, token, stack) => {
  let next = input.get(token.start);
  if (next < 0) {
    token.accept(eof, token.start);
    return
  }
  if (next != newline$1 && next != carriageReturn) return
  if (stack.startOf(bracketed) != null) {
    token.accept(newlineBracketed, token.start + 1);
    return
  }
  let scan = token.start + 1, indent = 0;
  for (; scan < input.length; scan++) {
    let ch = input.get(scan);
    if (ch == space) indent++;
    else if (ch == tab) indent += 8 - (indent % 8);
    else if (ch == newline$1 || indent == carriageReturn || ch == hash) {
      token.accept(newlineEmpty, token.start + 1);
      return
    } else {
      break
    }
  }
  token.accept(newline, token.start + 1);
  Cache.for(input).set(scan, indent);
}, {contextual: true, fallback: true});

const bodyContinue = new lezer__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, token, stack) => {
  let parent = stack.startOf(parentStatement);
  let parentIndent = parent == null ? 0 : getIndent(input, parent);
  let indentHere = getIndent(input, token.start);
  token.accept(indentHere <= parentIndent ? endBody : continueBody, token.start);
}, {contextual: true, fallback: true});

const legacyPrint = new lezer__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, token) => {
  let pos = token.start;
  for (let print = "print", i = 0; i < print.length; i++, pos++)
    if (input.get(pos) != print.charCodeAt(i)) return
  let end = pos;
  if (/\w/.test(String.fromCharCode(input.get(pos)))) return
  for (;; pos++) {
    let next = input.get(pos);
    if (next == space || next == tab) continue
    if (next != parenOpen && next != dot && next != newline$1 && next != carriageReturn && next != hash)
      token.accept(printKeyword, end);
    return
  }
});

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_identifier = {__proto__:null,await:40, or:48, and:50, in:54, not:56, is:58, if:64, else:66, lambda:70, self:74, yield:90, from:92, async:100, for:102, None:154, True:156, False:156, del:170, pass:174, break:178, continue:182, return:186, raise:194, import:198, as:200, global:204, nonlocal:206, assert:210, elif:220, while:224, try:230, except:232, finally:234, with:238, def:242, class:252};
const parser = lezer__WEBPACK_IMPORTED_MODULE_0__.Parser.deserialize({
  version: 13,
  states: "!;[O`Q!LTOOO%fQ!LUO'#GcOOQ!LQ'#Cm'#CmOOQ!LQ'#Cn'#CnO'UQ!LSO'#ClO(zQ!LUO'#GbOOQ!LQ'#Gc'#GcOOQ!LQ'#DS'#DSOOQ!LQ'#Gb'#GbO)hQ!LSO'#CqO)xQ!LSO'#DcO*YQ!LSO'#DgOOQ!LQ'#Dt'#DtO*mOWO'#DtO*uO`O'#DtO*}OpO'#DuO+YO!bO'#DuO+eO#tO'#DuO+pO&jO'#DuO-rQ!LUO'#GSOOQ!LQ'#GS'#GSO'UQ!LSO'#GRO/UQ!LUO'#GROOQ!LQ'#E^'#E^O/mQ!LSO'#E_OOQ!LQ'#GQ'#GQO/wQ!LSO'#GPOOQ&FV'#GP'#GPO0SQ!LSO'#FQOOQ!LQ'#Ft'#FtO0XQ!LSO'#FPOOQ&FV'#H]'#H]OOQ&FV'#GO'#GOOOQ!LR'#FS'#FSQ`Q!LTOOO'UQ!LSO'#CoO0gQ!LSO'#CzO0nQ!LSO'#DOO1PQ!LSO'#GgO1aQ!LUO'#ERO'UQ!LSO'#ESOOQ!LQ'#EU'#EUOOQ!LQ'#EW'#EWOOQ!LQ'#EY'#EYO1uQ!LSO'#E[O2SQ!LSO'#E`O0SQ!LSO'#EbO2gQ!LUO'#EbO0SQ!LSO'#EeO/mQ!LSO'#EhO/mQ!LSO'#ElO/mQ!LSO'#EoO2rQ!LSO'#EqO2yQ!LSO'#EvO3UQ!LSO'#ErO/mQ!LSO'#EvO0SQ!LSO'#ExO0SQ!LSO'#E}OOQ!LQ'#Cc'#CcOOQ!LQ'#Cd'#CdOOQ!LQ'#Ce'#CeOOQ!LQ'#Cf'#CfOOQ!LQ'#Cg'#CgOOQ!LQ'#Ch'#ChOOQ!LQ'#Cj'#CjO'UQ!LSO,58|O'UQ!LSO,58|O'UQ!LSO,58|O'UQ!LSO,58|O'UQ!LSO,58|O'UQ!LSO,58|O'UQ!LSO,58|O3ZQ!LSO'#DnOOQ!LQ,5:X,5:XO3nQ!LSO,5:[O3{Q#)WO,5:[O4QQ!LUO,59WO0gQ!LSO,59_O0gQ!LSO,59_O0gQ!LSO,59_O6pQ!LSO,59_O6uQ!LSO,59_O6|Q!LSO,59gO7TQ!LSO'#GbO8ZQ!LSO'#GaOOQ!LQ'#Ga'#GaOOQ!LQ'#DY'#DYO8rQ!LSO,59]O'UQ!LSO,59]O9QQ!LSO,59]O9VQ!LSO,5:QO'UQ!LSO,5:QOOQ!LQ,59},59}O9eQ!LSO,59}O9jQ!LSO,5:WO'UQ!LSO,5:WO'UQ!LSO,5:UOOQ!LQ,5:R,5:RO9{Q!LSO,5:RO:QQ!LSO,5:VOOOO'#F]'#F]O:VOWO,5:`OOQ!LQ,5:`,5:`OOOO'#F^'#F^O:_O`O,5:`O:gQ!LSO'#DvOOOO'#F_'#F_O:wOpO,5:aOOQ!LQ,5:a,5:aOOOO'#Fb'#FbO;SO!bO,5:aOOOO'#Fc'#FcO;_O#tO,5:aOOOO'#Fd'#FdO;jO&jO,5:aOOQ!LQ'#Fe'#FeO;uQ!LUO,5:eO>gQ!LUO,5<mO?QQ#4^O'#FfO?tQ!LUO,5<mOOQ!LQ,5:y,5:yO@]Q!LTO'#FmOAlQ!LSO,5;UOOQ&FV,5<k,5<kOAwQ!LUO'#HYOB`Q!LSO,5;lOOQ!LQ-E9r-E9rOOQ&FV,5;k,5;kO3PQ!LSO'#ExOOQ!LR-E9Q-E9QOBhQ!LUO,59ZODoQ!LUO,59fOEYQ!LSO'#GdOEeQ!LSO'#GdO0SQ!LSO'#GdOEpQ!LSO'#DQOExQ!LSO,59jOE}Q!LSO'#GhO'UQ!LSO'#GhO/mQ!LSO,5=ROOQ!LQ,5=R,5=RO/mQ!LSO'#D}OOQ!LQ'#EO'#EOOFlQ!LSO'#FgOF|Q!LSO,58zOG[Q!LSO,58zO)kQ!LSO,5:kOGaQ!LUO'#GjOOQ!LQ,5:n,5:nOOQ!LQ,5:v,5:vOGtQ!LSO,5:zOHVQ!LSO,5:|OOQ!LQ'#Fj'#FjOHeQ!LUO,5:|OHsQ!LSO,5:|OHxQ!LSO'#H[OOQ!LQ,5;P,5;POIWQ!LSO'#HXOOQ!LQ,5;S,5;SO3UQ!LSO,5;WO3UQ!LSO,5;ZOIiQ!LUO'#H^O'UQ!LSO'#H^OIsQ!LSO,5;]O2rQ!LSO,5;]O/mQ!LSO,5;bO0SQ!LSO,5;dOIxQ!LTO'#EmOKRQ&FXO,5;^ONjQ!LSO'#H_O3UQ!LSO,5;bONuQ!LSO,5;dONzQ!LSO,5;iO!#oQ!LUO1G.hO!#vQ!LUO1G.hO!&gQ!LUO1G.hO!&qQ!LUO1G.hO!)[Q!LUO1G.hO!)oQ!LUO1G.hO!*SQ!LUO1G.hO!,rQ!LSO'#GpO!-QQ!LUO'#GSO/mQ!LSO'#GpO!-[Q!LSO'#GoOOQ!LQ,5:Y,5:YO!-dQ!LSO,5:YO!-iQ!LSO'#GqO!-tQ!LSO'#GqO!.XQ!LSO1G/vOOQ!LQ'#Dr'#DrOOQ!LQ1G/v1G/vOOQ!LQ1G.y1G.yO!/XQ!LUO1G.yO!/`Q!LUO1G.yO0gQ!LSO1G.yO!/{Q!LSO1G/ROOQ!LQ'#DX'#DXO/mQ!LSO,59rOOQ!LQ1G.w1G.wO!0SQ!LSO1G/dO!0dQ!LSO1G/dO!0lQ!LSO1G/eO'UQ!LSO'#GiO!0qQ!LSO'#GiO!0vQ!LUO1G.wO!1WQ!LSO,59fO!2^Q!LSO'#FXO!2qQ!LSO,5=XO!2yQ!LSO1G/lO!3OQ!LUO1G/lOOQ!LQ1G/i1G/iO!3`Q!LSO'#FUO!4YQ!LSO,5=SO/mQ!LSO1G/pO!4wQ!LSO1G/rO!4|Q!LUO1G/rO!5^Q!LUO1G/pOOQ!LQ1G/m1G/mOOQ!LQ1G/q1G/qOOOO-E9Z-E9ZOOQ!LQ1G/z1G/zOOOO-E9[-E9[O!5nQ!LSO'#G|O/mQ!LSO'#G|O!5|Q!LSO,5:bOOOO-E9]-E9]OOQ!LQ1G/{1G/{OOOO-E9`-E9`OOOO-E9a-E9aOOOO-E9b-E9bOOQ!LQ-E9c-E9cO!6XQ!LUO1G2XO'UQ!LSO,5<QOOQ!LQ,5<Q,5<QOOQ!LQ-E9d-E9dOOQ!LQ,5<X,5<XOOQ!LQ-E9k-E9kOOQ&FV1G0p1G0pO0SQ!LSO'#FiO!6pQ!LUO,5=tOOQ!LQ1G1W1G1WO!7XQ!LSO1G1WOOQ!LQ'#DT'#DTO/mQ!LSO,5=OOOQ!LQ,5=O,5=OO!7^Q!LSO'#FTO!7lQ!LSO,59lO!7tQ!LSO1G/UO!8OQ!LUO,5=SOOQ!LQ1G2m1G2mOOQ!LQ,5:i,5:iO!8oQ!LSO'#GROOQ!LQ,5<R,5<ROOQ!LQ-E9e-E9eO!9QQ!LSO1G.fOOQ!LQ1G0V1G0VO!9`Q!LSO'#FWO!9sQ!LSO,5=UO/mQ!LSO1G0fO/mQ!LSO1G0fO0SQ!LSO1G0hOOQ!LQ-E9h-E9hO!:UQ!LSO1G0hO!:aQ!LSO1G0hO!:fQ!LSO'#FlO!:wQ!LSO,5=vO!;VQ!LSO'#FhO!;pQ!LSO,5=sO!<RQ&FXO1G0rO!?gQ&FXO1G0uO!BxQ!LSO'#FpO!CVQ!LSO,5=xO!C_Q!LUO,5=xO/mQ!LSO1G0wO!CiQ!LSO1G0wO3UQ!LSO1G0|ONuQ!LSO1G1OOOQ&FV,5;X,5;XO!CnQ!LTO,5;XO!EaQ&FXO1G0xO!HxQ!LSO'#FqO3UQ!LSO1G0xO3UQ!LSO1G0xO!IVQ!LSO'#FrO!IgQ!LSO,5=yO0SQ!LSO,5=yOOQ&FV1G0|1G0|O!JQQ!LSO'#EzO!JXQ#)WO1G1OOOQ&FV1G1T1G1TO3UQ!LSO1G1TOOQ!LQ,5=[,5=[OOQ!LQ'#Do'#DoO/mQ!LSO,5=[O!JaQ!LSO'#FZO!JwQ!LSO,5=ZOOQ!LQ1G/t1G/tO!KPQ!LSO'#F[O!KdQ!LSO,5=]O!KlQ!LSO,5=]O!LPQ!LSO,5=]O!LaQ!LSO,5=]OOQ!LQ7+%b7+%bOOQ!LQ7+$e7+$eO!7tQ!LSO7+$mO!NSQ!LSO1G.yO!NZQ!LSO1G.yOOQ!LQ1G/^1G/^OOQ!LQ,5;q,5;qO'UQ!LSO,5;qOOQ!LQ7+%O7+%OO!NbQ!LSO7+%OOOQ!LQ-E9T-E9TOOQ!LQ7+%P7+%PO!NrQ!LSO,5=TO'UQ!LSO,5=TOOQ!LQ7+$c7+$cO!NwQ!LSO7+%OO# PQ!LSO7+%POOQ!LQ,5;s,5;sO'UQ!LSO,5;sOOQ!LQ-E9V-E9VOOQ!LQ7+%W7+%WO# UQ!LSO1G2sO# ^Q!LSO7+%WOOQ!LQ,5;p,5;pO'UQ!LSO,5;pOOQ!LQ-E9S-E9SO# cQ!LSO7+%[OOQ!LQ7+%^7+%^O# qQ!LSO1G2nO#!`Q!LSO7+%^O#!eQ!LSO'#FYO#!xQ!LSO1G2tO##QQ!LSO7+%[O##VQ!LSO'#F`O##pQ!LSO,5=hO##pQ!LSO,5=hO#$OOMhO'#DxO#$ZOQO'#G}OOOO1G/|1G/|O#$`Q!LSO1G/|O#$hQ!LUO1G1lOOQ!LQ,5<T,5<TOOQ!LQ-E9g-E9gOOQ!LQ7+&r7+&rOOQ!LQ1G2j1G2jOOQ!LQ,5;o,5;oOOQ!LQ-E9R-E9ROOQ!LQ7+$p7+$pO#%RQ!LSO'#FfO#%oQ!LSO,5<mO#&QQ!LUO,5;rOOQ!LQ-E9U-E9UOOQ!LQ7+&Q7+&QO#&eQ!LSO7+&QOOQ!LQ7+&S7+&SO#&sQ!LSO'#HZO0SQ!LSO7+&SO#'XQ!LSO7+&SOOQ!LQ,5<W,5<WOOQ!LQ-E9j-E9jOOQ!LQ,5<S,5<SOOQ!LQ-E9f-E9fO#'dQ&FXO7+&^O!HxQ!LSO'#FoO3UQ!LSO7+&^O3UQ!LSO7+&aO#*xQ!LUO,5<[O'UQ!LSO,5<[OOQ!LQ-E9n-E9nO#+SQ!LSO1G3dO3UQ!LSO7+&cO/mQ!LSO7+&cOOQ&FV7+&h7+&hO!JXQ#)WO7+&jO#+[Q&FWO1G0sOOQ&FV-E9o-E9oO3UQ!LSO7+&dO3UQ!LSO7+&dOOQ&FV,5<],5<]O#+gQ!LSO,5<]OOQ&FV7+&d7+&dO#+rQ&FXO7+&dO#/TQ!LSO,5<^OOQ!LQ-E9p-E9pO#/`Q!LSO1G3eO#/hQ!LSO'#HaO#/vQ!LSO'#HaO0SQ!LSO'#HaOOQ!LQ'#Ha'#HaO#0RQ!LSO'#H`OOQ!LQ,5;f,5;fO#0ZQ!LSO,5;fO/mQ!LSO'#E|OOQ&FV7+&j7+&jO3UQ!LSO7+&jOOQ&FV7+&o7+&oOOQ!LQ1G2v1G2vOOQ!LQ,5;u,5;uOOQ!LQ-E9X-E9XO#0`Q!LSO,5;vO#0kQ!LSO,5;vOOQ!LQ-E9Y-E9YO#1OQ!LSO1G2wO#1WQ!LSO1G2wO#1hQ!LSO1G2wO#1OQ!LSO1G2wOOQ!LQ<<HX<<HXO#1sQ!LUO1G1]OOQ!LQ<<Hj<<HjP#1}Q!LSO'#FVO6|Q!LSO1G2oO#2[Q!LSO1G2oO#2aQ!LSO<<HjOOQ!LQ<<Hk<<HkO#2qQ!LUO1G1_OOQ!LQ<<Hr<<HrO#2{Q!LUO1G1[O#3lQ!LSO7+(`O#3tQ!LSO<<HvOOQ!LQ<<Hx<<HxO#3yQ!LSO,5;tO'UQ!LSO,5;tOOQ!LQ-E9W-E9WOOQ!LQ<<Hv<<HvOOQ!LQ,5;z,5;zO/mQ!LSO,5;zOOQ!LQ-E9^-E9^O#4OQ!LSO1G3SOOOO'#Fa'#FaO#4^OMhO,5:dOOOO,5=i,5=iOOOO7+%h7+%hO#4iQ!LSO1G2XO/mQ!LSO<<IlO#4zQ!LSO'#FkO#5`Q!LSO,5=uO0SQ!LSO,5=uO#5qQ!LSO<<InOOQ!LQ<<In<<InO0SQ!LSO<<InOOQ&FV-E9m-E9mO3UQ!LSO<<IxOOQ&FV,5<Z,5<ZO3UQ!LSO,5<ZOOQ&FV<<Ix<<IxOOQ&FV<<I{<<I{O#5vQ!LUO1G1vO#6QQ&FXO<<I}O3UQ!LSO<<I}OOQ&FV<<JU<<JUO3UQ!LSO<<JUO!CnQ!LTO'#FnO#9cQ&FWO7+&_OOQ&FV7+&_7+&_OOQ&FV<<JO<<JOO#9nQ&FXO<<JOOOQ&FV1G1w1G1wO0SQ!LSO1G1wO3UQ!LSO<<JOO0SQ!LSO1G1xO#=PQ!LSO7+)POOQ!LQ'#E{'#E{O/mQ!LSO,5={O#=XQ!LSO,5={OOQ!LQ,5={,5={O#=dQ!LSO'#FsO#=nQ!LSO,5=zOOQ!LQ1G1Q1G1QOOQ!LQ,5;h,5;hO#=vQ!LSO1G1bO#>ZQ!LSO1G1bO#>kQ!LSO1G1bO#>vQ!LSO7+(cO#>vQ!LSO7+(cO#?OQ!LSO7+(cO#?`Q!LSO7+(ZO6|Q!LSO7+(ZOOQ!LQAN>UAN>UOOQ!LQAN>bAN>bO/mQ!LSO1G1`O#?yQ!LUO1G1`OOQ!LQ1G1f1G1fOOOO-E9_-E9_OOQ!LQAN?WAN?WO#@TQ!LSO,5<VOOQ!LQ-E9i-E9iO#@iQ!LSO1G3aOOQ!LQAN?YAN?YO#@zQ!LSOAN?YOOQ&FVAN?dAN?dOOQ&FV1G1u1G1uO3UQ!LSOAN?iO#APQ&FXOAN?iOOQ&FVAN?pAN?pOOQ&FU,5<Y,5<YOOQ&FU-E9l-E9lOOQ&FV<<Iy<<IyO3UQ!LSOAN?jO3UQ!LSO7+'cOOQ&FVAN?jAN?jOOQ!LQ7+'d7+'dOOQ!LQ1G3g1G3gO/mQ!LSO1G3gOOQ!LQ,5<_,5<_OOQ!LQ-E9q-E9qO#DbQ!LSO7+&|O#DrQ!LSO7+&|OOQ!LQ7+&|7+&|O#D}Q!LSO<<K}O#D}Q!LSO<<K}O#EVQ!LSO'#GkOOQ!LQ<<Ku<<KuO#EaQ!LSO<<KuOOQ!LQ7+&z7+&zO0SQ!LSO1G1qO#EzQ!LSO7+({OOQ!LQG24tG24tOOQ&FVG25TG25TO3UQ!LSOG25TOOQ&FVG25UG25UOOQ&FV<<J}<<J}OOQ!LQ7+)R7+)ROOQ!LQ<<Jh<<JhO#F]Q!LSO<<JhO#FmQ!LSOANAiO#FuQ!LSO'#GlOOQ!LQ'#Gl'#GlO0nQ!LSO'#DbO#G`Q!LSO,5=VOOQ!LQANAaANAaOOQ!LQ7+']7+']OOQ&FVLD*oLD*oOOQ!LQAN@SAN@SO#GwQ!LSO,59|OOQ!LQ1G2q1G2qO#EVQ!LSO1G/hOOQ!LQ7+%S7+%SO6|Q!LSO'#CzO6|Q!LSO,59_O6|Q!LSO,59_O6|Q!LSO,59_O#G|Q!LUO,5<mO6|Q!LSO1G.yO/mQ!LSO1G/UO/mQ!LSO7+$mO'UQ!LSO'#GRO#HaQ!LSO,59_O#HfQ!LSO,59_O#HmQ!LSO,59jO#HrQ!LSO1G/RO0nQ!LSO'#DOO6|Q!LSO,59g",
  stateData: "#IT~O$qOS$lOS$kOSQOS~OPhOTeOdsOfXOltOp!SOsuOudO}vO!O!PO!S!VO!T!UO!WYO![ZO!gdO!ndO!odO!pdO!wxO!yyO!{zO!}{O#P|O#T}O#V!OO#Y!QO#Z!QO#]!RO#d!TO#g!WO#k!XO#m!YO#r!ZO#ulO$jqO$|QO$}QO%RRO%SVO%g[O%h]O%k^O%n_O%t`O%waO%ybO~OT!aO]!aO_!bOf!jO!W!lO!e!mO$w![O$x!]O$y!^O$z!_O${!_O$|!`O$}!`O%O!aO%P!aO%Q!aO~Oh%VXi%VXj%VXk%VXl%VXm%VXp%VXx%VXy%VX!t%VX#_%VX$j%VX$m%VX%X%VX!P%VX!S%VX!T%VX%Y%VX!X%VX!]%VX!O%VX#W%VXq%VX!k%VX~P$bOdsOfXOudO!WYO![ZO!gdO!ndO!odO!pdO$|QO$}QO%RRO%SVO%g[O%h]O%k^O%n_O%t`O%waO%ybO~Ox%UXy%UX#_%UX$j%UX$m%UX%X%UX~Oh!pOi!qOj!oOk!oOl!rOm!sOp!tO!t%UX~P(fOT!zOl,qOs-OO}vO~P'UOT!}Ol,qOs-OO!X#OO~P'UOT#RO_#SOl,qOs-OO!]#TO~P'UO%i#WO%j#YO~O%l#ZO%m#YO~O![#]O%o#^O%s#`O~O![#]O%u#aO%v#`O~O![#]O%j#`O%x#cO~O![#]O%m#`O%z#eO~OT$vX]$vX_$vXf$vXh$vXi$vXj$vXk$vXl$vXm$vXp$vXx$vX!W$vX!e$vX$w$vX$x$vX$y$vX$z$vX${$vX$|$vX$}$vX%O$vX%P$vX%Q$vX!P$vX!S$vX!T$vX~O%g[O%h]O%k^O%n_O%t`O%waO%ybOy$vX!t$vX#_$vX$j$vX$m$vX%X$vX%Y$vX!X$vX!]$vX!O$vX#W$vXq$vX!k$vX~P+{Ox#jOy$uX!t$uX#_$uX$j$uX$m$uX%X$uX~Ol,qOs-OO~P'UO#_#mO$j#oO$m#oO~O%SVO~O!S#tO#m!YO#r!ZO#ulO~OltO~P'UOT#yO_#zOu#xO%SVOytP~OT$OOl,qOs-OO!O$PO~P'UOy$RO!t$WO%X$SO#_!uX$j!uX$m!uX~OT$OOl,qOs-OO~P'UOl,qOs-OO#_#SX$j#SX$m#SX~P'UO!e$^O!n$^O%SVO~OT$hO~P'UO!T$jO#k$kO#m$lO~Oy$mO~OT$|O_$|Ol,qOs-OO!P%OO~P'UOl,qOs-OOy%RO~P'UO%f%TO~O_!bOf!jO!W!lO!e!mOT`a]`ah`ai`aj`ak`al`am`ap`ax`ay`a!t`a#_`a$j`a$m`a$w`a$x`a$y`a$z`a${`a$|`a$}`a%O`a%P`a%Q`a%X`a!P`a!S`a!T`a%Y`a!X`a!]`a!O`a#W`aq`a!k`a~Ok%YO~Ol%YO~P'UOl,qO~P'UOh,sOi,tOj,rOk,rOl,zOm,{Op-PO!P%UX!S%UX!T%UX%Y%UX!X%UX!]%UX!O%UX#W%UX!k%UX~P(fO%Y%[Ox%TX!P%TX!S%TX!T%TX!X%TXy%TX~Ox%_O!P%^O!S%cO!T%bO~O!P%^O~Ox%fO!S%cO!T%bO!X%aX~O!X%jO~Ox%kOy%mO!S%cO!T%bO!]%[X~O!]%qO~O!]%rO~O%i#WO%j%tO~O%l#ZO%m%tO~OT%wOl,qOs-OO}vO~P'UO![#]O%o#^O%s%zO~O![#]O%u#aO%v%zO~O![#]O%j%zO%x#cO~O![#]O%m%zO%z#eO~OT!ma]!ma_!maf!mah!mai!maj!mak!mal!mam!map!max!may!ma!W!ma!e!ma!t!ma#_!ma$j!ma$m!ma$w!ma$x!ma$y!ma$z!ma${!ma$|!ma$}!ma%O!ma%P!ma%Q!ma%X!ma!P!ma!S!ma!T!ma%Y!ma!X!ma!]!ma!O!ma#W!maq!ma!k!ma~P#yOx#jOy$ua!t$ua#_$ua$j$ua$m$ua%X$ua~P$bOT&QOltOsuOx$YXy$YX!t$YX#_$YX$j$YX$m$YX%X$YX~P'UOx#jOy$ua!t$ua#_$ua$j$ua$m$ua%X$ua~OPhOTeOltOsuO}vO!O!PO!wxO!yyO!{zO!}{O#P|O#T}O#V!OO#Y!QO#Z!QO#]!RO#_$aX$j$aX$m$aX~P'UO#_#mO$j&VO$m&VO~O!e&WOf%|X$j%|X#W%|X#_%|X$m%|X#V%|X~Of!jO$j&YO~Ohcaicajcakcalcamcapcaxcayca!tca#_ca$jca$mca%Xca!Pca!Sca!Tca%Yca!Xca!]ca!Oca#Wcaqca!kca~P$bOpnaxnayna#_na$jna$mna%Xna~Oh!pOi!qOj!oOk!oOl!rOm!sO!tna~PDWO%X&[Ox%WXy%WX~O%SVOx%WXy%WX~Ox&_OytX~Oy&aO~Ox%kO#_%[X$j%[X$m%[X!P%[Xy%[X!]%[X!k%[X%X%[X~OT,yOl,qOs-OO}vO~P'UO%X$SO#_Sa$jSa$mSa~O%X$SO~Ox&jO#_%^X$j%^X$m%^Xk%^X~P$bOx&mO!O&lO#_#Sa$j#Sa$m#Sa~O#W&nO#_#Ua$j#Ua$m#Ua~O!e$^O!n$^O#V&pO%SVO~O#V&pO~Ox&rO#_&OX$j&OX$m&OX~Ox&tO#_%{X$j%{X$m%{Xy%{X~Ox&xOk&QX~P$bOk&{O~OPhOTeOltOsuO}vO!O!PO!wxO!yyO!{zO!}{O#P|O#T}O#V!OO#Y!QO#Z!QO#]!RO$j'QO~P'UOq'UO#h'SO#i'TOP#faT#fad#faf#fal#fap#fas#fau#fa}#fa!O#fa!S#fa!T#fa!W#fa![#fa!g#fa!n#fa!o#fa!p#fa!w#fa!y#fa!{#fa!}#fa#P#fa#T#fa#V#fa#Y#fa#Z#fa#]#fa#d#fa#g#fa#k#fa#m#fa#r#fa#u#fa$i#fa$j#fa$|#fa$}#fa%R#fa%S#fa%g#fa%h#fa%k#fa%n#fa%t#fa%w#fa%y#fa$m#fa$n#fa$o#fa~Ox'VO#W'XOy&RX~Of'ZO~Of!jOy$mO~OT!aO]!aO_!bOf!jO!W!lO!e!mO$y!^O$z!_O${!_O$|!`O$}!`O%O!aO%P!aO%Q!aOhUiiUijUikUilUimUipUixUiyUi!tUi#_Ui$jUi$mUi$wUi%XUi!PUi!SUi!TUi%YUi!XUi!]Ui!OUi#WUiqUi!kUi~O$x!]O~P! SO$xUi~P! SOT!aO]!aO_!bOf!jO!W!lO!e!mO$|!`O$}!`O%O!aO%P!aO%Q!aOhUiiUijUikUilUimUipUixUiyUi!tUi#_Ui$jUi$mUi$wUi$xUi$yUi%XUi!PUi!SUi!TUi%YUi!XUi!]Ui!OUi#WUiqUi!kUi~O$z!_O${!_O~P!#}O$zUi${Ui~P!#}O_!bOf!jO!W!lO!e!mOhUiiUijUikUilUimUipUixUiyUi!tUi#_Ui$jUi$mUi$wUi$xUi$yUi$zUi${Ui$|Ui$}Ui%XUi!PUi!SUi!TUi%YUi!XUi!]Ui!OUi#WUiqUi!kUi~OT!aO]!aO%O!aO%P!aO%Q!aO~P!&{OTUi]Ui%OUi%PUi%QUi~P!&{Of!jO!W!lO!e!mOTUi]Ui_UihUiiUijUikUilUimUipUixUiyUi!tUi#_Ui$jUi$mUi$wUi$xUi$yUi$zUi${Ui$|Ui$}Ui%OUi%PUi%QUi%XUi!PUi!SUi!TUi%YUi!XUi!]Ui!OUi#WUiqUi!kUi~O!S%cO!T%bOx%dX!P%dX~O%X'`O%Y'`O~P+{Ox'bO!P%cX~O!P'dO~Ox'eOy'gO!X%eX~Ol,qOs-OOx'eOy'hO!X%eX~P'UO!X'jO~Oj!oOk!oOl!rOm!sOhgipgixgiygi!tgi#_gi$jgi$mgi%Xgi~Oi!qO~P!.^Oigi~P!.^Oh,sOi,tOj,rOk,rOl,zOm,{O~Oq'lO~P!/gOT'qOl,qOs-OO!P'rO~P'UOx'sO!P'rO~O!P'uO~O!T'wO~Ox'sO!P'xO!S%cO!T%bO~P$bOh,sOi,tOj,rOk,rOl,zOm,{O!Pna!Sna!Tna%Yna!Xna!]na!Ona#Wnaqna!kna~PDWOT'|Ol,qOs-OOx#{X!X#{X~P'UOx%fO!X%aa~O!X(OO~Ox%fO!S%cO!T%bO!X%aa~P$bOT(SOl,qOs-OOx#xX!]#xX#_#xX$j#xX$m#xX!P#xXy#xX!k#xX%X#xX~P'UOx%kO!]%[a#_%[a$j%[a$m%[a!P%[ay%[a!k%[a%X%[a~O!](VO~Ox%kO!S%cO!T%bO!]%[a~P$bOx(YO!S%cO!T%bO!]%ba~P$bOx(]Oy%pX!]%pX!k%pX~Oy(`O!](bO!k(cO~Ox#jOy$ui!t$ui#_$ui$j$ui$m$ui%X$ui~O!e&WOf%|a$j%|a#W%|a#_%|a$m%|a#V%|a~O$j(gO~OT#yO_#zOu#xO%SVO~Ox&_Oyta~OltOsuO~P'UOx%kO#_%[a$j%[a$m%[a!P%[ay%[a!]%[a!k%[a%X%[a~P$bOx(lO#_$uX$j$uX$m$uX%X$uX~O%X$SO#_Si$jSi$mSi~Ox#zX#_#zX$j#zX$m#zXk#zX~P'UOx&jO#_%^a$j%^a$m%^ak%^a~OT(rOf(tO%SVO~O#V(uO~O%SVOx$`X#_$`X$j$`X$m$`X~Ox&rO#_&Oa$j&Oa$m&Oa~Ol,qOs-OOx$[X#_$[X$j$[X$m$[Xy$[X~P'UOx&tO#_%{a$j%{a$m%{ay%{a~Oq(|O#b({OP#`iT#`id#`if#`il#`ip#`is#`iu#`i}#`i!O#`i!S#`i!T#`i!W#`i![#`i!g#`i!n#`i!o#`i!p#`i!w#`i!y#`i!{#`i!}#`i#P#`i#T#`i#V#`i#Y#`i#Z#`i#]#`i#d#`i#g#`i#k#`i#m#`i#r#`i#u#`i$i#`i$j#`i$|#`i$}#`i%R#`i%S#`i%g#`i%h#`i%k#`i%n#`i%t#`i%w#`i%y#`i$m#`i$n#`i$o#`i~Oq(}OP#ciT#cid#cif#cil#cip#cis#ciu#ci}#ci!O#ci!S#ci!T#ci!W#ci![#ci!g#ci!n#ci!o#ci!p#ci!w#ci!y#ci!{#ci!}#ci#P#ci#T#ci#V#ci#Y#ci#Z#ci#]#ci#d#ci#g#ci#k#ci#m#ci#r#ci#u#ci$i#ci$j#ci$|#ci$}#ci%R#ci%S#ci%g#ci%h#ci%k#ci%n#ci%t#ci%w#ci%y#ci$m#ci$n#ci$o#ci~OT)POk$dXx$dX~P'UOx&xOk&Qa~Ox&xOk&Qa~P$bOk)TO~OPhOTeOltOp!SOsuO}vO!O!PO!S!VO!T!UO!wxO!yyO!{zO!}{O#P|O#T}O#V!OO#Y!QO#Z!QO#]!RO#d!TO#g!WO#k!XO#m!YO#r!ZO#ulO~P'UOq)ZO#h'SO#i)YOP#fiT#fid#fif#fil#fip#fis#fiu#fi}#fi!O#fi!S#fi!T#fi!W#fi![#fi!g#fi!n#fi!o#fi!p#fi!w#fi!y#fi!{#fi!}#fi#P#fi#T#fi#V#fi#Y#fi#Z#fi#]#fi#d#fi#g#fi#k#fi#m#fi#r#fi#u#fi$i#fi$j#fi$|#fi$}#fi%R#fi%S#fi%g#fi%h#fi%k#fi%n#fi%t#fi%w#fi%y#fi$m#fi$n#fi$o#fi~Ol,qOs-OOy$mO~P'UOl,qOs-OOx$fXy$fX~P'UOx'VOy&Ra~OT)dO_)eOu)cO%O)fO%SVO~O!P)hO~P!IoOy$mO&U)jO~OT$|O_$|Ol,qOs-OOx#}X!P#}X~P'UOx'bO!P%ca~Ol,qOs-OOy)rOx$OX!X$OX~P'UOx'eO!X%ea~Ol,qOs-OOx'eOy)uO!X%ea~P'UOl,qOs-OOx'eO!X%ea~P'UOx'eOy)uO!X%ea~Oj,rOk,rOl,zOm,{Ohgipgixgi!Pgi!Sgi!Tgi%Ygi!Xgiygi!]gi#_gi$jgi$mgi!Ogi#Wgiqgi!kgi%Xgi~Oi,tO~P!LlOigi~P!LlOT'qOl,qOs-OO!P)zO~P'UOk)|O~Ox*OO!P)zO~O!P*PO~Ox%fO!X%ai~O!X*RO~Ox(YO!S%cO!T%bO!]%bi~Ox%kO!]%[i#_%[i$j%[i$m%[i!P%[iy%[i!k%[i%X%[i~O!]*VO~O_*XOl,qOs-OOx#|X!]#|X~P'UOx(YO!]%bi~O!]*ZO~OT*]Ol,qOs-OOx$SXy$SX!]$SX!k$SX~P'UOx(]Oy%pa!]%pa!k%pa~O![#]O%r*`O!]!lX~O!]*bO~Oy(`O!]*cO~Ox$Yiy$Yi!t$Yi#_$Yi$j$Yi$m$Yi%X$Yi~P$bOT&QOl,qOs-OOx$YX#_$YX$j$YX$m$YX%X$YX~P'UOx(lO#_$ua$j$ua$m$ua%X$ua~Ox#za#_#za$j#za$m#zak#za~P$bOx*eO#_#Sq$j#Sq$m#Sq~Ox*fO#W*hO#_%}X$j%}X$m%}X!P%}X~OT*jOf*kO%SVO~Oq*mO#b({OP#`qT#`qd#`qf#`ql#`qp#`qs#`qu#`q}#`q!O#`q!S#`q!T#`q!W#`q![#`q!g#`q!n#`q!o#`q!p#`q!w#`q!y#`q!{#`q!}#`q#P#`q#T#`q#V#`q#Y#`q#Z#`q#]#`q#d#`q#g#`q#k#`q#m#`q#r#`q#u#`q$i#`q$j#`q$|#`q$}#`q%R#`q%S#`q%g#`q%h#`q%k#`q%n#`q%t#`q%w#`q%y#`q$m#`q$n#`q$o#`q~Ok$dax$da~P$bOx&xOk&Qi~O$m*yO$n*wO$o*yO~Ox*}Oy$mO#W*}O~O#i+OOP#fqT#fqd#fqf#fql#fqp#fqs#fqu#fq}#fq!O#fq!S#fq!T#fq!W#fq![#fq!g#fq!n#fq!o#fq!p#fq!w#fq!y#fq!{#fq!}#fq#P#fq#T#fq#V#fq#Y#fq#Z#fq#]#fq#d#fq#g#fq#k#fq#m#fq#r#fq#u#fq$i#fq$j#fq$|#fq$}#fq%R#fq%S#fq%g#fq%h#fq%k#fq%n#fq%t#fq%w#fq%y#fq$m#fq$n#fq$o#fq~O#W+POx$fay$fa~Ox'VOy&Ri~Oy$RO%X+ROx&TX!P&TX~O%SVOx&TX!P&TX~Ox+VO!P&SX~O!P+XO~Oy+ZOx$Oa!X$Oa~Ol,qOs-OOy+[Ox$Oa!X$Oa~P'UOx'eO!X%ei~Ol,qOs-OOx'eO!X%ei~P'UOx'eOy+`O!X%ei~Ox#yi!P#yi~P$bOT'qOl,qOs-OO~P'UOk+bO~OT'qOl,qOs-OO!P+cO~P'UOx#{i!X#{i~P$bOx#xi!]#xi#_#xi$j#xi$m#xi!P#xiy#xi!k#xi%X#xi~P$bOx(YO!]%bq~O!]+dO~Oy+eO~Ox(]Oy%pi!]%pi!k%pi~O![#]O%r*`O!]!la~Ox(lO#_$ui$j$ui$m$ui%X$ui~O%SVOx$_X#_$_X$j$_X$m$_X!P$_X~Ox*fO#_%}a$j%}a$m%}a!P%}a~O!P+mO~Ok$dix$di~P$bOq+qOP#eyT#eyd#eyf#eyl#eyp#eys#eyu#ey}#ey!O#ey!S#ey!T#ey!W#ey![#ey!g#ey!n#ey!o#ey!p#ey!w#ey!y#ey!{#ey!}#ey#P#ey#T#ey#V#ey#Y#ey#Z#ey#]#ey#d#ey#g#ey#k#ey#m#ey#r#ey#u#ey$i#ey$j#ey$|#ey$}#ey%R#ey%S#ey%g#ey%h#ey%k#ey%n#ey%t#ey%w#ey%y#ey$m#ey$n#ey$o#ey~O$m+vO$n*wO$o+vO~O#i+wOP#fyT#fyd#fyf#fyl#fyp#fys#fyu#fy}#fy!O#fy!S#fy!T#fy!W#fy![#fy!g#fy!n#fy!o#fy!p#fy!w#fy!y#fy!{#fy!}#fy#P#fy#T#fy#V#fy#Y#fy#Z#fy#]#fy#d#fy#g#fy#k#fy#m#fy#r#fy#u#fy$i#fy$j#fy$|#fy$}#fy%R#fy%S#fy%g#fy%h#fy%k#fy%n#fy%t#fy%w#fy%y#fy$m#fy$n#fy$o#fy~Ox'VOy&Rq~O%X+ROx&Ta!P&Ta~Ox$gX!P$gX~P!IoOx+VO!P&Sa~Ol,qOs-OOy,POx$Oi!X$Oi~P'UOl,qOs-OOx$Oi!X$Oi~P'UOy,POx$Oi!X$Oi~Ox'eO!X%eq~Ol,qOs-OOx'eO!X%eq~P'UOp,UO!S%cO!T%bO!P%]q!X%]q!]%]qx%]q~P!/gOx#|i!]#|i~P$bO#W,YOx$_a#_$_a$j$_a$m$_a!P$_a~Ox*fO#_%}i$j%}i$m%}i!P%}i~O!P,[O~Oq,^OP#e!RT#e!Rd#e!Rf#e!Rl#e!Rp#e!Rs#e!Ru#e!R}#e!R!O#e!R!S#e!R!T#e!R!W#e!R![#e!R!g#e!R!n#e!R!o#e!R!p#e!R!w#e!R!y#e!R!{#e!R!}#e!R#P#e!R#T#e!R#V#e!R#Y#e!R#Z#e!R#]#e!R#d#e!R#g#e!R#k#e!R#m#e!R#r#e!R#u#e!R$i#e!R$j#e!R$|#e!R$}#e!R%R#e!R%S#e!R%g#e!R%h#e!R%k#e!R%n#e!R%t#e!R%w#e!R%y#e!R$m#e!R$n#e!R$o#e!R~Ol,qOs-OOx$Oq!X$Oq~P'UOy,cOx$Oq!X$Oq~Ox'eO!X%ey~Ol,qOs,gO~P'UOp,UO!S%cO!T%bO!P%]y!X%]y!]%]yx%]y~P!/gOx*fO#_%}q$j%}q$m%}q!P%}q~Ol,qOs-OOx$Oy!X$Oy~P'UOx'eO!X%e!R~Op%`X!P%`X!S%`X!T%`X!X%`X!]%`Xx%`X~P!/gOp,UO!S%cO!T%bO!P%_a!X%_a!]%_ax%_a~Oy,oO~Ox(lO#_$ua$j$ua$m$ua%X$ua~P$bOk,vO~Ol,vO~P'UOy,wO~Oq,xO~P!/gO%h%k%w%y%g%n%t%S%g~",
  goto: "!&h&UPPPP&VP&_(|)d){*e+O+jP,VP&_,t,t&_P&_P/cPPPPPP/c1bPP1bP2}P3W7`PP7c7o7rPPP&_&_PP8O&_PP&_&_PP&_&_&_&_8S8x&_P8{P9O9O;qP<V&_PPP<Z<a&VP&V&VP&VP&VP&VP&VP&V&V&VP&VPP&VPP&VP<gP<n<tP<nP<n<nPPP<nP>mP>v>|?S>mP<n?YP?a?g?m?y@T@Z@e@o@uAcAiAoAuBPBVB]BcBiBoCRC]CcCiCoCyDPDVD]DcDmDsD}ETPPPPPPPPPE^EhEqE{FWPPPPPPPPPPPPI}JgNU!!qPP!!y!#X!#b!$W!#}!$a!$g!$j!$m!$p!$vPPPPPPPPPP!$y!$|PPPPPPPPP!%S!%`!%l!%x!%{!&R!&X!&_!&b]iOr#m$m'Q*w&XdOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!j!l!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m$|%R%Y%]%_%b%f%k%m%w&Q&]&a&j&l&m&t&x&{'Q'S'V'a'b'e'g'h'l'q's'w'|(S(Y(](l({)P)T)j)r)u){)|*O*X*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,y,{-Py!cP#i#v$X$g%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u{!dP#i#v$X$g$s%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u}!eP#i#v$X$g$s$t%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u!P!fP#i#v$X$g$s$t$u%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u!R!gP#i#v$X$g$s$t$u$v%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u!T!hP#i#v$X$g$s$t$u$v$w%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u!X!iP!n#i#v$X$g$s$t$u$v$w$x%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u&XSOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!j!l!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m$|%R%Y%]%_%b%f%k%m%w&Q&]&a&j&l&m&t&x&{'Q'S'V'a'b'e'g'h'l'q's'w'|(S(Y(](l({)P)T)j)r)u){)|*O*X*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,y,{-P$yUOXYZhrtv|}!R!S!T!X!j!l!o!p!q!s!t#]#j#m$P$R$T$W$k$m$|%R%Y%]%_%f%k%m%w&]&a&l&m&t&{'Q'S'V'a'b'e'g'h'l's(Y(](l({)T)j)r)u){)|*O*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,{-P$TWOXYZhrv|}!R!S!T!X!j!l#]#j#m$P$R$T$W$k$m$|%R%]%_%f%k%m%w&]&a&l&m&t&{'Q'S'V'a'b'e'g'h'l's(Y(](l({)T)j)r)u){*O*]*e*w+S+Z+[+`+e+|,P,c,w,xQ#|uQ,m,gR,|-O&SdOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!l!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m$|%R%Y%]%_%b%f%k%m%w&Q&]&a&j&l&m&t&x&{'Q'S'V'a'e'g'h'l'q's'w'|(S(Y(](l({)P)T)j)r)u){)|*O*X*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,y,{-PW#pl!O!P$_W#xu&_,g-OQ$a!QQ$q!YQ$r!ZS${!j'bS&^#y#zQ'O$lQ(e&WQ(r&nW(s&p(t(u*kQ(v&rQ)b'XS)c'Z+VS+U)d)eQ+j*fQ+l*hQ+x*}Q+z+PR,j,YR&]#xe!wXY!S!T%_%f's({){*OR%]!vQ!{XQ%x#]Q&f$TR&i$WT,f,U,o!Y!kP!n#i#v$X$g$s$t$u$v$w$x$y%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,uQ&Z#qR'^$rR'a${R%U!m&WcOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!j!l!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m$|%R%Y%]%_%b%f%k%m%w&Q&]&a&j&l&m&t&x&{'Q'S'V'a'b'e'g'h'l'q's'w'|(S(Y(](l({)P)T)j)r)u){)|*O*X*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,y,{-PT#gc#hS#^_#_S#a`#bS#ca#dS#eb#fT*`(`*aT(a%x(cQ$VwR+T)cX$Tw$U$V&hZkOr$m'Q*wXoOr'Q*wQ$n!WQ&v$eQ&w$fQ'Y$pQ']$rQ)U&}Q)['SQ)^'TQ)_'UQ)k'[Q)m'^Q*n({Q*p(|Q*q(}Q*s)SS*u)V)lQ*z)YQ*{)ZQ*|)]Q+o*mQ+p*oQ+r*tQ+s*vQ+y+OQ,]+qQ,_+wQ,`+xR,k,^WoOr'Q*wR#snQ'[$qR)V'OQ+S)cR+|+TQ)l'[R*v)VZmOnr'Q*wQrOR#urQ&`#{R(j&`S%l#Q#}S(T%l(WT(W%o&bQ%`!yS't%`'yR'y%dQ&k$XR(o&kQ%g!|S'}%g(PR(P%iQ(Z%pQ*T(UT*Y(Z*TQ'c$}R)p'cS'f%Q%RY)s'f)t+^,S,dU)t'g'h'iU+^)u)v)wS,S+_+`R,d,TQ#X]R%s#XQ#[^R%u#[Q#__R%y#_Q(^%vS*^(^*_R*_(_Q*a(`R+h*aQ#b`R%{#bQ#daR%|#dQ#fbR%}#fQ#hcR&O#hQ#kfQ&P#iW&S#k&P(m*dQ(m&eR*d,uQ$UwS&g$U&hR&h$VQ&u$cR(y&uQ&X#pR(f&XQ$_!PR&o$_Q*g(sS+k*g,ZR,Z+lQ&s$aR(w&sQ#njR&U#nQ*x)WR+u*xQ(z&vR*l(zQ&y$gS)Q&y)RR)R&zQ'R$nR)X'RQ'W$oS)a'W+QR+Q)bQ+W)gR,O+WWnOr'Q*wR#rnSqOrQ)W'QR+t*wWpOr'Q*wR'P$mYjOr$m'Q*wR&T#m[wOr#m$m'Q*wR&f$T$xPOXYZhrtv|}!R!S!T!X!j!l!o!p!q!s!t#]#j#m$P$R$T$W$k$m$|%R%Y%]%_%f%k%m%w&]&a&l&m&t&{'Q'S'V'a'b'e'g'h'l's(Y(](l({)T)j)r)u){)|*O*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,{-PQ!nSQ#ieQ#vsU$Xx%b'wS$g!U$jQ$s!cQ$t!dQ$u!eQ$v!fQ$w!gQ$x!hQ$y!iQ%d!zQ%i!}Q%o#RQ%p#SQ&b$OQ&z$hQ(d&QQ(n&jQ)O&xQ)y'qQ*Q'|Q*S(SQ*r)PQ+f*XR,u,yQ!yXQ!|YQ$e!SQ$f!TW'p%_'s){*OQ'{%fR*o({[fOr#m$m'Q*wd!vXY!S!T%_%f's({){*OQ#QZQ#lhS#}v|Q$[}W$c!R$W&{)TS$o!X$kS$z!j'bQ%Q!lQ%v#]S&R#j(lQ&c$PQ&d$RQ&e$TQ'_$|Q'i%RQ'o%]Q(R%kQ(U%mQ(_%wQ(h&]S(k&a,wQ(p&lQ(q&mQ(x&tQ)]'SQ)`'VQ)n'aQ)q'eQ)v'gQ)w'hS)x'l,xQ*W(YQ*[(]Q+Y)jQ+])rQ+_)uQ+g*]Q+i*eQ+{+SQ,Q+ZQ,R+[Q,T+`Q,X+eQ,a+|Q,b,PR,l,cbTOr#j#m$m&a'Q'l*w#p!uXYZhv|}!R!S!T!X!j!l#]$P$R$T$W$k$|%R%]%_%f%k%m%w&]&l&m&t&{'S'V'a'b'e'g'h's(Y(](l({)T)j)r)u){*O*]*e+S+Z+[+`+e+|,P,c,w,xQ#wtW%V!o!s,r,{Q%W!pQ%X!qQ%Z!tQ%e,qS'k%Y,vQ'm,sQ'n,tQ+a)|Q,W+bS,e,U,oR,}-PU#{u,g-OR(i&_[gOr#m$m'Q*wX!xX#]$T$WQ#VZQ$QvR$Z|Q%a!yQ%h!|Q%n#QQ'_$zQ'z%dQ(Q%iQ(X%oQ([%pQ*U(UQ,V+aQ,i,WR,n,hQ$YxQ'v%bR)}'wQ,h,UR,p,oR#PYR#UZR%P!jQ$}!jR)o'bR%S!lR%x#]Q(b%xR*c(cQ$d!RQ&i$WQ)S&{R*t)TQ#qlQ$]!OQ$`!PR&q$_Q(r&pQ*i(tQ*j(uR+n*kR$b!QXpOr'Q*wQ$i!UR&|$jQ$p!XR&}$kR)i'ZQ)g'ZR+}+V",
  nodeNames: "⚠ print Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ParenthesizedExpression ( BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList self VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from ) TupleExpression ComprehensionExpression async for LambdaExpression ArrayExpression [ ] ArrayComprehensionExpression DictionaryExpression { } DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatConversion FormatSpec ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At",
  maxTerm: 236,
  nodeProps: [
    [lezer__WEBPACK_IMPORTED_MODULE_0__.NodeProp.group, -14,4,81,83,84,86,88,90,92,94,95,96,98,101,104,"Statement Statement",-23,6,16,19,21,37,38,48,49,53,56,57,60,61,62,63,66,69,70,71,75,76,77,78,"Expression",-9,106,108,111,113,114,118,120,125,127,"Statement"]
  ],
  skippedNodes: [0,2],
  repeatNodeCount: 33,
  tokenData: "!E}MgR!^OX$}XY%wY[$}[]%w]p$}pq%wqr(crs*Ust2Otu$}uv4Qvw5Uwx5xxyAWyzAtz{Bb{|Cr|}Df}!OES!O!PFZ!P!QKa!Q!RLq!R![!(P![!]!)i!]!^!*m!^!_!+Z!_!`!,k!`!a!-_!a!b$}!b!c!.l!c!d!/b!d!e!1f!e!h!/b!h!i!8O!i!t!/b!t!u!=b!u!w!/b!w!x!?`!x!}!/b!}#O!@t#O#P!Ab#P#Q!Bc#Q#R!CP#R#S!/b#S#T$}#T#U!/b#U#V!1f#V#Y!/b#Y#Z!8O#Z#f!/b#f#g!=b#g#i!/b#i#j!?`#j#o!/b#o#p!Cs#p#q!D[#q#r!EO#r#s!Ea#s$g$}$g~!/b<r%`R%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%i7[%nR%r7[O#o%i#p#q%i#r~%iMg&[Z%o`%up%r7[%x!b%z#t%iS%lW$q1sOX%iXY&}Y[%i[]&}]p%ipq&}q#O%i#O#P'w#P#o%i#p#q%i#r~%iHP'UZ%r7[$q1sOX%iXY&}Y[%i[]&}]p%ipq&}q#O%i#O#P'w#P#o%i#p#q%i#r~%iHP'|V%r7[OY%iYZ&}Z]%i]^&}^#o%i#p#q%i#r~%i<u(tY%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`)d!`#T%i#T#U)t#U#f%i#f#g)t#g#h)t#h#o%i#p#q%i#r~%i7_)kRjR%r7[O#o%i#p#q%i#r~%i7_){R!kR%r7[O#o%i#p#q%i#r~%iG{*e]%vp%o`%r7[%x!b%iS%g,XOY+^YZ.{Z]+^]^.{^r+^rs/]s#O+^#O#P0|#P#o+^#o#p1b#p#q+^#q#r1b#r~+^Bm+g]%r7[%lW%g,XOY,`YZ%iZ],`]^%i^r,`rs-`s#O,`#O#P-p#P#o,`#o#p.U#p#q,`#q#r.U#r~,`Be,g]%r7[%g,XOY,`YZ%iZ],`]^%i^r,`rs-`s#O,`#O#P-p#P#o,`#o#p.U#p#q,`#q#r.U#r~,`Be-gR%r7[%g,XO#o%i#p#q%i#r~%iBe-uT%r7[O#o,`#o#p.U#p#q,`#q#r.U#r~,`,X.ZV%g,XOY.UZ].U^r.Urs.ps#O.U#O#P.u#P~.U,X.uO%g,X,X.xPO~.U7d/SR%r7[%lWO#o%i#p#q%i#r~%iEc/dX%r7[%g,XOr.{rs0Ps#O.{#O#P0c#P#o.{#o#p0w#p#q.{#q#r0w#r~.{Ec0YR%m#|%r7[%k,XO#o%i#p#q%i#r~%i7d0hT%r7[O#o.{#o#p0w#p#q.{#q#r0w#r~.{W0|O%lWBm1RT%r7[O#o+^#o#p1b#p#q+^#q#r1b#r~+^,a1iV%lW%g,XOY.UZ].U^r.Urs.ps#O.U#O#P.u#P~.UMg2cXQ1s%o`%up%r7[%x!b%z#t%iS%lWOY3OYZ%iZ]3O]^%i^#o3O#o#p3r#p#q3O#q#r3r#r~3OHP3VXQ1s%r7[OY3OYZ%iZ]3O]^%i^#o3O#o#p3r#p#q3O#q#r3r#r~3O1s3wRQ1sOY3rZ]3r^~3rGz4eT%PQ%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%iBd4{R!t,W%r7[O#o%i#p#q%i#r~%iGz5iT$yQ%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%iG{6X_%s`%up%r7[%z#t%lW%g,XOY7WYZ:dZ]7W]^:d^r7Wrs:xsw7Wwx;|x#O7W#O#P>n#P#o7W#o#p?t#p#q7W#q#r?S#r~7WFq7e]%r7[%x!b%z#t%iS%g,XOY8^YZ%iZ]8^]^%i^w8^wx-`x#O8^#O#P9^#P#o8^#o#p9r#p#q8^#q#r9r#r~8^Be8e]%r7[%g,XOY8^YZ%iZ]8^]^%i^w8^wx-`x#O8^#O#P9^#P#o8^#o#p9r#p#q8^#q#r9r#r~8^Be9cT%r7[O#o8^#o#p9r#p#q8^#q#r9r#r~8^,X9wV%g,XOY9rZ]9r^w9rwx.px#O9r#O#P:^#P~9r,X:aPO~9r;h:oR%r7[%x!b%z#t%iSO#o%i#p#q%i#r~%iC{;T]%r7[%x!b%iS%g,XOY8^YZ%iZ]8^]^%i^w8^wx-`x#O8^#O#P9^#P#o8^#o#p9r#p#q8^#q#r9r#r~8^Fq<VZ%r7[%z#t%g,XOr:drs<xsw:dwx=[x#O:d#O#P=p#P#o:d#o#p>_#p#q:d#q#r>U#r~:d8r=RR%r7[%x!b%iSO#o%i#p#q%i#r~%iFq=gR%j!f%r7[%z#t%h,XO#o%i#p#q%i#r~%i;h=uT%r7[O#o:d#o#p>U#p#q:d#q#r>U#r~:d%[>_O%x!b%z#t%iS%[>dP%iS#o#p>g%W>nO%x!b%z#tFq>sT%r7[O#o7W#o#p?S#p#q7W#q#r?S#r~7W0e?_V%x!b%z#t%iS%g,XOY9rZ]9r^w9rwx.px#O9r#O#P:^#P~9r0e?{X%iS%g,XOY9rZ]9r^w9rwx.px#O9r#O#P:^#P#o9r#o#p@h#p~9r0a@qV%x!b%z#t%g,XOY9rZ]9r^w9rwx.px#O9r#O#P:^#P~9rG{AkRf,X%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%i<uBXR!PR%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%iG{BuVT,X%o`%up%r7[%x!b%z#t%iS%lWOz%iz{C[{!_%i!_!`4t!`#o%i#p#q%i#r~%iBeCcT_R%r7[O!_%i!_!`4t!`#o%i#p#q%i#r~%iG{DVT$|,X%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%iG{DyRx,X%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%iMgEgU$},X%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`!aEy!a#o%i#p#q%i#r~%i<vFQR&U&j%r7[O#o%i#p#q%i#r~%iG{FnV!eQ%o`%up%r7[%x!b%z#t%iS%lWO!O%i!O!PGT!P!Q%i!Q![Gy![#o%i#p#q%i#r~%iBeGYT%r7[O!O%i!O!PGi!P#o%i#p#q%i#r~%iBeGpR!n,X%r7[O#o%i#p#q%i#r~%iBcHQ_!g,V%r7[O!Q%i!Q![Gy![!g%i!g!hIP!h!l%i!l!mKP!m#R%i#R#SGy#S#X%i#X#YIP#Y#^%i#^#_KP#_#o%i#p#q%i#r~%iBcIUX%r7[O{%i{|Iq|}%i}!OIq!O!Q%i!Q![JV![#o%i#p#q%i#r~%iBcIvT%r7[O!Q%i!Q![JV![#o%i#p#q%i#r~%iBcJ^Z!g,V%r7[O!Q%i!Q![JV![!l%i!l!mKP!m#R%i#R#SJV#S#^%i#^#_KP#_#o%i#p#q%i#r~%iBcKWR!g,V%r7[O#o%i#p#q%i#r~%iG{KtV%OR%o`%up%r7[%x!b%z#t%iS%lWO!P%i!P!QLZ!Q!_%i!_!`4t!`#o%i#p#q%i#r~%iBdLbT%QQ%r7[O!_%i!_!`4t!`#o%i#p#q%i#r~%iGyMUm!g,V%o`%up%r7[%x!b%z#t%iS%lWO!O%i!O!P! P!P!Q%i!Q![!!k![!d%i!d!e!#w!e!g%i!g!hIP!h!l%i!l!mKP!m!q%i!q!r!%V!r!z%i!z!{!&_!{#R%i#R#S!!k#S#U%i#U#V!#w#V#X%i#X#YIP#Y#^%i#^#_KP#_#c%i#c#d!%V#d#l%i#l#m!&_#m#o%i#p#q%i#r~%iBc! UT%r7[O!Q%i!Q![! e![#o%i#p#q%i#r~%iBc! l_!g,V%r7[O!Q%i!Q![! e![!g%i!g!hIP!h!l%i!l!mKP!m#R%i#R#S! e#S#X%i#X#YIP#Y#^%i#^#_KP#_#o%i#p#q%i#r~%iBc!!ra!g,V%r7[O!O%i!O!P! P!P!Q%i!Q![!!k![!g%i!g!hIP!h!l%i!l!mKP!m#R%i#R#S!!k#S#X%i#X#YIP#Y#^%i#^#_KP#_#o%i#p#q%i#r~%iBc!#|W%r7[O!Q%i!Q!R!$f!R!S!$f!S#R%i#R#S!$f#S#o%i#p#q%i#r~%iBc!$mW!g,V%r7[O!Q%i!Q!R!$f!R!S!$f!S#R%i#R#S!$f#S#o%i#p#q%i#r~%iBc!%[V%r7[O!Q%i!Q!Y!%q!Y#R%i#R#S!%q#S#o%i#p#q%i#r~%iBc!%xV!g,V%r7[O!Q%i!Q!Y!%q!Y#R%i#R#S!%q#S#o%i#p#q%i#r~%iBc!&dZ%r7[O!Q%i!Q![!'V![!c%i!c!i!'V!i#R%i#R#S!'V#S#T%i#T#Z!'V#Z#o%i#p#q%i#r~%iBc!'^Z!g,V%r7[O!Q%i!Q![!'V![!c%i!c!i!'V!i#R%i#R#S!'V#S#T%i#T#Z!'V#Z#o%i#p#q%i#r~%iGy!(da!g,V%o`%up%r7[%x!b%z#t%iS%lWO!O%i!O!P! P!P!Q%i!Q![!!k![!g%i!g!hIP!h!l%i!l!mKP!m#R%i#R#S!!k#S#X%i#X#YIP#Y#^%i#^#_KP#_#o%i#p#q%i#r~%iMg!)|Ty1s%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`!*]!`#o%i#p#q%i#r~%i7_!*dR%YR%r7[O#o%i#p#q%i#r~%iG{!+QR#_,X%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%iG{!+nVjR%o`%up%r7[%x!b%z#t%iS%lWO!^%i!^!_!,T!_!`)d!`!a)d!a#o%i#p#q%i#r~%iBd!,[T$zQ%r7[O!_%i!_!`4t!`#o%i#p#q%i#r~%iG{!-OT%X,X%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`)d!`#o%i#p#q%i#r~%iG{!-rUjR%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`)d!`!a!.U!a#o%i#p#q%i#r~%iBd!.]T${Q%r7[O!_%i!_!`4t!`#o%i#p#q%i#r~%iG{!/RT]Q#uP%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%iMg!/wZ%o`%up%r7[%x!b%z#t%iS%lW%f&j%S,XO!Q%i!Q![!0j![!c%i!c!}!0j!}#R%i#R#S!0j#S#T%i#T#o!0j#p#q%i#r$g%i$g~!0jHP!0sZ%r7[%f&j%S,XO!Q%i!Q![!0j![!c%i!c!}!0j!}#R%i#R#S!0j#S#T%i#T#o!0j#p#q%i#r$g%i$g~!0jMg!1{c%o`%up%r7[%x!b%z#t%iS%lW%f&j%S,XOr%irs!3Wsw%iwx!5Ox!Q%i!Q![!0j![!c%i!c!t!0j!t!u!6v!u!}!0j!}#R%i#R#S!0j#S#T%i#T#f!0j#f#g!6v#g#o!0j#p#q%i#r$g%i$g~!0jBe!3_]%r7[%g,XOY,`YZ%iZ],`]^%i^r,`rs!4Ws#O,`#O#P-p#P#o,`#o#p.U#p#q,`#q#r.U#r~,`Be!4_T%r7[%g,XOr%irs!4ns#o%i#p#q%i#r~%iBe!4uR%r7[%k,XO#o%i#p#q%i#r~%iBe!5V]%r7[%g,XOY8^YZ%iZ]8^]^%i^w8^wx!6Ox#O8^#O#P9^#P#o8^#o#p9r#p#q8^#q#r9r#r~8^Be!6VT%r7[%g,XOw%iwx!6fx#o%i#p#q%i#r~%iBe!6mR%r7[%h,XO#o%i#p#q%i#r~%iHP!7P_%r7[%f&j%S,XOr%irs!3Wsw%iwx!5Ox!Q%i!Q![!0j![!c%i!c!}!0j!}#R%i#R#S!0j#S#T%i#T#o!0j#p#q%i#r$g%i$g~!0jMg!8ec%o`%up%r7[%x!b%z#t%iS%lW%f&j%S,XOr%irs!9psw%iwx!:|x!Q%i!Q![!0j![!c%i!c!t!0j!t!u!<Y!u!}!0j!}#R%i#R#S!0j#S#T%i#T#f!0j#f#g!<Y#g#o!0j#p#q%i#r$g%i$g~!0jBe!9wT%r7[%t,XOr%irs!:Ws#o%i#p#q%i#r~%iBe!:]T%r7[Or%irs!:ls#o%i#p#q%i#r~%iBe!:sR%r7[%y,XO#o%i#p#q%i#r~%iBe!;TT%r7[%n,XOw%iwx!;dx#o%i#p#q%i#r~%iBe!;iT%r7[Ow%iwx!;xx#o%i#p#q%i#r~%iBe!<PR%r7[%w,XO#o%i#p#q%i#r~%iHP!<c_%r7[%f&j%S,XOr%irs!9psw%iwx!:|x!Q%i!Q![!0j![!c%i!c!}!0j!}#R%i#R#S!0j#S#T%i#T#o!0j#p#q%i#r$g%i$g~!0jMg!=wg%o`%up%r7[%x!b%z#t%iS%lW%f&j%S,XOr%irs!3Wsw%iwx!5Ox!Q%i!Q![!0j![!c%i!c!h!0j!h!i!<Y!i!t!0j!t!u!6v!u!}!0j!}#R%i#R#S!0j#S#T%i#T#U!0j#U#V!6v#V#Y!0j#Y#Z!<Y#Z#o!0j#p#q%i#r$g%i$g~!0jMg!?u_%o`%up%r7[%x!b%z#t%iS%lW%f&j%S,XOr%irs!3Wsw%iwx!5Ox!Q%i!Q![!0j![!c%i!c!}!0j!}#R%i#R#S!0j#S#T%i#T#o!0j#p#q%i#r$g%i$g~!0jG{!AXR!W,X%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%iMg!AgX%r7[OY$}YZ%wZ]$}]^%w^#o$}#o#p!BS#p#q$}#q#r!BS#r~$}&f!BcO%o`%up%x!b%z#t%iS%lW<u!BvR!XR%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%iGz!CdT$xQ%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%iGy!C|P![Gm%iS%lW#o#p!DP&Y!D[O%o`%up%x!b%z#tGz!DoT$wQ%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%i<u!EaO!]7_%o`%up%x!b%z#t%iS%lWGy!EtR%R,V%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%i",
  tokenizers: [legacyPrint, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, newlines, bodyContinue],
  topRules: {"Script":[0,3]},
  specialized: [{term: 188, get: value => spec_identifier[value] || -1}],
  tokenPrec: 6067
});




/***/ }),

/***/ "./node_modules/lezer-tree/dist/tree.es.js":
/*!*************************************************!*
  !*** ./node_modules/lezer-tree/dist/tree.es.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DefaultBufferLength": () => /* binding */ DefaultBufferLength,
/* harmony export */   "NodeProp": () => /* binding */ NodeProp,
/* harmony export */   "NodeSet": () => /* binding */ NodeSet,
/* harmony export */   "NodeType": () => /* binding */ NodeType,
/* harmony export */   "Tree": () => /* binding */ Tree,
/* harmony export */   "TreeBuffer": () => /* binding */ TreeBuffer,
/* harmony export */   "TreeCursor": () => /* binding */ TreeCursor,
/* harmony export */   "TreeFragment": () => /* binding */ TreeFragment,
/* harmony export */   "stringInput": () => /* binding */ stringInput
/* harmony export */ });
/// The default maximum length of a `TreeBuffer` node.
const DefaultBufferLength = 1024;
let nextPropID = 0;
const CachedNode = new WeakMap();
/// Each [node type](#tree.NodeType) can have metadata associated with
/// it in props. Instances of this class represent prop names.
class NodeProp {
    /// Create a new node prop type. You can optionally pass a
    /// `deserialize` function.
    constructor({ deserialize } = {}) {
        this.id = nextPropID++;
        this.deserialize = deserialize || (() => {
            throw new Error("This node type doesn't define a deserialize function");
        });
    }
    /// Create a string-valued node prop whose deserialize function is
    /// the identity function.
    static string() { return new NodeProp({ deserialize: str => str }); }
    /// Create a number-valued node prop whose deserialize function is
    /// just `Number`.
    static number() { return new NodeProp({ deserialize: Number }); }
    /// Creates a boolean-valued node prop whose deserialize function
    /// returns true for any input.
    static flag() { return new NodeProp({ deserialize: () => true }); }
    /// Store a value for this prop in the given object. This can be
    /// useful when building up a prop object to pass to the
    /// [`NodeType`](#tree.NodeType) constructor. Returns its first
    /// argument.
    set(propObj, value) {
        propObj[this.id] = value;
        return propObj;
    }
    /// This is meant to be used with
    /// [`NodeSet.extend`](#tree.NodeSet.extend) or
    /// [`Parser.withProps`](#lezer.Parser.withProps) to compute prop
    /// values for each node type in the set. Takes a [match
    /// object](#tree.NodeType^match) or function that returns undefined
    /// if the node type doesn't get this prop, and the prop's value if
    /// it does.
    add(match) {
        if (typeof match != "function")
            match = NodeType.match(match);
        return (type) => {
            let result = match(type);
            return result === undefined ? null : [this, result];
        };
    }
}
/// Prop that is used to describe matching delimiters. For opening
/// delimiters, this holds an array of node names (written as a
/// space-separated string when declaring this prop in a grammar)
/// for the node types of closing delimiters that match it.
NodeProp.closedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// The inverse of [`openedBy`](#tree.NodeProp^closedBy). This is
/// attached to closing delimiters, holding an array of node names
/// of types of matching opening delimiters.
NodeProp.openedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// Used to assign node types to groups (for example, all node
/// types that represent an expression could be tagged with an
/// `"Expression"` group).
NodeProp.group = new NodeProp({ deserialize: str => str.split(" ") });
const noProps = Object.create(null);
/// Each node in a syntax tree has a node type associated with it.
class NodeType {
    /// @internal
    constructor(
    /// The name of the node type. Not necessarily unique, but if the
    /// grammar was written properly, different node types with the
    /// same name within a node set should play the same semantic
    /// role.
    name, 
    /// @internal
    props, 
    /// The id of this node in its set. Corresponds to the term ids
    /// used in the parser.
    id, 
    /// @internal
    flags = 0) {
        this.name = name;
        this.props = props;
        this.id = id;
        this.flags = flags;
    }
    static define(spec) {
        let props = spec.props && spec.props.length ? Object.create(null) : noProps;
        let flags = (spec.top ? 1 /* Top */ : 0) | (spec.skipped ? 2 /* Skipped */ : 0) |
            (spec.error ? 4 /* Error */ : 0) | (spec.name == null ? 8 /* Anonymous */ : 0);
        let type = new NodeType(spec.name || "", props, spec.id, flags);
        if (spec.props)
            for (let src of spec.props) {
                if (!Array.isArray(src))
                    src = src(type);
                if (src)
                    src[0].set(props, src[1]);
            }
        return type;
    }
    /// Retrieves a node prop for this type. Will return `undefined` if
    /// the prop isn't present on this node.
    prop(prop) { return this.props[prop.id]; }
    /// True when this is the top node of a grammar.
    get isTop() { return (this.flags & 1 /* Top */) > 0; }
    /// True when this node is produced by a skip rule.
    get isSkipped() { return (this.flags & 2 /* Skipped */) > 0; }
    /// Indicates whether this is an error node.
    get isError() { return (this.flags & 4 /* Error */) > 0; }
    /// When true, this node type doesn't correspond to a user-declared
    /// named node, for example because it is used to cache repetition.
    get isAnonymous() { return (this.flags & 8 /* Anonymous */) > 0; }
    /// Returns true when this node's name or one of its
    /// [groups](#tree.NodeProp^group) matches the given string.
    is(name) {
        if (typeof name == 'string') {
            if (this.name == name)
                return true;
            let group = this.prop(NodeProp.group);
            return group ? group.indexOf(name) > -1 : false;
        }
        return this.id == name;
    }
    /// Create a function from node types to arbitrary values by
    /// specifying an object whose property names are node or
    /// [group](#tree.NodeProp^group) names. Often useful with
    /// [`NodeProp.add`](#tree.NodeProp.add). You can put multiple
    /// names, separated by spaces, in a single property name to map
    /// multiple node names to a single value.
    static match(map) {
        let direct = Object.create(null);
        for (let prop in map)
            for (let name of prop.split(" "))
                direct[name] = map[prop];
        return (node) => {
            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
                let found = direct[i < 0 ? node.name : groups[i]];
                if (found)
                    return found;
            }
        };
    }
}
/// An empty dummy node type to use when no actual type is available.
NodeType.none = new NodeType("", Object.create(null), 0, 8 /* Anonymous */);
/// A node set holds a collection of node types. It is used to
/// compactly represent trees by storing their type ids, rather than a
/// full pointer to the type object, in a number array. Each parser
/// [has](#lezer.Parser.nodeSet) a node set, and [tree
/// buffers](#tree.TreeBuffer) can only store collections of nodes
/// from the same set. A set can have a maximum of 2**16 (65536)
/// node types in it, so that the ids fit into 16-bit typed array
/// slots.
class NodeSet {
    /// Create a set with the given types. The `id` property of each
    /// type should correspond to its position within the array.
    constructor(
    /// The node types in this set, by id.
    types) {
        this.types = types;
        for (let i = 0; i < types.length; i++)
            if (types[i].id != i)
                throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    /// Create a copy of this set with some node properties added. The
    /// arguments to this method should be created with
    /// [`NodeProp.add`](#tree.NodeProp.add).
    extend(...props) {
        let newTypes = [];
        for (let type of this.types) {
            let newProps = null;
            for (let source of props) {
                let add = source(type);
                if (add) {
                    if (!newProps)
                        newProps = Object.assign({}, type.props);
                    add[0].set(newProps, add[1]);
                }
            }
            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
        }
        return new NodeSet(newTypes);
    }
}
/// A piece of syntax tree. There are two ways to approach these
/// trees: the way they are actually stored in memory, and the
/// convenient way.
///
/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`
/// objects. By packing detail information into `TreeBuffer` leaf
/// nodes, the representation is made a lot more memory-efficient.
///
/// However, when you want to actually work with tree nodes, this
/// representation is very awkward, so most client code will want to
/// use the `TreeCursor` interface instead, which provides a view on
/// some part of this data structure, and can be used to move around
/// to adjacent nodes.
class Tree {
    /// Construct a new tree. You usually want to go through
    /// [`Tree.build`](#tree.Tree^build) instead.
    constructor(type, 
    /// The tree's child nodes. Children small enough to fit in a
    /// `TreeBuffer will be represented as such, other children can be
    /// further `Tree` instances with their own internal structure.
    children, 
    /// The positions (offsets relative to the start of this tree) of
    /// the children.
    positions, 
    /// The total length of this tree
    length) {
        this.type = type;
        this.children = children;
        this.positions = positions;
        this.length = length;
    }
    /// @internal
    toString() {
        let children = this.children.map(c => c.toString()).join();
        return !this.type.name ? children :
            (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +
                (children.length ? "(" + children + ")" : "");
    }
    /// Get a [tree cursor](#tree.TreeCursor) rooted at this tree. When
    /// `pos` is given, the cursor is [moved](#tree.TreeCursor.moveTo)
    /// to the given position and side.
    cursor(pos, side = 0) {
        let scope = (pos != null && CachedNode.get(this)) || this.topNode;
        let cursor = new TreeCursor(scope);
        if (pos != null) {
            cursor.moveTo(pos, side);
            CachedNode.set(this, cursor._tree);
        }
        return cursor;
    }
    /// Get a [tree cursor](#tree.TreeCursor) that, unlike regular
    /// cursors, doesn't skip [anonymous](#tree.NodeType.isAnonymous)
    /// nodes.
    fullCursor() {
        return new TreeCursor(this.topNode, true);
    }
    /// Get a [syntax node](#tree.SyntaxNode) object for the top of the
    /// tree.
    get topNode() {
        return new TreeNode(this, 0, 0, null);
    }
    /// Get the [syntax node](#tree.SyntaxNode) at the given position.
    /// If `side` is -1, this will move into nodes that end at the
    /// position. If 1, it'll move into nodes that start at the
    /// position. With 0, it'll only enter nodes that cover the position
    /// from both sides.
    resolve(pos, side = 0) {
        return this.cursor(pos, side).node;
    }
    /// Iterate over the tree and its children, calling `enter` for any
    /// node that touches the `from`/`to` region (if given) before
    /// running over such a node's children, and `leave` (if given) when
    /// leaving the node. When `enter` returns `false`, the given node
    /// will not have its children iterated over (or `leave` called).
    iterate(spec) {
        let { enter, leave, from = 0, to = this.length } = spec;
        for (let c = this.cursor();;) {
            let mustLeave = false;
            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to) !== false)) {
                if (c.firstChild())
                    continue;
                if (!c.type.isAnonymous)
                    mustLeave = true;
            }
            for (;;) {
                if (mustLeave && leave)
                    leave(c.type, c.from, c.to);
                mustLeave = c.type.isAnonymous;
                if (c.nextSibling())
                    break;
                if (!c.parent())
                    return;
                mustLeave = true;
            }
        }
    }
    /// Balance the direct children of this tree.
    balance(maxBufferLength = DefaultBufferLength) {
        return this.children.length <= BalanceBranchFactor ? this
            : balanceRange(this.type, NodeType.none, this.children, this.positions, 0, this.children.length, 0, maxBufferLength, this.length);
    }
    /// Build a tree from a postfix-ordered buffer of node information,
    /// or a cursor over such a buffer.
    static build(data) { return buildTree(data); }
}
/// The empty tree
Tree.empty = new Tree(NodeType.none, [], [], 0);
/// Tree buffers contain (type, start, end, endIndex) quads for each
/// node. In such a buffer, nodes are stored in prefix order (parents
/// before children, with the endIndex of the parent indicating which
/// children belong to it)
class TreeBuffer {
    /// Create a tree buffer @internal
    constructor(
    /// @internal
    buffer, 
    // The total length of the group of nodes in the buffer.
    length, 
    /// @internal
    set, type = NodeType.none) {
        this.buffer = buffer;
        this.length = length;
        this.set = set;
        this.type = type;
    }
    /// @internal
    toString() {
        let result = [];
        for (let index = 0; index < this.buffer.length;) {
            result.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result.join(",");
    }
    /// @internal
    childString(index) {
        let id = this.buffer[index], endIndex = this.buffer[index + 3];
        let type = this.set.types[id], result = type.name;
        if (/\W/.test(result) && !type.isError)
            result = JSON.stringify(result);
        index += 4;
        if (endIndex == index)
            return result;
        let children = [];
        while (index < endIndex) {
            children.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result + "(" + children.join(",") + ")";
    }
    /// @internal
    findChild(startIndex, endIndex, dir, after) {
        let { buffer } = this, pick = -1;
        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
            if (after != -100000000 /* None */) {
                let start = buffer[i + 1], end = buffer[i + 2];
                if (dir > 0) {
                    if (end > after)
                        pick = i;
                    if (end > after)
                        break;
                }
                else {
                    if (start < after)
                        pick = i;
                    if (end >= after)
                        break;
                }
            }
            else {
                pick = i;
                if (dir > 0)
                    break;
            }
        }
        return pick;
    }
}
class TreeNode {
    constructor(node, from, index, _parent) {
        this.node = node;
        this.from = from;
        this.index = index;
        this._parent = _parent;
    }
    get type() { return this.node.type; }
    get name() { return this.node.type.name; }
    get to() { return this.from + this.node.length; }
    nextChild(i, dir, after, full = false) {
        for (let parent = this;;) {
            for (let { children, positions } = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {
                let next = children[i], start = positions[i] + parent.from;
                if (after != -100000000 /* None */ && (dir < 0 ? start >= after : start + next.length <= after))
                    continue;
                if (next instanceof TreeBuffer) {
                    let index = next.findChild(0, next.buffer.length, dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - start);
                    if (index > -1)
                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);
                }
                else if (full || (!next.type.isAnonymous || hasChild(next))) {
                    let inner = new TreeNode(next, start, i, parent);
                    return full || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, after);
                }
            }
            if (full || !parent.type.isAnonymous)
                return null;
            i = parent.index + dir;
            parent = parent._parent;
            if (!parent)
                return null;
        }
    }
    get firstChild() { return this.nextChild(0, 1, -100000000 /* None */); }
    get lastChild() { return this.nextChild(this.node.children.length - 1, -1, -100000000 /* None */); }
    childAfter(pos) { return this.nextChild(0, 1, pos); }
    childBefore(pos) { return this.nextChild(this.node.children.length - 1, -1, pos); }
    nextSignificantParent() {
        let val = this;
        while (val.type.isAnonymous && val._parent)
            val = val._parent;
        return val;
    }
    get parent() {
        return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
        return this._parent ? this._parent.nextChild(this.index + 1, 1, -1) : null;
    }
    get prevSibling() {
        return this._parent ? this._parent.nextChild(this.index - 1, -1, -1) : null;
    }
    get cursor() { return new TreeCursor(this); }
    resolve(pos, side = 0) {
        return this.cursor.moveTo(pos, side).node;
    }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
    /// @internal
    toString() { return this.node.toString(); }
}
function getChildren(node, type, before, after) {
    let cur = node.cursor, result = [];
    if (!cur.firstChild())
        return result;
    if (before != null)
        while (!cur.type.is(before))
            if (!cur.nextSibling())
                return result;
    for (;;) {
        if (after != null && cur.type.is(after))
            return result;
        if (cur.type.is(type))
            result.push(cur.node);
        if (!cur.nextSibling())
            return after == null ? result : [];
    }
}
class BufferContext {
    constructor(parent, buffer, index, start) {
        this.parent = parent;
        this.buffer = buffer;
        this.index = index;
        this.start = start;
    }
}
class BufferNode {
    constructor(context, _parent, index) {
        this.context = context;
        this._parent = _parent;
        this.index = index;
        this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
    get name() { return this.type.name; }
    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }
    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }
    child(dir, after) {
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - this.context.start);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get firstChild() { return this.child(1, -100000000 /* None */); }
    get lastChild() { return this.child(-1, -100000000 /* None */); }
    childAfter(pos) { return this.child(1, pos); }
    childBefore(pos) { return this.child(-1, pos); }
    get parent() {
        return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, -1);
    }
    get nextSibling() {
        let { buffer } = this.context;
        let after = buffer.buffer[this.index + 3];
        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
            return new BufferNode(this.context, this._parent, after);
        return this.externalSibling(1);
    }
    get prevSibling() {
        let { buffer } = this.context;
        let parentStart = this._parent ? this._parent.index + 4 : 0;
        if (this.index == parentStart)
            return this.externalSibling(-1);
        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, -100000000 /* None */));
    }
    get cursor() { return new TreeCursor(this); }
    resolve(pos, side = 0) {
        return this.cursor.moveTo(pos, side).node;
    }
    /// @internal
    toString() { return this.context.buffer.childString(this.index); }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
}
/// A tree cursor object focuses on a given node in a syntax tree, and
/// allows you to move to adjacent nodes.
class TreeCursor {
    /// @internal
    constructor(node, full = false) {
        this.full = full;
        this.buffer = null;
        this.stack = [];
        this.index = 0;
        this.bufferNode = null;
        if (node instanceof TreeNode) {
            this.yieldNode(node);
        }
        else {
            this._tree = node.context.parent;
            this.buffer = node.context;
            for (let n = node._parent; n; n = n._parent)
                this.stack.unshift(n.index);
            this.bufferNode = node;
            this.yieldBuf(node.index);
        }
    }
    /// Shorthand for `.type.name`.
    get name() { return this.type.name; }
    yieldNode(node) {
        if (!node)
            return false;
        this._tree = node;
        this.type = node.type;
        this.from = node.from;
        this.to = node.to;
        return true;
    }
    yieldBuf(index, type) {
        this.index = index;
        let { start, buffer } = this.buffer;
        this.type = type || buffer.set.types[buffer.buffer[index]];
        this.from = start + buffer.buffer[index + 1];
        this.to = start + buffer.buffer[index + 2];
        return true;
    }
    yield(node) {
        if (!node)
            return false;
        if (node instanceof TreeNode) {
            this.buffer = null;
            return this.yieldNode(node);
        }
        this.buffer = node.context;
        return this.yieldBuf(node.index, node.type);
    }
    /// @internal
    toString() {
        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    /// @internal
    enter(dir, after) {
        if (!this.buffer)
            return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, after, this.full));
        let { buffer } = this.buffer;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - this.buffer.start);
        if (index < 0)
            return false;
        this.stack.push(this.index);
        return this.yieldBuf(index);
    }
    /// Move the cursor to this node's first child. When this returns
    /// false, the node has no child, and the cursor has not been moved.
    firstChild() { return this.enter(1, -100000000 /* None */); }
    /// Move the cursor to this node's last child.
    lastChild() { return this.enter(-1, -100000000 /* None */); }
    /// Move the cursor to the first child that starts at or after `pos`.
    childAfter(pos) { return this.enter(1, pos); }
    /// Move to the last child that ends at or before `pos`.
    childBefore(pos) { return this.enter(-1, pos); }
    /// Move the node's parent node, if this isn't the top node.
    parent() {
        if (!this.buffer)
            return this.yieldNode(this.full ? this._tree._parent : this._tree.parent);
        if (this.stack.length)
            return this.yieldBuf(this.stack.pop());
        let parent = this.full ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
        this.buffer = null;
        return this.yieldNode(parent);
    }
    /// @internal
    sibling(dir) {
        if (!this.buffer)
            return !this._tree._parent ? false
                : this.yield(this._tree._parent.nextChild(this._tree.index + dir, dir, -100000000 /* None */, this.full));
        let { buffer } = this.buffer, d = this.stack.length - 1;
        if (dir < 0) {
            let parentStart = d < 0 ? 0 : this.stack[d] + 4;
            if (this.index != parentStart)
                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, -100000000 /* None */));
        }
        else {
            let after = buffer.buffer[this.index + 3];
            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
                return this.yieldBuf(after);
        }
        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, -100000000 /* None */, this.full)) : false;
    }
    /// Move to this node's next sibling, if any.
    nextSibling() { return this.sibling(1); }
    /// Move to this node's previous sibling, if any.
    prevSibling() { return this.sibling(-1); }
    atLastNode(dir) {
        let index, parent, { buffer } = this;
        if (buffer) {
            if (dir > 0) {
                if (this.index < buffer.buffer.buffer.length)
                    return false;
            }
            else {
                for (let i = 0; i < this.index; i++)
                    if (buffer.buffer.buffer[i + 3] < this.index)
                        return false;
            }
            ({ index, parent } = buffer);
        }
        else {
            ({ index, _parent: parent } = this._tree);
        }
        for (; parent; { index, _parent: parent } = parent) {
            for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {
                let child = parent.node.children[i];
                if (this.full || !child.type.isAnonymous || child instanceof TreeBuffer || hasChild(child))
                    return false;
            }
        }
        return true;
    }
    move(dir) {
        if (this.enter(dir, -100000000 /* None */))
            return true;
        for (;;) {
            if (this.sibling(dir))
                return true;
            if (this.atLastNode(dir) || !this.parent())
                return false;
        }
    }
    /// Move to the next node in a
    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))
    /// traversal, going from a node to its first child or, if the
    /// current node is empty, its next sibling or the next sibling of
    /// the first parent node that has one.
    next() { return this.move(1); }
    /// Move to the next node in a last-to-first pre-order traveral. A
    /// node is followed by ist last child or, if it has none, its
    /// previous sibling or the previous sibling of the first parent
    /// node that has one.
    prev() { return this.move(-1); }
    /// Move the cursor to the innermost node that covers `pos`. If
    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,
    /// it will enter nodes that start at `pos`.
    moveTo(pos, side = 0) {
        // Move up to a node that actually holds the position, if possible
        while (this.from == this.to ||
            (side < 1 ? this.from >= pos : this.from > pos) ||
            (side > -1 ? this.to <= pos : this.to < pos))
            if (!this.parent())
                break;
        // Then scan down into child nodes as far as possible
        for (;;) {
            if (side < 0 ? !this.childBefore(pos) : !this.childAfter(pos))
                break;
            if (this.from == this.to ||
                (side < 1 ? this.from >= pos : this.from > pos) ||
                (side > -1 ? this.to <= pos : this.to < pos)) {
                this.parent();
                break;
            }
        }
        return this;
    }
    /// Get a [syntax node](#tree.SyntaxNode) at the cursor's current
    /// position.
    get node() {
        if (!this.buffer)
            return this._tree;
        let cache = this.bufferNode, result = null, depth = 0;
        if (cache && cache.context == this.buffer) {
            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {
                for (let c = cache; c; c = c._parent)
                    if (c.index == index) {
                        if (index == this.index)
                            return c;
                        result = c;
                        depth = d + 1;
                        break scan;
                    }
                index = this.stack[--d];
            }
        }
        for (let i = depth; i < this.stack.length; i++)
            result = new BufferNode(this.buffer, result, this.stack[i]);
        return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    /// Get the [tree](#tree.Tree) that represents the current node, if
    /// any. Will return null when the node is in a [tree
    /// buffer](#tree.TreeBuffer).
    get tree() {
        return this.buffer ? null : this._tree.node;
    }
}
function hasChild(tree) {
    return tree.children.some(ch => !ch.type.isAnonymous || ch instanceof TreeBuffer || hasChild(ch));
}
class FlatBufferCursor {
    constructor(buffer, index) {
        this.buffer = buffer;
        this.index = index;
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    get pos() { return this.index; }
    next() { this.index -= 4; }
    fork() { return new FlatBufferCursor(this.buffer, this.index); }
}
const BalanceBranchFactor = 8;
function buildTree(data) {
    var _a;
    let { buffer, nodeSet, topID = 0, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types = nodeSet.types;
    function takeNode(parentStart, minPos, children, positions, inRepeat) {
        let { id, start, end, size } = cursor;
        while (id == inRepeat) {
            cursor.next();
            ({ id, start, end, size } = cursor);
        }
        let startPos = start - parentStart;
        if (size < 0) { // Reused node
            children.push(reused[id]);
            positions.push(startPos);
            cursor.next();
            return;
        }
        let type = types[id], node, buffer;
        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {
            // Small enough for a buffer, and no reused nodes inside
            let data = new Uint16Array(buffer.size - buffer.skip);
            let endPos = cursor.pos - buffer.size, index = data.length;
            while (cursor.pos > endPos)
                index = copyToBuffer(buffer.start, data, index, inRepeat);
            node = new TreeBuffer(data, end - buffer.start, nodeSet, inRepeat < 0 ? NodeType.none : types[inRepeat]);
            startPos = buffer.start - parentStart;
        }
        else { // Make it a node
            let endPos = cursor.pos - size;
            cursor.next();
            let localChildren = [], localPositions = [];
            let localInRepeat = id >= minRepeatType ? id : -1;
            while (cursor.pos > endPos)
                takeNode(start, endPos, localChildren, localPositions, localInRepeat);
            localChildren.reverse();
            localPositions.reverse();
            if (localInRepeat > -1 && localChildren.length > BalanceBranchFactor)
                node = balanceRange(type, type, localChildren, localPositions, 0, localChildren.length, 0, maxBufferLength, end - start);
            else
                node = new Tree(type, localChildren, localPositions, end - start);
        }
        children.push(node);
        positions.push(startPos);
    }
    function findBufferSize(maxSize, inRepeat) {
        // Scan through the buffer to find previous siblings that fit
        // together in a TreeBuffer, and don't contain any reused nodes
        // (which can't be stored in a buffer).
        // If `inRepeat` is > -1, ignore node boundaries of that type for
        // nesting, but make sure the end falls either at the start
        // (`maxSize`) or before such a node.
        let fork = cursor.fork();
        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
        let result = { size: 0, start: 0, skip: 0 };
        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {
            // Pretend nested repeat nodes of the same type don't exist
            if (fork.id == inRepeat) {
                // Except that we store the current state as a valid return
                // value.
                result.size = size;
                result.start = start;
                result.skip = skip;
                skip += 4;
                size += 4;
                fork.next();
                continue;
            }
            let nodeSize = fork.size, startPos = fork.pos - nodeSize;
            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)
                break;
            let localSkipped = fork.id >= minRepeatType ? 4 : 0;
            let nodeStart = fork.start;
            fork.next();
            while (fork.pos > startPos) {
                if (fork.size < 0)
                    break scan;
                if (fork.id >= minRepeatType)
                    localSkipped += 4;
                fork.next();
            }
            start = nodeStart;
            size += nodeSize;
            skip += localSkipped;
        }
        if (inRepeat < 0 || size == maxSize) {
            result.size = size;
            result.start = start;
            result.skip = skip;
        }
        return result.size > 4 ? result : undefined;
    }
    function copyToBuffer(bufferStart, buffer, index, inRepeat) {
        let { id, start, end, size } = cursor;
        cursor.next();
        if (id == inRepeat)
            return index;
        let startIndex = index;
        if (size > 4) {
            let endPos = cursor.pos - (size - 4);
            while (cursor.pos > endPos)
                index = copyToBuffer(bufferStart, buffer, index, inRepeat);
        }
        if (id < minRepeatType) { // Don't copy repeat nodes into buffers
            buffer[--index] = startIndex;
            buffer[--index] = end - bufferStart;
            buffer[--index] = start - bufferStart;
            buffer[--index] = id;
        }
        return index;
    }
    let children = [], positions = [];
    while (cursor.pos > 0)
        takeNode(data.start || 0, 0, children, positions, -1);
    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);
    return new Tree(types[topID], children.reverse(), positions.reverse(), length);
}
function balanceRange(outerType, innerType, children, positions, from, to, start, maxBufferLength, length) {
    let localChildren = [], localPositions = [];
    if (length <= maxBufferLength) {
        for (let i = from; i < to; i++) {
            localChildren.push(children[i]);
            localPositions.push(positions[i] - start);
        }
    }
    else {
        let maxChild = Math.max(maxBufferLength, Math.ceil(length * 1.5 / BalanceBranchFactor));
        for (let i = from; i < to;) {
            let groupFrom = i, groupStart = positions[i];
            i++;
            for (; i < to; i++) {
                let nextEnd = positions[i] + children[i].length;
                if (nextEnd - groupStart > maxChild)
                    break;
            }
            if (i == groupFrom + 1) {
                let only = children[groupFrom];
                if (only instanceof Tree && only.type == innerType && only.length > maxChild << 1) { // Too big, collapse
                    for (let j = 0; j < only.children.length; j++) {
                        localChildren.push(only.children[j]);
                        localPositions.push(only.positions[j] + groupStart - start);
                    }
                    continue;
                }
                localChildren.push(only);
            }
            else if (i == groupFrom + 1) {
                localChildren.push(children[groupFrom]);
            }
            else {
                let inner = balanceRange(innerType, innerType, children, positions, groupFrom, i, groupStart, maxBufferLength, positions[i - 1] + children[i - 1].length - groupStart);
                if (innerType != NodeType.none && !containsType(inner.children, innerType))
                    inner = new Tree(NodeType.none, inner.children, inner.positions, inner.length);
                localChildren.push(inner);
            }
            localPositions.push(groupStart - start);
        }
    }
    return new Tree(outerType, localChildren, localPositions, length);
}
function containsType(nodes, type) {
    for (let elt of nodes)
        if (elt.type == type)
            return true;
    return false;
}
/// Tree fragments are used during [incremental
/// parsing](#lezer.ParseOptions.fragments) to track parts of old
/// trees that can be reused in a new parse. An array of fragments is
/// used to track regions of an old tree whose nodes might be reused
/// in new parses. Use the static
/// [`applyChanges`](#tree.TreeFragment^applyChanges) method to update
/// fragments for document changes.
class TreeFragment {
    constructor(
    /// The start of the unchanged range pointed to by this fragment.
    /// This refers to an offset in the _updated_ document (as opposed
    /// to the original tree).
    from, 
    /// The end of the unchanged range.
    to, 
    /// The tree that this fragment is based on.
    tree, 
    /// The offset between the fragment's tree and the document that
    /// this fragment can be used against. Add this when going from
    /// document to tree positions, subtract it to go from tree to
    /// document positions.
    offset, open) {
        this.from = from;
        this.to = to;
        this.tree = tree;
        this.offset = offset;
        this.open = open;
    }
    get openStart() { return (this.open & 1 /* Start */) > 0; }
    get openEnd() { return (this.open & 2 /* End */) > 0; }
    /// Apply a set of edits to an array of fragments, removing or
    /// splitting fragments as necessary to remove edited ranges, and
    /// adjusting offsets for fragments that moved.
    static applyChanges(fragments, changes, minGap = 128) {
        if (!changes.length)
            return fragments;
        let result = [];
        let fI = 1, nextF = fragments.length ? fragments[0] : null;
        let cI = 0, pos = 0, off = 0;
        for (;;) {
            let nextC = cI < changes.length ? changes[cI++] : null;
            let nextPos = nextC ? nextC.fromA : 1e9;
            if (nextPos - pos >= minGap)
                while (nextF && nextF.from < nextPos) {
                    let cut = nextF;
                    if (pos >= cut.from || nextPos <= cut.to || off) {
                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
                        cut = fFrom >= fTo ? null :
                            new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, (cI > 0 ? 1 /* Start */ : 0) | (nextC ? 2 /* End */ : 0));
                    }
                    if (cut)
                        result.push(cut);
                    if (nextF.to > nextPos)
                        break;
                    nextF = fI < fragments.length ? fragments[fI++] : null;
                }
            if (!nextC)
                break;
            pos = nextC.toA;
            off = nextC.toA - nextC.toB;
        }
        return result;
    }
    /// Create a set of fragments from a freshly parsed tree, or update
    /// an existing set of fragments by replacing the ones that overlap
    /// with a tree with content from the new tree. When `partial` is
    /// true, the parse is treated as incomplete, and the token at its
    /// end is not included in [`safeTo`](#tree.TreeFragment.safeTo).
    static addTree(tree, fragments = [], partial = false) {
        let result = [new TreeFragment(0, tree.length, tree, 0, partial ? 2 /* End */ : 0)];
        for (let f of fragments)
            if (f.to > tree.length)
                result.push(f);
        return result;
    }
}
// Creates an `Input` that is backed by a single, flat string.
function stringInput(input) { return new StringInput(input); }
class StringInput {
    constructor(string, length = string.length) {
        this.string = string;
        this.length = length;
    }
    get(pos) {
        return pos < 0 || pos >= this.length ? -1 : this.string.charCodeAt(pos);
    }
    lineAfter(pos) {
        if (pos < 0)
            return "";
        let end = this.string.indexOf("\n", pos);
        return this.string.slice(pos, end < 0 ? this.length : Math.min(end, this.length));
    }
    read(from, to) { return this.string.slice(from, Math.min(this.length, to)); }
    clip(at) { return new StringInput(this.string, at); }
}


//# sourceMappingURL=tree.es.js.map


/***/ }),

/***/ "./node_modules/lezer/dist/index.es.js":
/*!*********************************************!*
  !*** ./node_modules/lezer/dist/index.es.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NodeProp": () => /* reexport safe */ lezer_tree__WEBPACK_IMPORTED_MODULE_0__.NodeProp,
/* harmony export */   "NodeSet": () => /* reexport safe */ lezer_tree__WEBPACK_IMPORTED_MODULE_0__.NodeSet,
/* harmony export */   "NodeType": () => /* reexport safe */ lezer_tree__WEBPACK_IMPORTED_MODULE_0__.NodeType,
/* harmony export */   "Tree": () => /* reexport safe */ lezer_tree__WEBPACK_IMPORTED_MODULE_0__.Tree,
/* harmony export */   "TreeCursor": () => /* reexport safe */ lezer_tree__WEBPACK_IMPORTED_MODULE_0__.TreeCursor,
/* harmony export */   "ExternalTokenizer": () => /* binding */ ExternalTokenizer,
/* harmony export */   "Parser": () => /* binding */ Parser,
/* harmony export */   "Stack": () => /* binding */ Stack,
/* harmony export */   "Token": () => /* binding */ Token
/* harmony export */ });
/* harmony import */ var lezer_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lezer-tree */ "./node_modules/lezer-tree/dist/tree.es.js");



/// A parse stack. These are used internally by the parser to track
/// parsing progress. They also provide some properties and methods
/// that external code such as a tokenizer can use to get information
/// about the parse state.
class Stack {
    /// @internal
    constructor(
    /// A group of values that the stack will share with all
    /// split instances
    ///@internal
    cx, 
    /// Holds state, pos, value stack pos (15 bits array index, 15 bits
    /// buffer index) triplets for all but the top state
    /// @internal
    stack, 
    /// The current parse state @internal
    state, 
    // The position at which the next reduce should take place. This
    // can be less than `this.pos` when skipped expressions have been
    // added to the stack (which should be moved outside of the next
    // reduction)
    /// @internal
    reducePos, 
    /// The input position up to which this stack has parsed.
    pos, 
    /// The dynamic score of the stack, including dynamic precedence
    /// and error-recovery penalties
    /// @internal
    score, 
    // The output buffer. Holds (type, start, end, size) quads
    // representing nodes created by the parser, where `size` is
    // amount of buffer array entries covered by this node.
    /// @internal
    buffer, 
    // The base offset of the buffer. When stacks are split, the split
    // instance shared the buffer history with its parent up to
    // `bufferBase`, which is the absolute offset (including the
    // offset of previous splits) into the buffer at which this stack
    // starts writing.
    /// @internal
    bufferBase, 
    // A parent stack from which this was split off, if any. This is
    // set up so that it always points to a stack that has some
    // additional buffer content, never to a stack with an equal
    // `bufferBase`.
    /// @internal
    parent) {
        this.cx = cx;
        this.stack = stack;
        this.state = state;
        this.reducePos = reducePos;
        this.pos = pos;
        this.score = score;
        this.buffer = buffer;
        this.bufferBase = bufferBase;
        this.parent = parent;
    }
    /// @internal
    toString() {
        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
    }
    // Start an empty stack
    /// @internal
    static start(cx, state, pos = 0) {
        return new Stack(cx, [], state, pos, pos, 0, [], 0, null);
    }
    // Push a state onto the stack, tracking its start position as well
    // as the buffer base at that point.
    /// @internal
    pushState(state, start) {
        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
        this.state = state;
    }
    // Apply a reduce action
    /// @internal
    reduce(action) {
        let depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;
        let { parser } = this.cx;
        let dPrec = parser.dynamicPrecedence(type);
        if (dPrec)
            this.score += dPrec;
        if (depth == 0) {
            // Zero-depth reductions are a special case—they add stuff to
            // the stack without popping anything off.
            if (type < parser.minRepeatTerm)
                this.storeNode(type, this.reducePos, this.reducePos, 4, true);
            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);
            return;
        }
        // Find the base index into `this.stack`, content after which will
        // be dropped. Note that with `StayFlag` reductions we need to
        // consume two extra frames (the dummy parent node for the skipped
        // expression and the state that we'll be staying in, which should
        // be moved to `this.state`).
        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);
        let start = this.stack[base - 2];
        let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;
        // Store normal terms or `R -> R R` repeat reductions
        if (type < parser.minRepeatTerm || (action & 131072 /* RepeatFlag */)) {
            let pos = parser.stateFlag(this.state, 1 /* Skipped */) ? this.pos : this.reducePos;
            this.storeNode(type, start, pos, count + 4, true);
        }
        if (action & 262144 /* StayFlag */) {
            this.state = this.stack[base];
        }
        else {
            let baseStateID = this.stack[base - 3];
            this.state = parser.getGoto(baseStateID, type, true);
        }
        while (this.stack.length > base)
            this.stack.pop();
    }
    // Shift a value into the buffer
    /// @internal
    storeNode(term, start, end, size = 4, isReduce = false) {
        if (term == 0 /* Err */) { // Try to omit/merge adjacent error nodes
            let cur = this, top = this.buffer.length;
            if (top == 0 && cur.parent) {
                top = cur.bufferBase - cur.parent.bufferBase;
                cur = cur.parent;
            }
            if (top > 0 && cur.buffer[top - 4] == 0 /* Err */ && cur.buffer[top - 1] > -1) {
                if (start == end)
                    return;
                if (cur.buffer[top - 2] >= start) {
                    cur.buffer[top - 2] = end;
                    return;
                }
            }
        }
        if (!isReduce || this.pos == end) { // Simple case, just append
            this.buffer.push(term, start, end, size);
        }
        else { // There may be skipped nodes that have to be moved forward
            let index = this.buffer.length;
            if (index > 0 && this.buffer[index - 4] != 0 /* Err */)
                while (index > 0 && this.buffer[index - 2] > end) {
                    // Move this record forward
                    this.buffer[index] = this.buffer[index - 4];
                    this.buffer[index + 1] = this.buffer[index - 3];
                    this.buffer[index + 2] = this.buffer[index - 2];
                    this.buffer[index + 3] = this.buffer[index - 1];
                    index -= 4;
                    if (size > 4)
                        size -= 4;
                }
            this.buffer[index] = term;
            this.buffer[index + 1] = start;
            this.buffer[index + 2] = end;
            this.buffer[index + 3] = size;
        }
    }
    // Apply a shift action
    /// @internal
    shift(action, next, nextEnd) {
        if (action & 131072 /* GotoFlag */) {
            this.pushState(action & 65535 /* ValueMask */, this.pos);
        }
        else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift
            let start = this.pos, nextState = action, { parser } = this.cx;
            if (nextEnd > this.pos || next <= parser.maxNode) {
                this.pos = nextEnd;
                if (!parser.stateFlag(nextState, 1 /* Skipped */))
                    this.reducePos = nextEnd;
            }
            this.pushState(nextState, start);
            if (next <= parser.maxNode)
                this.buffer.push(next, start, nextEnd, 4);
        }
        else { // Shift-and-stay, which means this is a skipped token
            if (next <= this.cx.parser.maxNode)
                this.buffer.push(next, this.pos, nextEnd, 4);
            this.pos = nextEnd;
        }
    }
    // Apply an action
    /// @internal
    apply(action, next, nextEnd) {
        if (action & 65536 /* ReduceFlag */)
            this.reduce(action);
        else
            this.shift(action, next, nextEnd);
    }
    // Add a prebuilt node into the buffer. This may be a reused node or
    // the result of running a nested parser.
    /// @internal
    useNode(value, next) {
        let index = this.cx.reused.length - 1;
        if (index < 0 || this.cx.reused[index] != value) {
            this.cx.reused.push(value);
            index++;
        }
        let start = this.pos;
        this.reducePos = this.pos = start + value.length;
        this.pushState(next, start);
        this.buffer.push(index, start, this.reducePos, -1 /* size < 0 means this is a reused value */);
    }
    // Split the stack. Due to the buffer sharing and the fact
    // that `this.stack` tends to stay quite shallow, this isn't very
    // expensive.
    /// @internal
    split() {
        let parent = this;
        let off = parent.buffer.length;
        // Because the top of the buffer (after this.pos) may be mutated
        // to reorder reductions and skipped tokens, and shared buffers
        // should be immutable, this copies any outstanding skipped tokens
        // to the new buffer, and puts the base pointer before them.
        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
            off -= 4;
        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;
        // Make sure parent points to an actual parent with content, if there is such a parent.
        while (parent && base == parent.bufferBase)
            parent = parent.parent;
        return new Stack(this.cx, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, parent);
    }
    // Try to recover from an error by 'deleting' (ignoring) one token.
    /// @internal
    recoverByDelete(next, nextEnd) {
        let isNode = next <= this.cx.parser.maxNode;
        if (isNode)
            this.storeNode(next, this.pos, nextEnd);
        this.storeNode(0 /* Err */, this.pos, nextEnd, isNode ? 8 : 4);
        this.pos = this.reducePos = nextEnd;
        this.score -= 200 /* Token */;
    }
    /// Check if the given term would be able to be shifted (optionally
    /// after some reductions) on this stack. This can be useful for
    /// external tokenizers that want to make sure they only provide a
    /// given token when it applies.
    canShift(term) {
        for (let sim = new SimulatedStack(this);;) {
            let action = this.cx.parser.stateSlot(sim.top, 4 /* DefaultReduce */) || this.cx.parser.hasAction(sim.top, term);
            if ((action & 65536 /* ReduceFlag */) == 0)
                return true;
            if (action == 0)
                return false;
            sim.reduce(action);
        }
    }
    /// Find the start position of the rule that is currently being parsed.
    get ruleStart() {
        for (let state = this.state, base = this.stack.length;;) {
            let force = this.cx.parser.stateSlot(state, 5 /* ForcedReduce */);
            if (!(force & 65536 /* ReduceFlag */))
                return 0;
            base -= 3 * (force >> 19 /* ReduceDepthShift */);
            if ((force & 65535 /* ValueMask */) < this.cx.parser.minRepeatTerm)
                return this.stack[base + 1];
            state = this.stack[base];
        }
    }
    /// Find the start position of an instance of any of the given term
    /// types, or return `null` when none of them are found.
    ///
    /// **Note:** this is only reliable when there is at least some
    /// state that unambiguously matches the given rule on the stack.
    /// I.e. if you have a grammar like this, where the difference
    /// between `a` and `b` is only apparent at the third token:
    ///
    ///     a { b | c }
    ///     b { "x" "y" "x" }
    ///     c { "x" "y" "z" }
    ///
    /// Then a parse state after `"x"` will not reliably tell you that
    /// `b` is on the stack. You _can_ pass `[b, c]` to reliably check
    /// for either of those two rules (assuming that `a` isn't part of
    /// some rule that includes other things starting with `"x"`).
    ///
    /// When `before` is given, this keeps scanning up the stack until
    /// it finds a match that starts before that position.
    startOf(types, before) {
        let state = this.state, frame = this.stack.length, { parser } = this.cx;
        for (;;) {
            let force = parser.stateSlot(state, 5 /* ForcedReduce */);
            let depth = force >> 19 /* ReduceDepthShift */, term = force & 65535 /* ValueMask */;
            if (types.indexOf(term) > -1) {
                let base = frame - (3 * (force >> 19 /* ReduceDepthShift */)), pos = this.stack[base + 1];
                if (before == null || before > pos)
                    return pos;
            }
            if (frame == 0)
                return null;
            if (depth == 0) {
                frame -= 3;
                state = this.stack[frame];
            }
            else {
                frame -= 3 * (depth - 1);
                state = parser.getGoto(this.stack[frame - 3], term, true);
            }
        }
    }
    // Apply up to Recover.MaxNext recovery actions that conceptually
    // inserts some missing token or rule.
    /// @internal
    recoverByInsert(next) {
        if (this.stack.length >= 300 /* MaxInsertStackDepth */)
            return [];
        let nextStates = this.cx.parser.nextStates(this.state);
        if (nextStates.length > 4 /* MaxNext */ || this.stack.length >= 120 /* DampenInsertStackDepth */) {
            let best = nextStates.filter(s => s != this.state && this.cx.parser.hasAction(s, next));
            if (this.stack.length < 120 /* DampenInsertStackDepth */)
                for (let i = 0; best.length < 4 /* MaxNext */ && i < nextStates.length; i++)
                    if (best.indexOf(nextStates[i]) < 0)
                        best.push(nextStates[i]);
            nextStates = best;
        }
        let result = [];
        for (let i = 0; i < nextStates.length && result.length < 4 /* MaxNext */; i++) {
            if (nextStates[i] == this.state)
                continue;
            let stack = this.split();
            stack.storeNode(0 /* Err */, stack.pos, stack.pos, 4, true);
            stack.pushState(nextStates[i], this.pos);
            stack.score -= 200 /* Token */;
            result.push(stack);
        }
        return result;
    }
    // Force a reduce, if possible. Return false if that can't
    // be done.
    /// @internal
    forceReduce() {
        let reduce = this.cx.parser.stateSlot(this.state, 5 /* ForcedReduce */);
        if ((reduce & 65536 /* ReduceFlag */) == 0)
            return false;
        if (!this.cx.parser.validAction(this.state, reduce)) {
            this.storeNode(0 /* Err */, this.reducePos, this.reducePos, 4, true);
            this.score -= 100 /* Reduce */;
        }
        this.reduce(reduce);
        return true;
    }
    /// @internal
    forceAll() {
        while (!this.cx.parser.stateFlag(this.state, 2 /* Accepting */) && this.forceReduce()) { }
        return this;
    }
    /// Check whether this state has no further actions (assumed to be a direct descendant of the
    /// top state, since any other states must be able to continue
    /// somehow). @internal
    get deadEnd() {
        if (this.stack.length != 3)
            return false;
        let { parser } = this.cx;
        return parser.data[parser.stateSlot(this.state, 1 /* Actions */)] == 65535 /* End */ &&
            !parser.stateSlot(this.state, 4 /* DefaultReduce */);
    }
    /// Restart the stack (put it back in its start state). Only safe
    /// when this.stack.length == 3 (state is directly below the top
    /// state). @internal
    restart() {
        this.state = this.stack[0];
        this.stack.length = 0;
    }
    /// @internal
    sameState(other) {
        if (this.state != other.state || this.stack.length != other.stack.length)
            return false;
        for (let i = 0; i < this.stack.length; i += 3)
            if (this.stack[i] != other.stack[i])
                return false;
        return true;
    }
    /// Get the parser used by this stack.
    get parser() { return this.cx.parser; }
    /// Test whether a given dialect (by numeric ID, as exported from
    /// the terms file) is enabled.
    dialectEnabled(dialectID) { return this.cx.parser.dialect.flags[dialectID]; }
}
var Recover;
(function (Recover) {
    Recover[Recover["Token"] = 200] = "Token";
    Recover[Recover["Reduce"] = 100] = "Reduce";
    Recover[Recover["MaxNext"] = 4] = "MaxNext";
    Recover[Recover["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
    Recover[Recover["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
})(Recover || (Recover = {}));
// Used to cheaply run some reductions to scan ahead without mutating
// an entire stack
class SimulatedStack {
    constructor(stack) {
        this.stack = stack;
        this.top = stack.state;
        this.rest = stack.stack;
        this.offset = this.rest.length;
    }
    reduce(action) {
        let term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;
        if (depth == 0) {
            if (this.rest == this.stack.stack)
                this.rest = this.rest.slice();
            this.rest.push(this.top, 0, 0);
            this.offset += 3;
        }
        else {
            this.offset -= (depth - 1) * 3;
        }
        let goto = this.stack.cx.parser.getGoto(this.rest[this.offset - 3], term, true);
        this.top = goto;
    }
}
// This is given to `Tree.build` to build a buffer, and encapsulates
// the parent-stack-walking necessary to read the nodes.
class StackBufferCursor {
    constructor(stack, pos, index) {
        this.stack = stack;
        this.pos = pos;
        this.index = index;
        this.buffer = stack.buffer;
        if (this.index == 0)
            this.maybeNext();
    }
    static create(stack) {
        return new StackBufferCursor(stack, stack.bufferBase + stack.buffer.length, stack.buffer.length);
    }
    maybeNext() {
        let next = this.stack.parent;
        if (next != null) {
            this.index = this.stack.bufferBase - next.bufferBase;
            this.stack = next;
            this.buffer = next.buffer;
        }
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    next() {
        this.index -= 4;
        this.pos -= 4;
        if (this.index == 0)
            this.maybeNext();
    }
    fork() {
        return new StackBufferCursor(this.stack, this.pos, this.index);
    }
}

/// Tokenizers write the tokens they read into instances of this class.
class Token {
    constructor() {
        /// The start of the token. This is set by the parser, and should not
        /// be mutated by the tokenizer.
        this.start = -1;
        /// This starts at -1, and should be updated to a term id when a
        /// matching token is found.
        this.value = -1;
        /// When setting `.value`, you should also set `.end` to the end
        /// position of the token. (You'll usually want to use the `accept`
        /// method.)
        this.end = -1;
    }
    /// Accept a token, setting `value` and `end` to the given values.
    accept(value, end) {
        this.value = value;
        this.end = end;
    }
}
/// @internal
class TokenGroup {
    constructor(data, id) {
        this.data = data;
        this.id = id;
    }
    token(input, token, stack) { readToken(this.data, input, token, stack, this.id); }
}
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
/// Exports that are used for `@external tokens` in the grammar should
/// export an instance of this class.
class ExternalTokenizer {
    /// Create a tokenizer. The first argument is the function that,
    /// given an input stream and a token object,
    /// [fills](#lezer.Token.accept) the token object if it recognizes a
    /// token. `token.start` should be used as the start position to
    /// scan from.
    constructor(
    /// @internal
    token, options = {}) {
        this.token = token;
        this.contextual = !!options.contextual;
        this.fallback = !!options.fallback;
        this.extend = !!options.extend;
    }
}
// Tokenizer data is stored a big uint16 array containing, for each
// state:
//
//  - A group bitmask, indicating what token groups are reachable from
//    this state, so that paths that can only lead to tokens not in
//    any of the current groups can be cut off early.
//
//  - The position of the end of the state's sequence of accepting
//    tokens
//
//  - The number of outgoing edges for the state
//
//  - The accepting tokens, as (token id, group mask) pairs
//
//  - The outgoing edges, as (start character, end character, state
//    index) triples, with end character being exclusive
//
// This function interprets that data, running through a stream as
// long as new states with the a matching group mask can be reached,
// and updating `token` when it matches a token.
function readToken(data, input, token, stack, group) {
    let state = 0, groupMask = 1 << group, dialect = stack.cx.parser.dialect;
    scan: for (let pos = token.start;;) {
        if ((groupMask & data[state]) == 0)
            break;
        let accEnd = data[state + 1];
        // Check whether this state can lead to a token in the current group
        // Accept tokens in this state, possibly overwriting
        // lower-precedence / shorter tokens
        for (let i = state + 3; i < accEnd; i += 2)
            if ((data[i + 1] & groupMask) > 0) {
                let term = data[i];
                if (dialect.allows(term) &&
                    (token.value == -1 || token.value == term || stack.cx.parser.overrides(term, token.value))) {
                    token.accept(term, pos);
                    break;
                }
            }
        let next = input.get(pos++);
        // Do a binary search on the state's edges
        for (let low = 0, high = data[state + 2]; low < high;) {
            let mid = (low + high) >> 1;
            let index = accEnd + mid + (mid << 1);
            let from = data[index], to = data[index + 1];
            if (next < from)
                high = mid;
            else if (next >= to)
                low = mid + 1;
            else {
                state = data[index + 2];
                continue scan;
            }
        }
        break;
    }
}

// See lezer-generator/src/encode.ts for comments about the encoding
// used here
function decodeArray(input, Type = Uint16Array) {
    if (typeof input != "string")
        return input;
    let array = null;
    for (let pos = 0, out = 0; pos < input.length;) {
        let value = 0;
        for (;;) {
            let next = input.charCodeAt(pos++), stop = false;
            if (next == 126 /* BigValCode */) {
                value = 65535 /* BigVal */;
                break;
            }
            if (next >= 92 /* Gap2 */)
                next--;
            if (next >= 34 /* Gap1 */)
                next--;
            let digit = next - 32 /* Start */;
            if (digit >= 46 /* Base */) {
                digit -= 46 /* Base */;
                stop = true;
            }
            value += digit;
            if (stop)
                break;
            value *= 46 /* Base */;
        }
        if (array)
            array[out++] = value;
        else
            array = new Type(value);
    }
    return array;
}

// FIXME find some way to reduce recovery work done when the input
// doesn't match the grammar at all.
// Environment variable used to control console output
const verbose = typeof process != "undefined" && /\bparse\b/.test(process.env.LOG);
let stackIDs = null;
function cutAt(tree, pos, side) {
    let cursor = tree.cursor(pos);
    for (;;) {
        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
            for (;;) {
                if ((side < 0 ? cursor.to <= pos : cursor.from >= pos) && !cursor.type.isError)
                    return side < 0 ? cursor.to - 1 : cursor.from + 1;
                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
                    break;
                if (!cursor.parent())
                    return side < 0 ? 0 : tree.length;
            }
    }
}
class FragmentCursor {
    constructor(fragments) {
        this.fragments = fragments;
        this.i = 0;
        this.fragment = null;
        this.safeFrom = -1;
        this.safeTo = -1;
        this.trees = [];
        this.start = [];
        this.index = [];
        this.nextFragment();
    }
    nextFragment() {
        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
        if (fr) {
            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
            while (this.trees.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
            }
            this.trees.push(fr.tree);
            this.start.push(-fr.offset);
            this.index.push(0);
            this.nextStart = this.safeFrom;
        }
        else {
            this.nextStart = 1e9;
        }
    }
    // `pos` must be >= any previously given `pos` for this cursor
    nodeAt(pos) {
        if (pos < this.nextStart)
            return null;
        while (this.fragment && this.safeTo <= pos)
            this.nextFragment();
        if (!this.fragment)
            return null;
        for (;;) {
            let last = this.trees.length - 1;
            if (last < 0) { // End of tree
                this.nextFragment();
                return null;
            }
            let top = this.trees[last], index = this.index[last];
            if (index == top.children.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
                continue;
            }
            let next = top.children[index];
            let start = this.start[last] + top.positions[index];
            if (start > pos) {
                this.nextStart = start;
                return null;
            }
            else if (start == pos && start + next.length <= this.safeTo) {
                return start == pos && start >= this.safeFrom ? next : null;
            }
            if (next instanceof lezer_tree__WEBPACK_IMPORTED_MODULE_0__.TreeBuffer) {
                this.index[last]++;
                this.nextStart = start + next.length;
            }
            else {
                this.index[last]++;
                if (start + next.length >= pos) { // Enter this node
                    this.trees.push(next);
                    this.start.push(start);
                    this.index.push(0);
                }
            }
        }
    }
}
class CachedToken extends Token {
    constructor() {
        super(...arguments);
        this.extended = -1;
        this.mask = 0;
    }
    clear(start) {
        this.start = start;
        this.value = this.extended = -1;
    }
}
const dummyToken = new Token;
class TokenCache {
    constructor(parser) {
        this.tokens = [];
        this.mainToken = dummyToken;
        this.actions = [];
        this.tokens = parser.tokenizers.map(_ => new CachedToken);
    }
    getActions(stack, input) {
        let actionIndex = 0;
        let main = null;
        let { parser } = stack.cx, { tokenizers } = parser;
        let mask = parser.stateSlot(stack.state, 3 /* TokenizerMask */);
        for (let i = 0; i < tokenizers.length; i++) {
            if (((1 << i) & mask) == 0)
                continue;
            let tokenizer = tokenizers[i], token = this.tokens[i];
            if (main && !tokenizer.fallback)
                continue;
            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask) {
                this.updateCachedToken(token, tokenizer, stack, input);
                token.mask = mask;
            }
            if (token.value != 0 /* Err */) {
                let startIndex = actionIndex;
                if (token.extended > -1)
                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
                if (!tokenizer.extend) {
                    main = token;
                    if (actionIndex > startIndex)
                        break;
                }
            }
        }
        while (this.actions.length > actionIndex)
            this.actions.pop();
        if (!main) {
            main = dummyToken;
            main.start = stack.pos;
            if (stack.pos == input.length)
                main.accept(stack.cx.parser.eofTerm, stack.pos);
            else
                main.accept(0 /* Err */, stack.pos + 1);
        }
        this.mainToken = main;
        return this.actions;
    }
    updateCachedToken(token, tokenizer, stack, input) {
        token.clear(stack.pos);
        tokenizer.token(input, token, stack);
        if (token.value > -1) {
            let { parser } = stack.cx;
            for (let i = 0; i < parser.specialized.length; i++)
                if (parser.specialized[i] == token.value) {
                    let result = parser.specializers[i](input.read(token.start, token.end), stack);
                    if (result >= 0 && stack.cx.parser.dialect.allows(result >> 1)) {
                        if ((result & 1) == 0 /* Specialize */)
                            token.value = result >> 1;
                        else
                            token.extended = result >> 1;
                        break;
                    }
                }
        }
        else if (stack.pos == input.length) {
            token.accept(stack.cx.parser.eofTerm, stack.pos);
        }
        else {
            token.accept(0 /* Err */, stack.pos + 1);
        }
    }
    putAction(action, token, end, index) {
        // Don't add duplicate actions
        for (let i = 0; i < index; i += 3)
            if (this.actions[i] == action)
                return index;
        this.actions[index++] = action;
        this.actions[index++] = token;
        this.actions[index++] = end;
        return index;
    }
    addActions(stack, token, end, index) {
        let { state } = stack, { parser } = stack.cx, { data } = parser;
        for (let set = 0; set < 2; set++) {
            for (let i = parser.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */);; i += 3) {
                if (data[i] == 65535 /* End */) {
                    if (data[i + 1] == 1 /* Next */) {
                        i = pair(data, i + 2);
                    }
                    else {
                        if (index == 0 && data[i + 1] == 2 /* Other */)
                            index = this.putAction(pair(data, i + 1), token, end, index);
                        break;
                    }
                }
                if (data[i] == token)
                    index = this.putAction(pair(data, i + 1), token, end, index);
            }
        }
        return index;
    }
}
var Rec;
(function (Rec) {
    Rec[Rec["Distance"] = 5] = "Distance";
    Rec[Rec["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
    Rec[Rec["MinBufferLengthPrune"] = 200] = "MinBufferLengthPrune";
    Rec[Rec["ForceReduceLimit"] = 10] = "ForceReduceLimit";
})(Rec || (Rec = {}));
/// A parse context can be used for step-by-step parsing. After
/// creating it, you repeatedly call `.advance()` until it returns a
/// tree to indicate it has reached the end of the parse.
class Parse {
    constructor(parser, input, startPos, context) {
        this.parser = parser;
        this.input = input;
        this.startPos = startPos;
        this.context = context;
        // The position to which the parse has advanced.
        this.pos = 0;
        this.recovering = 0;
        this.nextStackID = 0x2654;
        this.nested = null;
        this.nestEnd = 0;
        this.nestWrap = null;
        this.reused = [];
        this.tokens = new TokenCache(parser);
        this.topTerm = parser.top[1];
        this.stacks = [Stack.start(this, parser.top[0], this.startPos)];
        let fragments = context === null || context === void 0 ? void 0 : context.fragments;
        this.fragments = fragments && fragments.length ? new FragmentCursor(fragments) : null;
    }
    // Move the parser forward. This will process all parse stacks at
    // `this.pos` and try to advance them to a further position. If no
    // stack for such a position is found, it'll start error-recovery.
    //
    // When the parse is finished, this will return a syntax tree. When
    // not, it returns `null`.
    advance() {
        if (this.nested) {
            let result = this.nested.advance();
            this.pos = this.nested.pos;
            if (result) {
                this.finishNested(this.stacks[0], result);
                this.nested = null;
            }
            return null;
        }
        let stacks = this.stacks, pos = this.pos;
        // This will hold stacks beyond `pos`.
        let newStacks = this.stacks = [];
        let stopped, stoppedTokens;
        let maybeNest;
        // Keep advancing any stacks at `pos` until they either move
        // forward or can't be advanced. Gather stacks that can't be
        // advanced further in `stopped`.
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i], nest;
            for (;;) {
                if (stack.pos > pos) {
                    newStacks.push(stack);
                }
                else if (nest = this.checkNest(stack)) {
                    if (!maybeNest || maybeNest.stack.score < stack.score)
                        maybeNest = nest;
                }
                else if (this.advanceStack(stack, newStacks, stacks)) {
                    continue;
                }
                else {
                    if (!stopped) {
                        stopped = [];
                        stoppedTokens = [];
                    }
                    stopped.push(stack);
                    let tok = this.tokens.mainToken;
                    stoppedTokens.push(tok.value, tok.end);
                }
                break;
            }
        }
        if (maybeNest) {
            this.startNested(maybeNest);
            return null;
        }
        if (!newStacks.length) {
            let finished = stopped && findFinished(stopped);
            if (finished)
                return this.stackToTree(finished);
            if (this.parser.strict) {
                if (verbose && stopped)
                    console.log("Stuck with token " + this.parser.getName(this.tokens.mainToken.value));
                throw new SyntaxError("No parse at " + pos);
            }
            if (!this.recovering)
                this.recovering = 5 /* Distance */;
        }
        if (this.recovering && stopped) {
            let finished = this.runRecovery(stopped, stoppedTokens, newStacks);
            if (finished)
                return this.stackToTree(finished.forceAll());
        }
        if (this.recovering) {
            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* MaxRemainingPerStep */;
            if (newStacks.length > maxRemaining) {
                newStacks.sort((a, b) => b.score - a.score);
                while (newStacks.length > maxRemaining)
                    newStacks.pop();
            }
            if (newStacks.some(s => s.reducePos > pos))
                this.recovering--;
        }
        else if (newStacks.length > 1) {
            // Prune stacks that are in the same state, or that have been
            // running without splitting for a while, to avoid getting stuck
            // with multiple successful stacks running endlessly on.
            outer: for (let i = 0; i < newStacks.length - 1; i++) {
                let stack = newStacks[i];
                for (let j = i + 1; j < newStacks.length; j++) {
                    let other = newStacks[j];
                    if (stack.sameState(other) ||
                        stack.buffer.length > 200 /* MinBufferLengthPrune */ && other.buffer.length > 200 /* MinBufferLengthPrune */) {
                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {
                            newStacks.splice(j--, 1);
                        }
                        else {
                            newStacks.splice(i--, 1);
                            continue outer;
                        }
                    }
                }
            }
        }
        this.pos = newStacks[0].pos;
        for (let i = 1; i < newStacks.length; i++)
            if (newStacks[i].pos < this.pos)
                this.pos = newStacks[i].pos;
        return null;
    }
    // Returns an updated version of the given stack, or null if the
    // stack can't advance normally. When `split` and `stacks` are
    // given, stacks split off by ambiguous operations will be pushed to
    // `split`, or added to `stacks` if they move `pos` forward.
    advanceStack(stack, stacks, split) {
        let start = stack.pos, { input, parser } = this;
        let base = verbose ? this.stackID(stack) + " -> " : "";
        if (this.fragments) {
            for (let cached = this.fragments.nodeAt(start); cached;) {
                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;
                if (match > -1 && cached.length) {
                    stack.useNode(cached, match);
                    if (verbose)
                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);
                    return true;
                }
                if (!(cached instanceof lezer_tree__WEBPACK_IMPORTED_MODULE_0__.Tree) || cached.children.length == 0 || cached.positions[0] > 0)
                    break;
                let inner = cached.children[0];
                if (inner instanceof lezer_tree__WEBPACK_IMPORTED_MODULE_0__.Tree)
                    cached = inner;
                else
                    break;
            }
        }
        let defaultReduce = parser.stateSlot(stack.state, 4 /* DefaultReduce */);
        if (defaultReduce > 0) {
            stack.reduce(defaultReduce);
            if (verbose)
                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* ValueMask */)})`);
            return true;
        }
        let actions = this.tokens.getActions(stack, input);
        for (let i = 0; i < actions.length;) {
            let action = actions[i++], term = actions[i++], end = actions[i++];
            let last = i == actions.length || !split;
            let localStack = last ? stack : stack.split();
            localStack.apply(action, term, end);
            if (verbose)
                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* ReduceFlag */) == 0 ? "shift"
                    : `reduce of ${parser.getName(action & 65535 /* ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
            if (last)
                return true;
            else if (localStack.pos > start)
                stacks.push(localStack);
            else
                split.push(localStack);
        }
        return false;
    }
    // Advance a given stack forward as far as it will go. Returns the
    // (possibly updated) stack if it got stuck, or null if it moved
    // forward and was given to `pushStackDedup`.
    advanceFully(stack, newStacks) {
        let pos = stack.pos;
        for (;;) {
            let nest = this.checkNest(stack);
            if (nest)
                return nest;
            if (!this.advanceStack(stack, null, null))
                return false;
            if (stack.pos > pos) {
                pushStackDedup(stack, newStacks);
                return true;
            }
        }
    }
    runRecovery(stacks, tokens, newStacks) {
        let finished = null, restarted = false;
        let maybeNest;
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
            let base = verbose ? this.stackID(stack) + " -> " : "";
            if (stack.deadEnd) {
                if (restarted)
                    continue;
                restarted = true;
                stack.restart();
                if (verbose)
                    console.log(base + this.stackID(stack) + " (restarted)");
                let done = this.advanceFully(stack, newStacks);
                if (done) {
                    if (done !== true)
                        maybeNest = done;
                    continue;
                }
            }
            let force = stack.split(), forceBase = base;
            for (let j = 0; force.forceReduce() && j < 10 /* ForceReduceLimit */; j++) {
                if (verbose)
                    console.log(forceBase + this.stackID(force) + " (via force-reduce)");
                let done = this.advanceFully(force, newStacks);
                if (done) {
                    if (done !== true)
                        maybeNest = done;
                    break;
                }
                if (verbose)
                    forceBase = this.stackID(force) + " -> ";
            }
            for (let insert of stack.recoverByInsert(token)) {
                if (verbose)
                    console.log(base + this.stackID(insert) + " (via recover-insert)");
                this.advanceFully(insert, newStacks);
            }
            if (this.input.length > stack.pos) {
                if (tokenEnd == stack.pos) {
                    tokenEnd++;
                    token = 0 /* Err */;
                }
                stack.recoverByDelete(token, tokenEnd);
                if (verbose)
                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
                pushStackDedup(stack, newStacks);
            }
            else if (!finished || finished.score < stack.score) {
                finished = stack;
            }
        }
        if (finished)
            return finished;
        if (maybeNest)
            for (let s of this.stacks)
                if (s.score > maybeNest.stack.score) {
                    maybeNest = undefined;
                    break;
                }
        if (maybeNest)
            this.startNested(maybeNest);
        return null;
    }
    forceFinish() {
        let stack = this.stacks[0].split();
        if (this.nested)
            this.finishNested(stack, this.nested.forceFinish());
        return this.stackToTree(stack.forceAll());
    }
    // Convert the stack's buffer to a syntax tree.
    stackToTree(stack, pos = stack.pos) {
        return lezer_tree__WEBPACK_IMPORTED_MODULE_0__.Tree.build({ buffer: StackBufferCursor.create(stack),
            nodeSet: this.parser.nodeSet,
            topID: this.topTerm,
            maxBufferLength: this.parser.bufferLength,
            reused: this.reused,
            start: this.startPos,
            length: pos - this.startPos,
            minRepeatType: this.parser.minRepeatTerm });
    }
    checkNest(stack) {
        let info = this.parser.findNested(stack.state);
        if (!info)
            return null;
        let spec = info.value;
        if (typeof spec == "function")
            spec = spec(this.input, stack);
        return spec ? { stack, info, spec } : null;
    }
    startNested(nest) {
        let { stack, info, spec } = nest;
        this.stacks = [stack];
        this.nestEnd = this.scanForNestEnd(stack, info.end, spec.filterEnd);
        this.nestWrap = typeof spec.wrapType == "number" ? this.parser.nodeSet.types[spec.wrapType] : spec.wrapType || null;
        if (spec.startParse) {
            this.nested = spec.startParse(this.input.clip(this.nestEnd), stack.pos, this.context);
        }
        else {
            this.finishNested(stack);
        }
    }
    scanForNestEnd(stack, endToken, filter) {
        for (let pos = stack.pos; pos < this.input.length; pos++) {
            dummyToken.start = pos;
            dummyToken.value = -1;
            endToken.token(this.input, dummyToken, stack);
            if (dummyToken.value > -1 && (!filter || filter(this.input.read(pos, dummyToken.end))))
                return pos;
        }
        return this.input.length;
    }
    finishNested(stack, tree) {
        if (this.nestWrap)
            tree = new lezer_tree__WEBPACK_IMPORTED_MODULE_0__.Tree(this.nestWrap, tree ? [tree] : [], tree ? [0] : [], this.nestEnd - stack.pos);
        else if (!tree)
            tree = new lezer_tree__WEBPACK_IMPORTED_MODULE_0__.Tree(lezer_tree__WEBPACK_IMPORTED_MODULE_0__.NodeType.none, [], [], this.nestEnd - stack.pos);
        let info = this.parser.findNested(stack.state);
        stack.useNode(tree, this.parser.getGoto(stack.state, info.placeholder, true));
        if (verbose)
            console.log(this.stackID(stack) + ` (via unnest)`);
    }
    stackID(stack) {
        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);
        if (!id)
            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));
        return id + stack;
    }
}
function pushStackDedup(stack, newStacks) {
    for (let i = 0; i < newStacks.length; i++) {
        let other = newStacks[i];
        if (other.pos == stack.pos && other.sameState(stack)) {
            if (newStacks[i].score < stack.score)
                newStacks[i] = stack;
            return;
        }
    }
    newStacks.push(stack);
}
class Dialect {
    constructor(source, flags, disabled) {
        this.source = source;
        this.flags = flags;
        this.disabled = disabled;
    }
    allows(term) { return !this.disabled || this.disabled[term] == 0; }
}
/// A parser holds the parse tables for a given grammar, as generated
/// by `lezer-generator`.
class Parser {
    /// @internal
    constructor(spec) {
        /// @internal
        this.bufferLength = lezer_tree__WEBPACK_IMPORTED_MODULE_0__.DefaultBufferLength;
        /// @internal
        this.strict = false;
        this.nextStateCache = [];
        this.cachedDialect = null;
        if (spec.version != 13 /* Version */)
            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${13 /* Version */})`);
        let tokenArray = decodeArray(spec.tokenData);
        let nodeNames = spec.nodeNames.split(" ");
        this.minRepeatTerm = nodeNames.length;
        for (let i = 0; i < spec.repeatNodeCount; i++)
            nodeNames.push("");
        let nodeProps = [];
        for (let i = 0; i < nodeNames.length; i++)
            nodeProps.push([]);
        function setProp(nodeID, prop, value) {
            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
        }
        if (spec.nodeProps)
            for (let propSpec of spec.nodeProps) {
                let prop = propSpec[0];
                for (let i = 1; i < propSpec.length;) {
                    let next = propSpec[i++];
                    if (next >= 0) {
                        setProp(next, prop, propSpec[i++]);
                    }
                    else {
                        let value = propSpec[i + -next];
                        for (let j = -next; j > 0; j--)
                            setProp(propSpec[i++], prop, value);
                        i++;
                    }
                }
            }
        this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);
        this.specializers = [];
        if (spec.specialized)
            for (let i = 0; i < spec.specialized.length; i++) {
                this.specialized[i] = spec.specialized[i].term;
                this.specializers[i] = spec.specialized[i].get;
            }
        this.states = decodeArray(spec.states, Uint32Array);
        this.data = decodeArray(spec.stateData);
        this.goto = decodeArray(spec.goto);
        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);
        this.nodeSet = new lezer_tree__WEBPACK_IMPORTED_MODULE_0__.NodeSet(nodeNames.map((name, i) => lezer_tree__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({
            name: i >= this.minRepeatTerm ? undefined : name,
            id: i,
            props: nodeProps[i],
            top: topTerms.indexOf(i) > -1,
            error: i == 0,
            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
        })));
        this.maxTerm = spec.maxTerm;
        this.tokenizers = spec.tokenizers.map(value => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
        this.topRules = spec.topRules;
        this.nested = (spec.nested || []).map(([name, value, endToken, placeholder]) => {
            return { name, value, end: new TokenGroup(decodeArray(endToken), 0), placeholder };
        });
        this.dialects = spec.dialects || {};
        this.dynamicPrecedences = spec.dynamicPrecedences || null;
        this.tokenPrecTable = spec.tokenPrec;
        this.termNames = spec.termNames || null;
        this.maxNode = this.nodeSet.types.length - 1;
        for (let i = 0, l = this.states.length / 6 /* Size */; i < l; i++)
            this.nextStateCache[i] = null;
        this.dialect = this.parseDialect();
        this.top = this.topRules[Object.keys(this.topRules)[0]];
    }
    /// Parse a given string or stream.
    parse(input, startPos = 0, context = {}) {
        if (typeof input == "string")
            input = (0,lezer_tree__WEBPACK_IMPORTED_MODULE_0__.stringInput)(input);
        let cx = new Parse(this, input, startPos, context);
        for (;;) {
            let done = cx.advance();
            if (done)
                return done;
        }
    }
    /// Start an incremental parse.
    startParse(input, startPos = 0, context = {}) {
        if (typeof input == "string")
            input = (0,lezer_tree__WEBPACK_IMPORTED_MODULE_0__.stringInput)(input);
        return new Parse(this, input, startPos, context);
    }
    /// Get a goto table entry @internal
    getGoto(state, term, loose = false) {
        let table = this.goto;
        if (term >= table[0])
            return -1;
        for (let pos = table[term + 1];;) {
            let groupTag = table[pos++], last = groupTag & 1;
            let target = table[pos++];
            if (last && loose)
                return target;
            for (let end = pos + (groupTag >> 1); pos < end; pos++)
                if (table[pos] == state)
                    return target;
            if (last)
                return -1;
        }
    }
    /// Check if this state has an action for a given terminal @internal
    hasAction(state, terminal) {
        let data = this.data;
        for (let set = 0; set < 2; set++) {
            for (let i = this.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next;; i += 3) {
                if ((next = data[i]) == 65535 /* End */) {
                    if (data[i + 1] == 1 /* Next */)
                        next = data[i = pair(data, i + 2)];
                    else if (data[i + 1] == 2 /* Other */)
                        return pair(data, i + 2);
                    else
                        break;
                }
                if (next == terminal || next == 0 /* Err */)
                    return pair(data, i + 1);
            }
        }
        return 0;
    }
    /// @internal
    stateSlot(state, slot) {
        return this.states[(state * 6 /* Size */) + slot];
    }
    /// @internal
    stateFlag(state, flag) {
        return (this.stateSlot(state, 0 /* Flags */) & flag) > 0;
    }
    /// @internal
    findNested(state) {
        let flags = this.stateSlot(state, 0 /* Flags */);
        return flags & 4 /* StartNest */ ? this.nested[flags >> 10 /* NestShift */] : null;
    }
    /// @internal
    validAction(state, action) {
        if (action == this.stateSlot(state, 4 /* DefaultReduce */))
            return true;
        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {
            if (this.data[i] == 65535 /* End */) {
                if (this.data[i + 1] == 1 /* Next */)
                    i = pair(this.data, i + 2);
                else
                    return false;
            }
            if (action == pair(this.data, i + 1))
                return true;
        }
    }
    /// Get the states that can follow this one through shift actions or
    /// goto jumps. @internal
    nextStates(state) {
        let cached = this.nextStateCache[state];
        if (cached)
            return cached;
        let result = [];
        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {
            if (this.data[i] == 65535 /* End */) {
                if (this.data[i + 1] == 1 /* Next */)
                    i = pair(this.data, i + 2);
                else
                    break;
            }
            if ((this.data[i + 2] & (65536 /* ReduceFlag */ >> 16)) == 0 && result.indexOf(this.data[i + 1]) < 0)
                result.push(this.data[i + 1]);
        }
        let table = this.goto, max = table[0];
        for (let term = 0; term < max; term++) {
            for (let pos = table[term + 1];;) {
                let groupTag = table[pos++], target = table[pos++];
                for (let end = pos + (groupTag >> 1); pos < end; pos++)
                    if (table[pos] == state && result.indexOf(target) < 0)
                        result.push(target);
                if (groupTag & 1)
                    break;
            }
        }
        return this.nextStateCache[state] = result;
    }
    /// @internal
    overrides(token, prev) {
        let iPrev = findOffset(this.data, this.tokenPrecTable, prev);
        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;
    }
    /// Configure the parser. Returns a new parser instance that has the
    /// given settings modified. Settings not provided in `config` are
    /// kept from the original parser.
    configure(config) {
        // Hideous reflection-based kludge to make it easy to create a
        // slightly modified copy of a parser.
        let copy = Object.assign(Object.create(Parser.prototype), this);
        if (config.props)
            copy.nodeSet = this.nodeSet.extend(...config.props);
        if (config.top) {
            let info = this.topRules[config.top];
            if (!info)
                throw new RangeError(`Invalid top rule name ${config.top}`);
            copy.top = info;
        }
        if (config.tokenizers)
            copy.tokenizers = this.tokenizers.map(t => {
                let found = config.tokenizers.find(r => r.from == t);
                return found ? found.to : t;
            });
        if (config.dialect)
            copy.dialect = this.parseDialect(config.dialect);
        if (config.nested)
            copy.nested = this.nested.map(obj => {
                if (!Object.prototype.hasOwnProperty.call(config.nested, obj.name))
                    return obj;
                return { name: obj.name, value: config.nested[obj.name], end: obj.end, placeholder: obj.placeholder };
            });
        if (config.strict != null)
            copy.strict = config.strict;
        if (config.bufferLength != null)
            copy.bufferLength = config.bufferLength;
        return copy;
    }
    /// Returns the name associated with a given term. This will only
    /// work for all terms when the parser was generated with the
    /// `--names` option. By default, only the names of tagged terms are
    /// stored.
    getName(term) {
        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
    }
    /// The eof term id is always allocated directly after the node
    /// types. @internal
    get eofTerm() { return this.maxNode + 1; }
    /// Tells you whether this grammar has any nested grammars.
    get hasNested() { return this.nested.length > 0; }
    /// @internal
    dynamicPrecedence(term) {
        let prec = this.dynamicPrecedences;
        return prec == null ? 0 : prec[term] || 0;
    }
    /// @internal
    parseDialect(dialect) {
        if (this.cachedDialect && this.cachedDialect.source == dialect)
            return this.cachedDialect;
        let values = Object.keys(this.dialects), flags = values.map(() => false);
        if (dialect)
            for (let part of dialect.split(" ")) {
                let id = values.indexOf(part);
                if (id >= 0)
                    flags[id] = true;
            }
        let disabled = null;
        for (let i = 0; i < values.length; i++)
            if (!flags[i]) {
                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* End */;)
                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;
            }
        return this.cachedDialect = new Dialect(dialect, flags, disabled);
    }
    /// (used by the output of the parser generator) @internal
    static deserialize(spec) {
        return new Parser(spec);
    }
}
function pair(data, off) { return data[off] | (data[off + 1] << 16); }
function findOffset(data, start, term) {
    for (let i = start, next; (next = data[i]) != 65535 /* End */; i++)
        if (next == term)
            return i - start;
    return -1;
}
function findFinished(stacks) {
    let best = null;
    for (let stack of stacks) {
        if (stack.pos == stack.cx.input.length &&
            stack.cx.parser.stateFlag(stack.state, 2 /* Accepting */) &&
            (!best || best.score < stack.score))
            best = stack;
    }
    return best;
}


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./ast.ts":
/*!****************!*
  !*** ./ast.ts ***!
  \****************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BinOp": () => /* binding */ BinOp,
/* harmony export */   "UniOp": () => /* binding */ UniOp
/* harmony export */ });
var BinOp;
(function (BinOp) {
    BinOp["Plus"] = "+";
    BinOp["Minus"] = "-";
    BinOp["Mul"] = "*";
    BinOp["Div"] = "//";
    BinOp["Mod"] = "%";
    BinOp["Eq"] = "==";
    BinOp["Neq"] = "!=";
    BinOp["Seq"] = "<=";
    BinOp["Leq"] = ">=";
    BinOp["Sml"] = "<";
    BinOp["Lrg"] = ">";
    BinOp["Is"] = "is";
})(BinOp || (BinOp = {}));
var UniOp;
(function (UniOp) {
    UniOp["Minus"] = "-";
    UniOp["Not"] = "not";
})(UniOp || (UniOp = {}));


/***/ }),

/***/ "./compiler.ts":
/*!*********************!*
  !*** ./compiler.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createEmptyLocalEnv": () => /* binding */ createEmptyLocalEnv,
/* harmony export */   "createEmptyGlobalEnv": () => /* binding */ createEmptyGlobalEnv,
/* harmony export */   "setGlobalInfo": () => /* binding */ setGlobalInfo,
/* harmony export */   "compile": () => /* binding */ compile
/* harmony export */ });
/* harmony import */ var _ast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ast */ "./ast.ts");
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parser */ "./parser.ts");
/* harmony import */ var _typecheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./typecheck */ "./typecheck.ts");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (undefined && undefined.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};



function createEmptyLocalEnv() {
    return {
        vars: new Map(),
        isFunc: false,
    };
}
function createEmptyGlobalEnv() {
    return {
        vars: new Map(),
        funcs: new Map(),
        classIndexes: new Map(),
        classInits: new Map(),
        loopDepth: 0
    };
}
// set up global variables and global functions
function setGlobalInfo(program) {
    var globalEnv = createEmptyGlobalEnv();
    // set variables
    for (var idx = 0; idx < program.varInits.length; ++idx) {
        globalEnv.vars.set(program.varInits[idx].name, program.varInits[idx]);
    }
    // set funcstions
    for (var idx = 0; idx < program.funcDefs.length; ++idx) {
        globalEnv.funcs.set(program.funcDefs[idx].name, program.funcDefs[idx]);
    }
    // set class field indexes and init value
    for (var idx = 0; idx < program.classDefs.length; idx++) {
        var classIndexes = new Map();
        var classInits = new Map();
        var classDef = program.classDefs[idx];
        if (classDef.tag !== "class") {
            throw Error("should be a class");
        }
        var fields = classDef.fields;
        for (var idx2 = 0; idx2 < fields.length; idx2++) {
            classIndexes.set(fields[idx2].name, idx2);
            classInits.set(fields[idx2].name, fields[idx2].initLiteral);
        }
        var className = classDef.name;
        globalEnv.classIndexes.set(className, classIndexes);
        globalEnv.classInits.set(className, classInits);
    }
    return globalEnv;
}
function compile(source) {
    // parse program and get each elements
    var program = (0,_typecheck__WEBPACK_IMPORTED_MODULE_2__.typeCheckProgram)((0,_parser__WEBPACK_IMPORTED_MODULE_1__.parse)(source));
    var ast = program.stmts;
    var globalEnv = setGlobalInfo(program);
    // generate function definitions
    var funcs = program.funcDefs.map(function (funcDef) {
        return codeGenFuncDef(funcDef, globalEnv);
    }).join('\n');
    // generate global variables (including the heap)
    var globalVars = codeGenGlobalVar(program.varInits).join('\n');
    // generate class definitions
    var classes = program.classDefs.map(function (classDef) {
        return codeGenClassDef(classDef, globalEnv); // not sure why its return is stringp[]
    }).join("\n");
    // create an empty local environment
    var localEnv = createEmptyLocalEnv();
    // generate the code for the main body
    var commands = codeGenMainBody(ast, globalEnv, localEnv);
    // console.log(commands);
    // set up final function return type
    var lastExpr = ast[ast.length - 1];
    var returnType = "";
    var returnExpr = "";
    // console.log(`ast.length: ${ast.length}, lastExpr: ${lastExpr.tag}`);
    if (ast.length > 0 && lastExpr.tag === "expr") {
        returnType = "(result i32)";
        returnExpr = "\n(local.get $last)"; // Since we use a function at the end, we need to put the return value in the stack.
    }
    // The last value is not needed if the last statement is not an expression.
    return {
        wasmSource: globalVars + "\n" + classes + "\n" + funcs + "\n(func (export \"exported_func\") " + returnType + commands.join('\n') + returnExpr + ")"
    };
}
// generate codes for statements
function codeGen(stmt, globalEnv, localEnv) {
    switch (stmt.tag) {
        case "assign":
            var valStmts = codeGenExpr(stmt.value, globalEnv, localEnv); // rhs
            var leftExpr = codeGenExpr(stmt.name, globalEnv, localEnv); // lhs
            // generate the "store" assign code
            if (stmt.name.tag == "getfield") {
                leftExpr = leftExpr.slice(0, -1); // strip `i32.load` since it's lhs
                return leftExpr.concat([valStmts + "\ni32.store"]);
            }
            else { // generate the "set" assign code
                if (localEnv.isFunc) {
                    if (localEnv.vars.has(stmt.variable)) {
                        return valStmts.concat(["(local.set $" + stmt.name + ")"]);
                    }
                    // We cannot assign a value to a global variable in the function environment.
                    throw new Error("The global variable " + stmt.variable + " cannot be assigned in a function");
                }
            }
            return valStmts.concat(["(global.set $" + stmt.variable + ")"]); // global environment
        case "expr":
            var exprStmts = codeGenExpr(stmt.expr, globalEnv, localEnv);
            return exprStmts.concat(["(local.set $last)"]);
        // Without the return command, the function would return the values in the stack.
        // However, we would need to make sure the #stack elements == #return values
        case "return":
            var returnStmts = codeGenExpr(stmt.expr, globalEnv, localEnv);
            returnStmts.push("(return)");
            return returnStmts;
        case "pass":
            return ["nop"]; // no operation
        case "while":
            var whileStmts = codeGenWhile(stmt, globalEnv, localEnv);
            return whileStmts.concat();
        case "if":
            var ifStmts = codeGenIf(stmt, globalEnv, localEnv);
            return ifStmts.concat();
    }
}
function codeGenMainBody(stmts, globalEnv, localEnv) {
    // declare all local variables according to the source
    var scratchVar = "(local $last i32)"; // as function output
    // put $last on the stack, and it wil consume the top value on the stack eventually
    var localDefines = [scratchVar];
    var commandGroups = stmts.map(function (stmt) { return codeGen(stmt, globalEnv, localEnv); });
    return localDefines.concat([].concat.apply([], commandGroups));
}
function codeGenExpr(expr, globalEnv, localEnv) {
    switch (expr.tag) {
        case "id":
            return [codeGenId(expr, globalEnv, localEnv)];
        case "binop":
            var leftStmts = codeGenExpr(expr.left, globalEnv, localEnv);
            var rightStmts = codeGenExpr(expr.right, globalEnv, localEnv);
            var opStmt = codeGenBinOp(expr.op);
            return __spreadArrays(leftStmts, rightStmts, [opStmt]);
        case "uniop":
            var uniopRight = codeGenExpr(expr.expr, globalEnv, localEnv);
            return codeGenUnionOp(expr.op, uniopRight);
        case "literal":
            return [codeGenLiteral(expr.literal)];
        case "call":
            return codeGenCall(expr, globalEnv, localEnv);
        case "method":
            var argInstrs = expr.args.map(function (a) { return codeGenExpr(a, globalEnv, localEnv); });
            var flattenArgs_1 = []; // flat the list of lists
            argInstrs.forEach(function (arg) { return flattenArgs_1.push(arg.join("\n")); });
            if (expr.obj.a == "int" || expr.obj.a == "bool" || expr.obj.a == "None") {
                throw Error("This should be a class.");
            }
            // The call object is the first argument self.
            var callObject = codeGenExpr(expr.obj, globalEnv, localEnv).join("\n");
            return [callObject, flattenArgs_1.join("\n"), "\n(call $$" + expr.obj.a.class + "$" + expr.name + ")"];
        case "getfield":
            return codeGenField(expr, globalEnv, localEnv);
    }
}
function codeGenBinOp(op) {
    switch (op) {
        case _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Plus:
            return "(i32.add)";
        case _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Minus:
            return "(i32.sub)";
        case _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Mul:
            return "(i32.mul)";
        case _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Div:
            return "(i32.div_s)";
        case _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Mod:
            return "(i32.rem_s)";
        case _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Eq:
            return "(i32.eq)";
        case _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Neq:
            return "(i32.ne)";
        case _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Seq:
            return "(i32.le_s)";
        case _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Leq:
            return "(i32.ge_s)";
        case _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Sml:
            return "(i32.lt_s)";
        case _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Lrg:
            return "(i32.gt_s)";
        case _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Is:
            // x is y 
            // e.g. y is a class and x is an object of that class
            // currently, the only class is None, so we can use eq
            // throw new Error("COMPILE ERROR: is operator not implemented")
            // For other classes, we should compare the field recursively.
            // In Chocopy, "is" is used to compare the fields in two class objects, and "==" cannot be used with classes. 
            return "(i32.eq)";
    }
}
function codeGenUnionOp(op, right) {
    switch (op) {
        case _ast__WEBPACK_IMPORTED_MODULE_0__.UniOp.Minus:
            return __spreadArrays(["(i32.const 0)"], right, ["(i32.sub) "]); // -x = 0 - x
        case _ast__WEBPACK_IMPORTED_MODULE_0__.UniOp.Not:
            return __spreadArrays(right, ["(i32.eqz)"]); // is x != 0, return 1; else, return 0
    }
}
function codeGenIf(stmt, globalEnv, localEnv) {
    if (stmt.tag !== 'if') {
        throw new Error("COMPILE ERROR: the input to codeGenIf should have tag if");
    }
    var ifCond = codeGenExpr(stmt.ifOp.cond, globalEnv, localEnv).join('\n');
    var ifBody = codeGenBody(stmt.ifOp.stmts, globalEnv, localEnv).join('\n');
    var elifCond = "(i32.const 0)";
    var elifBody = "nop";
    var elseBody = "nop";
    // has else if
    if (stmt.elifOp.cond !== null) {
        elifCond = codeGenExpr(stmt.elifOp.cond, globalEnv, localEnv).join('\n');
        elifBody = codeGenBody(stmt.elifOp.stmts, globalEnv, localEnv).join('\n');
    }
    if (stmt.elseOp.stmts !== null) {
        elseBody = codeGenBody(stmt.elseOp.stmts, globalEnv, localEnv).join('\n');
    }
    return [ifCond + "\n(if\n(then\n" + ifBody + "\n)\n(else\n" + elifCond + "\n(if\n(then\n" + elifBody + "\n)\n(else\n" + elseBody + "\n))))"];
}
// generate the codes for statements
function codeGenBody(stmts, globalEnv, localEnv) {
    var body = stmts.map(function (s) {
        var b = codeGen(s, globalEnv, localEnv);
        return b.join('\n');
    });
    return body;
}
function codeGenWhile(stmt, globalEnv, localEnv) {
    if (stmt.tag !== "while") {
        throw new Error("COMPILE ERROR: codeGenWhile takes only while statement as input");
    }
    // throw new Error("COMPILE ERROR: while has not been implemented yet");
    var loopId = (globalEnv.loopDepth++);
    // command body
    var body = codeGenBody(stmt.stmts, globalEnv, localEnv);
    // condition 
    var cond = codeGenExpr(stmt.cond, globalEnv, localEnv);
    globalEnv.loopDepth--;
    return ["(loop \n" + body.join('\n') + "\n" + cond.join('\n') + "\nbr_if " + loopId + ")"];
}
function codeGenField(expr, globalEnv, localEnv) {
    if (expr.tag !== 'getfield') {
        throw Error("COMPILER ERROR: The input expression to codeGenCall should be getfield.");
    }
    if (expr.obj.a === "int" || expr.obj.a === "bool" || expr.obj.a === "None") {
        throw Error("COMPILER ERROR: The object should be a class.");
    }
    // If it is an instance, it should return its address, ex. (global.get $r1).
    var objAddr = codeGenExpr(expr.obj, globalEnv, localEnv);
    var checkValidAddress = __spreadArrays(objAddr, ["(i32.const -4) \n(i32.add)", "(i32.load)", "local.set $last"]);
    var classIndexes = globalEnv.classIndexes.get(expr.obj.a.class);
    var indexOfField = classIndexes.get(expr.name);
    return __spreadArrays([checkValidAddress.join("\n")], objAddr, ["(i32.const " + indexOfField * 4 + ") \n(i32.add)", "(i32.load)"]);
}
function codeGenCall(expr, globalEnv, localEnv) {
    if (expr.tag !== "call") {
        throw new Error("COMPILER ERROR: The input expression to codeGenCall should be call.");
    }
    // address the case of an init call, ex. r1 = Rat().
    if (globalEnv.classInits.has(expr.name)) {
        // variable initializations
        var initVals_1 = [];
        var classInits_1 = globalEnv.classInits.get(expr.name); // get the initializing values of a class
        var classIndexes = globalEnv.classIndexes.get(expr.name); // get the field indexes of a class
        classIndexes.forEach(function (index, field) {
            var offset = index * 4;
            initVals_1 = __spreadArrays(initVals_1, [
                "(global.get $heap)",
                "(i32.const " + offset + ")",
                "(i32.add)",
                codeGenLiteral(classInits_1.get(field)),
                "(i32.store)"
            ]);
        });
        // We have to modify the address of the heap, so the next class can use it.
        initVals_1 = __spreadArrays(initVals_1, [
            "(global.get $heap)",
            "(global.get $heap)",
            "(i32.const " + classIndexes.size * 4 + ")",
            "(i32.add)",
            "(global.set $heap)",
        ]);
        var initFuncName = "$$" + expr.name + "$__init__)";
        if (globalEnv.funcs.has(initFuncName)) {
            initVals_1.push("(call $$" + expr.name + "$__init__)"); // execute the __init__ operations
        }
        return initVals_1;
    }
    var codes = [];
    // collect arguments
    for (var idx = 0; idx < expr.args.length; ++idx) {
        var arg = expr.args[idx];
        codes = __spreadArrays(codes, codeGenExpr(arg, globalEnv, localEnv));
    }
    // call the function
    if (expr.name === 'print') {
        if (expr.args[0].a !== "int" && expr.args[0].a !== "bool" && expr.args[0].a !== "None") {
            codes.push("(call $print_num)");
        }
        else {
            switch (expr.args[0].a) {
                case "int":
                    codes.push("(call $print_num)");
                    break;
                case "bool":
                    codes.push("(call $print_bool)");
                    break;
                case "None":
                    codes.push("(call $print_none)");
                    break;
                default:
                    // The code can still compile if it's a class, and an error will occur at runtime.
                    codes.push("(call $print_num)");
            }
        }
    }
    else {
        codes.push("(call $" + expr.name + ")");
    }
    return codes;
}
function codeGenGlobalVar(varInits) {
    var varInitWasm = varInits.map(function (varInit) {
        return "(global $" + varInit.name + " (mut i32) " + codeGenLiteral(varInit.initLiteral) + ")";
    });
    varInitWasm.push("(global $heap (mut i32) (i32.const 4))\n"); // initialize the heap for classes
    return varInitWasm;
}
/*
def get_field_a(self : Rat):
  return self.a
*/
function codeGenClassDef(classDef, globalEnv) {
    if (classDef.tag !== "class") {
        throw Error("can only generate codes for classes");
    }
    var classWasm = [];
    // add all the fields functions (simply return the value)
    classDef.fields.forEach(function (f) {
        // To return self.a, we need the address of self, and the index of a.
        var params = [{
                a: {
                    tag: "object",
                    class: classDef.name
                },
                name: "self",
                type: classDef.a
            }]; // ex. self : Rat
        var varInits = []; // no variable initializations
        var getfieldObj = {
            a: {
                tag: "object",
                class: classDef.name
            },
            tag: "id",
            name: "self"
        }; // ex. r1
        var getfieldExpr = { a: f.a, tag: "getfield", obj: getfieldObj, name: f.name };
        var stmts = [{ a: "None", tag: "return", expr: getfieldExpr }];
        var funcDef = {
            name: "$" + classDef.name + "$get_field_" + f.name,
            params: params,
            retType: f.a,
            varInits: varInits,
            stmts: stmts
        };
        codeGenFuncDef(funcDef, globalEnv).forEach(function (funcWasm) {
            classWasm.push(funcWasm);
        });
    });
    // add all the method functions
    classDef.methods.forEach(function (m) {
        var funcDef = __assign(__assign({}, m), { name: "$" + classDef.name + "$" + m.name }); // Another "$" would be added later.
        // add a return statement to the init function
        if (m.name == "__init__") {
            funcDef.stmts.push({
                a: "None",
                tag: "return",
                expr: {
                    a: { tag: "object", class: classDef.name },
                    tag: "id",
                    name: "self"
                }
            });
        }
        // We remove "self" in the parser and add it back here.
        funcDef.params = __spreadArrays([{
                a: {
                    tag: "object",
                    class: classDef.name
                },
                name: "self",
                type: classDef.a
            }], funcDef.params);
        // funcDef.params.push({ 
        //   a: { 
        //     tag: "object", 
        //     class: classDef.name 
        //   }, 
        //   name: "self", 
        //   type: classDef.a 
        // });
        codeGenFuncDef(funcDef, globalEnv).forEach(function (funcWasm) {
            classWasm.push(funcWasm);
        });
    });
    return classWasm.join("\n");
}
function codeGenFuncDef(funcDef, globalEnv) {
    // prepare the local environment
    var localEnv = createEmptyLocalEnv();
    localEnv.isFunc = true;
    funcDef.params.map(function (p) {
        localEnv.vars.set(p.name, true);
    });
    funcDef.varInits.map(function (v) {
        localEnv.vars.set(v.name, true);
    });
    // params
    var params = funcDef.params.map(function (p) {
        return "(param $" + p.name + " i32)";
    }).join(' ');
    // init local variables
    var localVarInit = funcDef.varInits.map(function (v) {
        return "(local $" + v.name + " i32)\n(local.set $" + v.name + " " + codeGenLiteral(v.initLiteral) + ")";
    }).join('\n');
    // generate body statements
    var body = codeGenBody(funcDef.stmts, globalEnv, localEnv);
    // return tge function definition in WASM
    // return [`\n(func $${funcDef.name} ${params} (result i32) ${localVarInit}\n${body.join('\n')})`]
    // return [`(func $${funcDef.name} ${params} (result i32)\n(local $last i32)\n${localVarInit}\n${body.join('\n')}\n(i32.const 0))`]
    return ["(func $" + funcDef.name + " " + params + " (result i32)\n(local $last i32)" + localVarInit + "\n" + body.join('\n') + "\n(i32.const 0))\n"];
}
function codeGenLiteral(literal) {
    switch (literal.tag) {
        case "num":
            return "(i32.const " + literal.value + ")";
        case "bool":
            if (literal.value)
                return "(i32.const 1)";
            return "(i32.const 0)";
        case "none":
            return "(i32.const 0)";
    }
}
// should use local environment instead of global environment
function codeGenId(id, GlocalEnv, localEnv) {
    if (id.tag !== 'id') {
        throw new Error("COMPILE ERROR: input to codeGen Id should be an id expr");
    }
    // The type checker has already make sure the variable is defined.
    if (localEnv.vars.has(id.name)) {
        return "(local.get $" + id.name + ")";
    }
    return "(global.get $" + id.name + ")";
}


/***/ }),

/***/ "./parser.ts":
/*!*******************!*
  !*** ./parser.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "traverseArgs": () => /* binding */ traverseArgs,
/* harmony export */   "traverseExpr": () => /* binding */ traverseExpr,
/* harmony export */   "traverseStmt": () => /* binding */ traverseStmt,
/* harmony export */   "traverseProgram": () => /* binding */ traverseProgram,
/* harmony export */   "parse": () => /* binding */ parse,
/* harmony export */   "isFuncDef": () => /* binding */ isFuncDef,
/* harmony export */   "isClassDef": () => /* binding */ isClassDef,
/* harmony export */   "isVarInit": () => /* binding */ isVarInit,
/* harmony export */   "traverseVarInit": () => /* binding */ traverseVarInit,
/* harmony export */   "node2type": () => /* binding */ node2type,
/* harmony export */   "traverseTypedVar": () => /* binding */ traverseTypedVar,
/* harmony export */   "traverseLiteral": () => /* binding */ traverseLiteral,
/* harmony export */   "traverseClassDef": () => /* binding */ traverseClassDef,
/* harmony export */   "traverseMethDef": () => /* binding */ traverseMethDef,
/* harmony export */   "traverseFuncDef": () => /* binding */ traverseFuncDef,
/* harmony export */   "stringifyTree": () => /* binding */ stringifyTree
/* harmony export */ });
/* harmony import */ var lezer_python__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lezer-python */ "./node_modules/lezer-python/dist/index.es.js");
/* harmony import */ var _ast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ast */ "./ast.ts");


function traverseArgs(c, s) {
    var args = [];
    c.firstChild();
    while (c.nextSibling()) {
        if (c.type.name === ')') {
            break;
        }
        args.push(traverseExpr(c, s));
        c.nextSibling();
    }
    c.parent();
    return args;
}
function traverseExpr(c, s) {
    switch (c.type.name) {
        case "Number": // eg. '1'
            return {
                tag: "literal",
                literal: {
                    tag: "num",
                    value: Number(s.substring(c.from, c.to))
                }
            };
        case 'Boolean':
            return {
                tag: "literal",
                literal: {
                    tag: "bool",
                    value: s.substring(c.from, c.to) === "True"
                }
            };
        case "None":
            return { tag: "literal", literal: { tag: "none" } };
        case "VariableName": // e.g. 'x'
            return { tag: "id", name: s.substring(c.from, c.to) };
        case "self": // not sure if this should be handled like this
            return { tag: "id", name: "self" };
        case "CallExpression": // e.g. max(x, y), abs(x), f()
            c.firstChild(); // "MemberExpression" or "VariableName"
            if (c.name === "MemberExpression") {
                c.lastChild(); // "PropertyName"
                var pName_1 = s.substring(c.from, c.to);
                c.parent(); // get back to "MemberExpression"
                var obj_1 = traverseExpr(c, s);
                if (obj_1.tag !== "getfield") { // Visiting MemberExpression should always gets a getfield return.
                    throw Error("The object has an incorrect tag.");
                }
                c.nextSibling(); // "ArgList"
                var args = traverseArgs(c, s);
                c.parent();
                // We return obj.obj because the obj is actually not a getfield.
                return { tag: "method", obj: obj_1.obj, args: args, name: pName_1 };
            }
            else {
                // "VariableName"
                var callName = s.substring(c.from, c.to);
                c.nextSibling(); // "ArgList"
                var args = traverseArgs(c, s);
                c.parent(); // back to "CallExpression"
                return { tag: "call", name: callName, args: args };
            }
        case "UnaryExpression":
            // WARNING: This uniary expression only deals with uniary operator directly followed by a number 
            // e.g. -x, - (1 + 2)
            c.firstChild(); // go into the unary expressoin
            var uniOp = str2uniop(s.substring(c.from, c.to));
            // pop uniary expression
            var num = Number(s.substring(c.from, c.to));
            c.nextSibling();
            var unionExpr = traverseExpr(c, s);
            c.parent();
            return { tag: "uniop", op: uniOp, expr: unionExpr };
        case "BinaryExpression": // e.g. 1 + 2
            c.firstChild(); // go into binary expression
            var left = traverseExpr(c, s);
            c.nextSibling();
            var op = str2binop(s.substring(c.from, c.to));
            c.nextSibling();
            var right = traverseExpr(c, s);
            c.parent(); // pop the binary
            return { tag: "binop", op: op, left: left, right: right };
        case "MemberExpression": // ex. r2.n
            c.firstChild(); // "CallExpression" or "VariableName"
            var obj = traverseExpr(c, s);
            c.nextSibling(); // "."
            c.nextSibling(); // "PropertyName"
            var pName = s.substring(c.from, c.to);
            c.parent();
            return { tag: "getfield", obj: obj, name: pName };
        case "ParenthesizedExpression":
            c.firstChild(); // visit "("
            c.nextSibling(); // visit the inner expression
            var expr = traverseExpr(c, s);
            c.parent;
            return expr;
        default:
            console.log(stringifyTree(c, s, 2));
            throw new Error("PARSE ERROR: Could not parse expr at " + c.from + " " + c.to + ": " + s.substring(c.from, c.to));
    }
}
/*
 * A function to parse one statement
 * @input c: a treecorsor
 * @input s: the original input string
 * @input env: environment variables (if we are going to traverse a func,)
 */
function traverseStmt(c, s) {
    switch (c.node.type.name) {
        case "AssignStatement": // a = 1, b = 2 or var Init
            c.firstChild(); // "VariableName" or "MemberExpression"
            // get lhs expression
            var name = traverseExpr(c, s);
            var variable = s.substring(c.from, c.to);
            variable = variable.split(".")[0]; // This only tells the initial variable => self.y as self
            c.nextSibling(); // "AssignOp"
            c.nextSibling(); // rhs expression
            var value = traverseExpr(c, s);
            c.parent();
            return { tag: "assign", name: name, variable: variable, value: value };
        case "ExpressionStatement":
            c.firstChild();
            var expr = traverseExpr(c, s);
            c.parent();
            return { tag: "expr", expr: expr };
        case "ReturnStatement":
            c.firstChild();
            c.nextSibling();
            var retExpr = { tag: "literal", literal: { tag: "none" } };
            if (c.type.name !== '⚠') { // return None
                retExpr = traverseExpr(c, s);
            }
            c.parent();
            return { tag: "return", expr: retExpr };
        case "PassStatement":
            return { tag: "pass" };
        case "IfStatement":
            return traverseIf(c, s);
        case "WhileStatement":
            return traverseWhile(c, s);
        case "ClassDefinition":
            return traverseClassDef(c, s);
        default:
            throw new Error("Could not parse stmt at " + c.node.from + " " + c.node.to + ": " + s.substring(c.from, c.to));
    }
}
function traverseProgram(c, s) {
    var varInits = [];
    var classDefs = [];
    var funcDefs = []; // no FuncDef for PA3
    var stmts = []; // class definitions are included here
    switch (c.node.type.name) {
        case "Script":
            c.firstChild();
            // parse class definitions and variable initializations
            do {
                if (isVarInit(c)) {
                    varInits.push(traverseVarInit(c, s)); // parse variable initialization
                }
                else if (isFuncDef(c)) {
                    funcDefs.push(traverseFuncDef(c, s));
                }
                else if (isClassDef(c)) {
                    classDefs.push(traverseClassDef(c, s));
                }
                else {
                    break;
                }
            } while (c.nextSibling());
            if (isVarInit(c) || isFuncDef(c) || isClassDef(c)) { // no next sibling && no stmts
                return { varInits: varInits, classDefs: classDefs, funcDefs: funcDefs, stmts: stmts };
            }
            // parse statements
            do {
                if (isVarInit(c) || isFuncDef(c)) {
                    throw new Error("PARSE ERROR: var init and func def should go before statements");
                }
                stmts.push(traverseStmt(c, s));
            } while (c.nextSibling());
            return { varInits: varInits, classDefs: classDefs, funcDefs: funcDefs, stmts: stmts };
        default:
            throw new Error("Could not parse program at " + c.node.from + " " + c.node.to);
    }
}
function parse(source) {
    var t = lezer_python__WEBPACK_IMPORTED_MODULE_0__.parser.parse(source);
    console.log("Parsed Source Code:");
    console.log(stringifyTree(t.cursor(), source, 0));
    console.log("\n");
    return traverseProgram(t.cursor(), source);
}
function isFuncDef(c) {
    return c.type.name === 'FunctionDefinition';
}
function isClassDef(c) {
    return c.type.name === 'ClassDefinition';
}
function isVarInit(c) {
    if (c.type.name !== 'AssignStatement') {
        return false;
    }
    c.firstChild();
    c.nextSibling();
    var isTypeDef = (c.node.type.name === 'TypeDef');
    c.parent();
    return isTypeDef;
}
// c is now in AssignStatement
function traverseVarInit(c, s) {
    c.firstChild(); // VariableName
    var tVar = traverseTypedVar(c, s);
    c.nextSibling(); // TypeDef
    c.nextSibling(); // AssignOp
    var literal = traverseLiteral(c, s); // Number
    c.parent();
    return { name: tVar.name, type: tVar.type, initLiteral: literal };
}
// There would be much more types (classes).
function node2type(c, s) {
    var typeStr = s.substring(c.from, c.to);
    switch (typeStr) {
        case 'int':
            return "int";
        case 'bool':
            return "bool";
        case 'None':
            return "None";
        default: // We'll check if the type exists in the type checker
            return {
                tag: "object",
                class: typeStr
            };
        // throw new Error(`PARSE ERROR: unknown type ${typeStr}`);
    }
}
function traverseTypedVar(c, s) {
    var name = s.substring(c.from, c.to); // "VariableName"
    c.nextSibling(); // TypeDef
    c.firstChild(); // :
    c.nextSibling(); // VariableName
    var type = node2type(c, s);
    c.parent();
    return { name: name, type: type };
}
function traverseLiteral(c, s) {
    var valStr = s.substring(c.from, c.to);
    switch (c.type.name) {
        case 'Boolean':
            if (valStr == 'False') {
                return { tag: "bool", value: false };
            }
            else {
                return { tag: "bool", value: true };
            }
        case 'Number':
            return { tag: "num", value: parseInt(valStr) };
        case 'None':
            return { tag: "none" };
    }
    throw new Error("PARSE ERROR: unsupporting literal type");
}
function traverseClassDef(c, s) {
    var cls = {
        tag: "class",
        name: "",
        fields: [],
        methods: [],
    };
    c.firstChild(); // class node
    c.nextSibling(); // class name
    cls.name = s.substring(c.from, c.to); // assign class name
    c.nextSibling(); // "Arglist" => fixed to be object
    c.nextSibling(); // "Body"
    c.firstChild(); // ":"
    c.nextSibling(); // reach the fisrt statement in the body
    var code = traverseClassBody(c, s);
    cls.fields = code.varInits;
    cls.methods = code.funcDefs;
    c.parent(); // back to "Body"
    c.parent(); // back to "ClassDefinition"
    return cls;
}
function traverseMethDef(c, s) {
    var func = {
        name: "",
        params: null,
        retType: "None",
        varInits: null,
        stmts: null
    };
    c.firstChild(); // "def"
    c.nextSibling(); // method name
    func.name = s.substring(c.from, c.to);
    c.nextSibling(); // "ParamList" => at least 1 parameters (self)
    func.params = traverseMethParams(c, s);
    c.nextSibling(); // "TypeDef" or "Body"
    // check if the method provides a return type
    if (c.type.name === 'TypeDef') {
        c.firstChild();
        func.retType = node2type(c, s);
        c.parent();
        c.nextSibling(); // "Body"
    }
    c.firstChild(); // ":"
    c.nextSibling(); // the first body statement
    var code = traverseMethBody(c, s); // This line is the only difference
    func.varInits = code.varInits;
    func.stmts = code.stmts;
    c.parent(); // back to "Body"
    c.parent(); // back to "ClassDefinition"
    return func;
}
function traverseFuncDef(c, s) {
    var func = {
        name: "",
        params: null,
        retType: "None",
        varInits: null,
        stmts: null
    };
    // function name
    c.firstChild();
    c.nextSibling();
    func.name = s.substring(c.from, c.to);
    // paramlist (0 or more)
    c.nextSibling();
    func.params = traverseFuncParams(c, s);
    // return type (0 or one)
    c.nextSibling();
    if (c.type.name === 'TypeDef') {
        c.firstChild();
        func.retType = node2type(c, s);
        c.parent();
    }
    // parse body
    c.nextSibling();
    c.firstChild();
    c.nextSibling();
    var code = traverseFuncBody(c, s);
    func.varInits = code.varInits;
    func.stmts = code.stmts;
    c.parent();
    c.parent();
    return func;
}
// similar to traverseFuncParams, but escape the self parameter
function traverseMethParams(c, s) {
    var params = [];
    c.firstChild(); // "("
    c.nextSibling(); // "self"
    c.nextSibling(); // "TypeDef"
    c.nextSibling(); // ","
    do {
        if (s.substring(c.from, c.to) === ')')
            break;
        if (s.substring(c.from, c.to) === ',')
            continue;
        params.push(traverseTypedVar(c, s));
    } while (c.nextSibling());
    c.parent();
    return params;
}
function traverseFuncParams(c, s) {
    var params = [];
    c.firstChild();
    c.nextSibling();
    do {
        if (s.substring(c.from, c.to) === ')')
            break;
        if (s.substring(c.from, c.to) === ',')
            continue;
        params.push(traverseTypedVar(c, s));
    } while (c.nextSibling());
    c.parent();
    return params;
}
function traverseClassBody(c, s) {
    var varInits = [];
    var funcDefs = [];
    do {
        if (isVarInit(c)) {
            varInits.push(traverseVarInit(c, s));
        }
        if (isFuncDef(c)) {
            funcDefs.push(traverseMethDef(c, s));
        }
    } while (c.nextSibling());
    // A class consists of variable initializations and method definitions.
    return { varInits: varInits, classDefs: [], funcDefs: funcDefs, stmts: [] };
}
// A method body consists variable definitions and statements.
function traverseMethBody(c, s) {
    var varInits = [];
    var stmts = [];
    // traverse variable initializations
    do {
        if (!isVarInit(c)) {
            break;
        }
        varInits.push(traverseVarInit(c, s));
    } while (c.nextSibling());
    // get all statement
    do {
        stmts.push(traverseStmt(c, s));
    } while (c.nextSibling());
    return { varInits: varInits, classDefs: [], stmts: stmts, funcDefs: [] };
}
function traverseFuncBody(c, s) {
    var varInits = [];
    var stmts = [];
    do {
        if (!isVarInit(c)) {
            break;
        }
        if (isFuncDef(c)) {
            throw new Error("PARSER ERRO: nested function definition is not allowed");
        }
        varInits.push(traverseVarInit(c, s));
    } while (c.nextSibling());
    // get all statement
    do {
        if (isFuncDef(c)) {
            throw new Error("PARSER ERROR: nested function definition is now allowed");
        }
        if (isVarInit(c)) {
            throw new Error("PARSE ERROR: Variable initialization should go before statements");
        }
        stmts.push(traverseStmt(c, s));
    } while (c.nextSibling());
    return { varInits: varInits, classDefs: [], stmts: stmts, funcDefs: [] };
}
function str2uniop(opStr) {
    switch (opStr) {
        case "-":
            return _ast__WEBPACK_IMPORTED_MODULE_1__.UniOp.Minus;
        case "not":
            return _ast__WEBPACK_IMPORTED_MODULE_1__.UniOp.Not;
    }
    throw new Error("PARSE ERROR: unsupported uniary operator");
}
function str2binop(opStr) {
    switch (opStr) {
        case "+":
            return _ast__WEBPACK_IMPORTED_MODULE_1__.BinOp.Plus;
        case "-":
            return _ast__WEBPACK_IMPORTED_MODULE_1__.BinOp.Minus;
        case "*":
            return _ast__WEBPACK_IMPORTED_MODULE_1__.BinOp.Mul;
        case "//":
            return _ast__WEBPACK_IMPORTED_MODULE_1__.BinOp.Div;
        case "%":
            return _ast__WEBPACK_IMPORTED_MODULE_1__.BinOp.Mod;
        case "==":
            return _ast__WEBPACK_IMPORTED_MODULE_1__.BinOp.Eq;
        case "!=":
            return _ast__WEBPACK_IMPORTED_MODULE_1__.BinOp.Neq;
        case "<=":
            return _ast__WEBPACK_IMPORTED_MODULE_1__.BinOp.Seq;
        case ">=":
            return _ast__WEBPACK_IMPORTED_MODULE_1__.BinOp.Leq;
        case "<":
            return _ast__WEBPACK_IMPORTED_MODULE_1__.BinOp.Sml;
        case ">":
            return _ast__WEBPACK_IMPORTED_MODULE_1__.BinOp.Lrg;
        case "is":
            return _ast__WEBPACK_IMPORTED_MODULE_1__.BinOp.Is;
    }
    throw new Error("PARSE ERROR: unknown binary operator");
}
function traverseWhile(c, s) {
    c.firstChild(); // while
    c.nextSibling(); // cond
    var cond = traverseExpr(c, s);
    var stmts = [];
    c.nextSibling();
    c.firstChild();
    c.nextSibling();
    do {
        stmts.push(traverseStmt(c, s));
    } while (c.nextSibling());
    c.parent();
    c.parent();
    return { tag: "while", cond: cond, stmts: stmts };
}
function traverseIf(c, s) {
    var ifClause = {
        tag: "if",
        ifOp: {
            cond: null,
            stmts: null
        },
        elifOp: {
            cond: null,
            stmts: null,
        },
        elseOp: {
            stmts: null
        }
    };
    // check if
    c.firstChild(); // if
    c.nextSibling();
    ifClause.ifOp.cond = traverseExpr(c, s);
    c.nextSibling();
    c.firstChild();
    c.nextSibling();
    ifClause.ifOp.stmts = [];
    do {
        ifClause.ifOp.stmts.push(traverseStmt(c, s));
    } while (c.nextSibling());
    c.parent();
    if (!c.nextSibling()) {
        c.parent();
        return ifClause;
    }
    // check elif if
    if (c.type.name == 'elif') {
        c.nextSibling();
        ifClause.elifOp.cond = traverseExpr(c, s);
        c.nextSibling();
        c.firstChild();
        c.nextSibling();
        ifClause.elifOp.stmts = [];
        do {
            ifClause.elifOp.stmts.push(traverseStmt(c, s));
        } while (c.nextSibling());
        c.parent();
        if (!c.nextSibling()) {
            c.parent();
            return ifClause;
        }
    }
    // check else
    if (c.type.name == 'else') {
        c.nextSibling();
        c.firstChild();
        c.nextSibling();
        ifClause.elseOp.stmts = [];
        do {
            ifClause.elseOp.stmts.push(traverseStmt(c, s));
        } while (c.nextSibling());
        c.parent();
    }
    c.parent();
    return ifClause;
}
/*
 * Helper Functions
 */
function stringifyTree(t, source, d) {
    var str = "";
    var spaces = " ".repeat(d * 2);
    str += spaces + t.type.name;
    if (["Number", "CallExpression", "BinaryExpression", "UnaryExpression"].includes(t.type.name)) {
        str += "-->" + source.substring(t.from, t.to);
    }
    str += "\n";
    if (t.firstChild()) {
        do {
            str += stringifyTree(t, source, d + 1);
        } while (t.nextSibling());
        t.parent();
    }
    return str;
}


/***/ }),

/***/ "./runner.ts":
/*!*******************!*
  !*** ./runner.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "runwatsrc": () => /* binding */ runwatsrc
/* harmony export */ });
/* harmony import */ var wabt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! wabt */ "wabt");
/* harmony import */ var wabt__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(wabt__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _compiler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compiler */ "./compiler.ts");
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parser */ "./parser.ts");
// This is a mashup of tutorials from:
//
// - https://github.com/AssemblyScript/wabt.js/
// - https://developer.mozilla.org/en-US/docs/WebAssembly/Using_the_JavaScript_API
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};



// NOTE(joe): This is a hack to get the CLI Repl to run. WABT registers a global
// uncaught exn handler, and this is not allowed when running the REPL
// (https://nodejs.org/api/repl.html#repl_global_uncaught_exceptions). No reason
// is given for this in the docs page, and I haven't spent time on the domain
// module to figure out what's going on here. It doesn't seem critical for WABT
// to have this support, so we patch it away.
if (typeof process !== "undefined") {
    var oldProcessOn_1 = process.on;
    process.on = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args[0] === "uncaughtException") {
            return;
        }
        else {
            return oldProcessOn_1.apply(process, args);
        }
    };
}
function runwatsrc(source, config) {
    return __awaiter(this, void 0, void 0, function () {
        var wabtInterface, parsed, returnType, returnExpr, compiled, importObject, wasmSource, myModule, asBinary, wasmModule, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, wabt__WEBPACK_IMPORTED_MODULE_0___default()()];
                case 1:
                    wabtInterface = _a.sent();
                    parsed = (0,_parser__WEBPACK_IMPORTED_MODULE_2__.parse)(source).stmts;
                    returnType = "";
                    returnExpr = "";
                    compiled = _compiler__WEBPACK_IMPORTED_MODULE_1__.compile(source);
                    importObject = config.importObject;
                    wasmSource = "(module\n    (func $print_num (import \"imports\" \"print_num\") (param i32) (result i32))\n    (func $print_bool (import \"imports\" \"print_bool\") (param i32) (result i32))\n    (func $print_none (import \"imports\" \"print_none\") (param i32) (result i32))\n    (func $print (import \"imports\" \"print\") (param i32) (result i32))\n    (func $abs (import \"imports\" \"abs\") (param i32) (result i32))\n    (func $max (import \"imports\" \"max\") (param i32) (param i32) (result i32))\n    (func $min (import \"imports\" \"min\") (param i32) (param i32) (result i32))\n    (func $pow (import \"imports\" \"pow\") (param i32) (param i32) (result i32))\n    (memory (import \"imports\" \"mem\") 1)\n    " + compiled.wasmSource + "\n  )";
                    console.log("wasmSource: " + wasmSource);
                    myModule = wabtInterface.parseWat("test.wat", wasmSource);
                    asBinary = myModule.toBinary({});
                    return [4 /*yield*/, WebAssembly.instantiate(asBinary.buffer, importObject)];
                case 2:
                    wasmModule = _a.sent();
                    result = wasmModule.instance.exports.exported_func();
                    return [2 /*return*/, result];
            }
        });
    });
}


/***/ }),

/***/ "./typecheck.ts":
/*!**********************!*
  !*** ./typecheck.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deepCopyVarEnv": () => /* binding */ deepCopyVarEnv,
/* harmony export */   "newTypeEnv": () => /* binding */ newTypeEnv,
/* harmony export */   "setupEnv": () => /* binding */ setupEnv,
/* harmony export */   "typeCheckProgram": () => /* binding */ typeCheckProgram,
/* harmony export */   "typeCheckStmts": () => /* binding */ typeCheckStmts,
/* harmony export */   "typeCheckExpr": () => /* binding */ typeCheckExpr,
/* harmony export */   "typeCheckBinOp": () => /* binding */ typeCheckBinOp,
/* harmony export */   "isSameType": () => /* binding */ isSameType,
/* harmony export */   "isObject": () => /* binding */ isObject,
/* harmony export */   "typeCheckUniOp": () => /* binding */ typeCheckUniOp,
/* harmony export */   "typeCheckWhile": () => /* binding */ typeCheckWhile,
/* harmony export */   "typeCheckIf": () => /* binding */ typeCheckIf,
/* harmony export */   "typeCheckField": () => /* binding */ typeCheckField,
/* harmony export */   "typeCheckMethod": () => /* binding */ typeCheckMethod,
/* harmony export */   "typeCheckCall": () => /* binding */ typeCheckCall,
/* harmony export */   "typeCheckVarInit": () => /* binding */ typeCheckVarInit,
/* harmony export */   "typeCheckClassDef": () => /* binding */ typeCheckClassDef,
/* harmony export */   "typeCheckFuncDef": () => /* binding */ typeCheckFuncDef,
/* harmony export */   "typeCheckParams": () => /* binding */ typeCheckParams,
/* harmony export */   "typeCheckLiteral": () => /* binding */ typeCheckLiteral,
/* harmony export */   "typeCheckHasReturn": () => /* binding */ typeCheckHasReturn
/* harmony export */ });
/* harmony import */ var _ast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ast */ "./ast.ts");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function deepCopyVarEnv(env) {
    return {
        vars: new Map(env.vars),
        classMethods: new Map(env.classMethods),
        classFields: new Map(env.classFields),
        funcs: new Map(env.funcs),
        retType: env.retType
    };
}
// initialize an environment sturcture
function newTypeEnv() {
    return {
        vars: new Map(),
        classMethods: new Map(),
        classFields: new Map(),
        funcs: new Map(),
        retType: "None"
    };
}
function setupEnv(program) {
    var evn = newTypeEnv();
    // global variables
    program.varInits.forEach(function (v) {
        evn.vars.set(v.name, v.type);
    });
    // class definitions
    program.classDefs.forEach(function (s) {
        if (s.tag !== "class") {
            throw Error("Error: TYPE ERROR: not a class");
        }
        // define the fields (name : type)
        var fields = s.fields;
        var fieldMap = new Map();
        fields.forEach(function (f) {
            fieldMap.set(f.name, f.type);
        });
        evn.classFields.set(s.name, fieldMap);
        // define the methods (name : args and return type)
        var methods = s.methods;
        var methodMap = new Map();
        methods.forEach(function (m) {
            methodMap.set(m.name, [m.params.map(function (p) { return p.type; }), m.retType]);
        });
        evn.classMethods.set(s.name, methodMap);
        // add the class initialization functions
        evn.funcs.set(s.name, [[], { tag: "object", class: s.name }]);
    });
    // function definitions
    program.funcDefs.forEach(function (f) {
        evn.funcs.set(f.name, [f.params.map(function (p) { return p.type; }), f.retType]);
    });
    return evn;
}
function typeCheckProgram(prog) {
    var env = setupEnv(prog);
    var progTyped = {
        varInits: [],
        classDefs: [],
        funcDefs: [],
        stmts: []
    };
    // check global variable => The rhs values should have correct types
    progTyped.varInits = typeCheckVarInit(prog.varInits, env);
    // check class definitions
    progTyped.classDefs = prog.classDefs.map(function (c) { return typeCheckClassDef(c, env); });
    // check function definitions
    progTyped.funcDefs = prog.funcDefs.map(function (f) { return typeCheckFuncDef(f, env); });
    // check main body
    progTyped.stmts = typeCheckStmts(prog.stmts, env);
    return progTyped;
}
function typeCheckStmts(stmts, env) {
    var typedStmts = [];
    stmts.forEach(function (stmt) {
        switch (stmt.tag) {
            case "assign": // e.g. a = 0
                // If the stmt is an "id", we would check of the variable exists.
                // If the stmt is a "getfield", we would check recursively until it's an "id".
                var leftTypedValue = typeCheckExpr(stmt.name, env);
                var rightTypedValue = typeCheckExpr(stmt.value, env); // to get a
                if (!isSameType(leftTypedValue.a, rightTypedValue.a)) {
                    throw Error("Error: TYPE ERROR: Expected type " + leftTypedValue.a + "; got type " + rightTypedValue.a);
                }
                typedStmts.push(__assign(__assign({}, stmt), { a: "None", name: leftTypedValue, value: rightTypedValue }));
                break;
            case "expr":
                var typedExpr = typeCheckExpr(stmt.expr, env);
                typedStmts.push(__assign(__assign({}, stmt), { expr: typedExpr, a: "None" }));
                break;
            case "return":
                var typedRet = typeCheckExpr(stmt.expr, env);
                if (!isSameType(typedRet.a, env.retType)) {
                    throw new Error("Error: TYPE ERROR: return expected type " + env.retType + "; got type " + typedRet.a);
                }
                typedStmts.push(__assign(__assign({}, stmt), { expr: typedRet, a: typedRet.a })); // This can also be "None"
                break;
            case "pass":
                typedStmts.push(__assign(__assign({}, stmt), { a: "None" }));
                break;
            case "while":
                var typedWhile = typeCheckWhile(stmt, env);
                typedStmts.push(__assign(__assign({}, typedWhile), { a: "None" }));
                break;
            case "if":
                var typedIf = typeCheckIf(stmt, env);
                typedStmts.push(__assign(__assign({}, typedIf), { a: "None" }));
                break;
        }
    });
    return typedStmts;
}
function typeCheckExpr(expr, env) {
    switch (expr.tag) {
        case "id": // check if the variable has been defined 
            if (!env.vars.has(expr.name)) {
                throw new Error("TYPE ERROR: not a variable " + expr.name);
            }
            var idType = env.vars.get(expr.name);
            return __assign(__assign({}, expr), { a: idType });
        case "binop":
            return typeCheckBinOp(expr, env);
        case "uniop":
            return typeCheckUniOp(expr, env);
        case "literal":
            return __assign(__assign({}, expr), { a: typeCheckLiteral(expr.literal).a });
        case "call":
            var typedCall = typeCheckCall(expr, env);
            return typedCall;
        case "getfield":
            var typedGetfield = typeCheckField(expr, env);
            return typedGetfield;
        case "method":
            var typedMethod = typeCheckMethod(expr, env);
            return typedMethod;
    }
}
function typeCheckBinOp(expr, env) {
    if (expr.tag != "binop") {
        throw new Error("TYPECHECK  ERROR: typeCheckBinOp only take binary operation");
    }
    switch (expr.op) {
        // work for int
        case _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Plus:
        case _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Minus:
        case _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Mul:
        case _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Div:
        case _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Mod:
        case _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Seq:
        case _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Leq:
        case _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Sml:
        case _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Lrg:
            var leftTyped = typeCheckExpr(expr.left, env); // add the type to the left expression
            var rightTyped = typeCheckExpr(expr.right, env);
            if (!isSameType(leftTyped.a, rightTyped.a) || (leftTyped.a !== "int")) {
                throw new Error("TYPECHECK ERROR: Cannot apply operator '" + expr.op + "' on types '" + leftTyped.a + "' and type '" + rightTyped.a + "'");
            }
            if (expr.op === _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Seq || expr.op === _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Leq || expr.op === _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Sml || expr.op === _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Lrg) {
                return __assign(__assign({}, expr), { left: leftTyped, right: rightTyped, a: "bool" });
            }
            return __assign(__assign({}, expr), { left: leftTyped, right: rightTyped, a: "int" });
        // work for both int and bool, but not None
        case _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Eq:
        case _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Neq:
            var leftTypedEq = typeCheckExpr(expr.left, env);
            var rightTypedEq = typeCheckExpr(expr.right, env);
            // filter out classes and "None"
            if (!isSameType(leftTypedEq.a, rightTypedEq.a) || isObject(leftTypedEq.a) || leftTypedEq.a == "None") {
                throw new Error("TYPECHECK ERROR: Cannot apply operator '" + expr.op + "' on types '" + leftTypedEq.a + "' and type '" + rightTypedEq.a + "'");
            }
            return __assign(__assign({}, expr), { left: leftTypedEq, right: rightTypedEq, a: "bool" });
        // work for None and other classes
        case _ast__WEBPACK_IMPORTED_MODULE_0__.BinOp.Is:
            var leftTypedIs = typeCheckExpr(expr.left, env);
            var rightTypedIs = typeCheckExpr(expr.right, env);
            if (leftTypedIs.a === "int" || leftTypedIs.a === "bool" || rightTypedIs.a === "int" || rightTypedIs.a === "bool") {
                throw new Error("TYPECHECK ERROR: Cannot apply operator '" + expr.op + "' on types '" + leftTypedIs.a + "' and type '" + rightTypedIs.a + "'");
            }
            return __assign(__assign({}, expr), { left: leftTypedIs, right: rightTypedIs, a: "bool" });
    }
}
// should return true in the first statement if both are not objects
function isSameType(s, t) {
    if (s === t) {
        return true; // both "int", "bool", or "None"
    }
    else if (s === "int" || s === "bool") {
        return false;
    }
    else if (t === "int" || t === "bool") {
        return false;
    }
    else if (t === "None" || s === "None") { // "None" is the same type as any classes
        return true;
    }
    else {
        return (s.tag === t.tag && s.class === t.class); // both objects
    }
}
function isObject(s) {
    if (s === "int" || s === "bool" || s === "None") {
        return false;
    }
    return true;
}
function typeCheckUniOp(expr, env) {
    if (expr.tag != "uniop") {
        throw new Error("TYPECHECK  ERROR: typeCheckUniOp only take unary operations");
    }
    switch (expr.op) {
        // work for int
        case _ast__WEBPACK_IMPORTED_MODULE_0__.UniOp.Minus:
            var typedExpr = typeCheckExpr(expr.expr, env);
            if (typedExpr.a !== "int") {
                throw new Error("TYPECHECK ERROR: uniary operator " + _ast__WEBPACK_IMPORTED_MODULE_0__.UniOp.Minus + " expected " + "int" + "; got type " + typedExpr.a);
            }
            return __assign(__assign({}, expr), { expr: typedExpr, a: "int" });
        // work for bool
        case _ast__WEBPACK_IMPORTED_MODULE_0__.UniOp.Not:
            var notTypedExpr = typeCheckExpr(expr.expr, env);
            if (notTypedExpr.a !== "bool") {
                throw new Error("TYPECHECK ERROR: uniary operator " + _ast__WEBPACK_IMPORTED_MODULE_0__.UniOp.Not + " expected " + "bool" + "; got type " + notTypedExpr.a);
            }
            return __assign(__assign({}, expr), { expr: notTypedExpr, a: "bool" });
        default:
            throw new Error("TYPECHECK ERROR: undefined unary operator " + expr + ". This error should be called in parser");
    }
}
function typeCheckWhile(stmt, env) {
    if (stmt.tag !== 'while') {
        throw new Error("TYPECHECK ERROR: the input statement should be while when calling typeCheckWhile");
    }
    var typedWhileCond = typeCheckExpr(stmt.cond, env);
    var typedWhileBody = typeCheckStmts(stmt.stmts, env);
    if (typedWhileCond.a !== "bool") {
        throw new Error("TYPECHECK ERROR: Condtion expression cannot be of type '" + typedWhileCond.a + "'");
    }
    return {
        a: "None",
        tag: 'while',
        cond: typedWhileCond,
        stmts: typedWhileBody
    };
}
function typeCheckIf(stmt, env) {
    if (stmt.tag !== 'if') {
        throw new Error("TYPECHECK ERROR: the input statement should be if when calling typeCheckIf");
    }
    // check if
    var typedIfCond = typeCheckExpr(stmt.ifOp.cond, env);
    var typedIfBody = typeCheckStmts(stmt.ifOp.stmts, env);
    if (typedIfCond.a !== "bool") {
        throw new Error("TYPECHECK ERROR: Condtion expression cannot be of type '" + typedIfCond.a + "'");
    }
    // check elif
    var typedElifCond = null;
    var typedElifBody = null;
    if (stmt.elifOp.cond !== null) {
        typedElifCond = typeCheckExpr(stmt.elifOp.cond, env);
        typedElifBody = typeCheckStmts(stmt.elifOp.stmts, env);
        if (typedElifCond.a !== "bool") {
            throw new Error("TYPECHECK ERROR: Condtion expression cannot be of type '" + typedElifCond.a + "'");
        }
    }
    // check else:
    var tpyedElseBody = null;
    if (stmt.elseOp.stmts !== null) {
        tpyedElseBody = typeCheckStmts(stmt.elseOp.stmts, env);
    }
    return {
        a: "None",
        tag: "if",
        ifOp: { cond: typedIfCond, stmts: typedIfBody },
        elifOp: { cond: typedElifCond, stmts: typedElifBody },
        elseOp: { stmts: tpyedElseBody }
    };
}
function typeCheckField(expr, env) {
    if (expr.tag !== "getfield") {
        throw new Error("TYPECHECK ERROR: typeCheckMethod only accepts a getfield as an input expr");
    }
    var typedObj = typeCheckExpr(expr.obj, env);
    if (typedObj.a === "int" || typedObj.a === "bool" || typedObj.a === "None") { // cannot compile with isObject()
        throw new Error("TYPECHECK ERROR: Only objects can get fields.");
    }
    if (!env.classFields.has(typedObj.a.class)) {
        throw new Error("TYPECHECK ERROR: The class doesn't exist.");
    }
    var classFields = env.classFields.get(typedObj.a.class);
    if (!classFields.has(expr.name)) {
        throw new Error("TYPECHECK ERROR: The field doesn't exist in the class.");
    }
    return __assign(__assign({}, expr), { obj: typedObj, a: classFields.get(expr.name) });
}
function typeCheckMethod(expr, env) {
    if (expr.tag !== "method") {
        throw new Error("TYPECHECK ERROR: typeCheckMethod only accepts a method as an input expr");
    }
    var typedObj = typeCheckExpr(expr.obj, env);
    if (typedObj.a === "int" || typedObj.a === "bool" || typedObj.a === "None") {
        throw new Error("TYPECHECK ERROR: Only classes can call methods.");
    }
    if (!env.classMethods.has(typedObj.a.class)) {
        throw new Error("TYPECHECK ERROR: The class doesn't exist.");
    }
    var classMethods = env.classMethods.get(typedObj.a.class);
    if (!classMethods.has(expr.name)) {
        throw new Error("TYPECHECK ERROR: The method doesn't exist in the class.");
    }
    var _a = classMethods.get(expr.name), argTyps = _a[0], retTyp = _a[1];
    var typedArgs = expr.args.map(function (a) { return typeCheckExpr(a, env); });
    if (argTyps.length != typedArgs.length) { // We escaped "self" in the parser.
        throw new Error("TYPECHECK ERROR: The number of parameters is incorrect.");
    }
    argTyps.forEach(function (t, i) {
        if (!isSameType(t, typedArgs[i].a)) {
            throw new Error("TYPECHECK ERROR: incorrect parameter type");
        }
    });
    return __assign(__assign({}, expr), { obj: typedObj, args: typedArgs, a: retTyp });
}
function typeCheckCall(expr, env) {
    if (expr.tag !== "call") {
        throw new Error("TYPECHECK ERROR: typeCheckCall only accept a call as an input expr");
    }
    if (!env.funcs.has(expr.name)) {
        console.warn("TYPECHECK WARNING: If the " + expr.name + " function is an imported one, we don't do any type check."); // ex. print()
        var typedArgs_1 = expr.args.map(function (arg) {
            return typeCheckExpr(arg, env);
        });
        return __assign(__assign({}, expr), { args: typedArgs_1, a: "None" });
    }
    // check # params
    var params = env.funcs.get(expr.name)[0];
    var args = expr.args;
    if (args.length !== params.length) {
        throw new Error("TYPECHECK ERROR: call func " + expr.name + "; expected " + params.length + " arguments; got " + args.length);
    }
    // check argument type
    var typedArgs = [];
    for (var idx = 0; idx < params.length; ++idx) {
        var typedArg = typeCheckExpr(args[idx], env);
        if (typedArg.a !== params[idx]) {
            throw new Error("TYPECHECK ERROR: call func " + expr.name + "; expected type " + params[idx] + "; got type " + typedArg.a + " in parameters " + idx);
        }
        typedArgs.push(typedArg);
    }
    return __assign(__assign({}, expr), { args: typedArgs, a: env.funcs.get(expr.name)[1] }); // use the return type
}
// make sure the variable type is equal to the literal type
function typeCheckVarInit(inits, env) {
    var typedInits = [];
    var scopeVar = new Set();
    inits.forEach(function (init) {
        // check if the left hand type equals to the right hand type
        // ex. x:int and 1
        var typedLiteral = typeCheckLiteral(init.initLiteral);
        if (!isSameType(init.type, typedLiteral.a) && !(isObject(init.type) && typedLiteral.a === "None")) { // ex. r1 : Rat = None
            throw Error("Error: TYPE ERROR: init type does not match literal type");
        }
        typedInits.push(__assign(__assign({}, init), { a: init.type, initLiteral: typedLiteral })); // add the types to VarInit
    });
    return typedInits;
}
/*
Check the type of class definition:
(1) add the class variables
(2) check each function
*/
function typeCheckClassDef(cls, env) {
    if (cls.tag !== "class") {
        throw new Error("This is not a class statement.");
    }
    // The methods in the class can access the global variables.
    var localEnv = deepCopyVarEnv(env); // include global variables in the local environment
    // check variable initializations
    var localTypedInits = typeCheckVarInit(cls.fields, localEnv); // check the type
    cls.fields.forEach(function (localTypedInit) {
        localEnv.vars.set("self." + localTypedInit.name, localTypedInit.type); // to distinguish self.a from a
    }); // add variables to the environment
    localEnv.vars.set("self", { tag: "object", class: cls.name }); // add the "self" variable to the environment
    // check method definitions
    var localTypedMethods = cls.methods.map(function (m) { return typeCheckFuncDef(m, localEnv); }); // use the same function
    return __assign(__assign({}, cls), { a: "None", fields: localTypedInits, methods: localTypedMethods }); // A class definition doesn't require an "a".
}
/*
 * Check the type of function definition:
 * (1) need to update the type var env before checking the func body
 * (2) need to check the statements
 * (3) the return type
 */
function typeCheckFuncDef(func, env) {
    // The global variables are included in the local environment.
    var localEnv = deepCopyVarEnv(env);
    // add params to envs
    var scopeVar = new Set(); // We need this because localEnv contains global variables.
    var typedParams = typeCheckParams(func.params);
    func.params.forEach(function (param) {
        // Params are added first to check duplicate initializations.
        if (scopeVar.has(param.name)) {
            throw Error("duplicate param declaration in the same field");
        }
        scopeVar.add(param.name);
        localEnv.vars.set(param.name, param.type);
    });
    // check inits -> add to envs
    var localTypedInits = typeCheckVarInit(func.varInits, localEnv);
    func.varInits.forEach(function (localTypedInit) {
        if (scopeVar.has(localTypedInit.name)) {
            throw Error("duplicate init declaration in the same field");
        }
        scopeVar.add(localTypedInit.name);
        localEnv.vars.set(localTypedInit.name, localTypedInit.type);
    });
    // add return type
    localEnv.retType = func.retType;
    // check body statements
    var typedStmts = typeCheckStmts(func.stmts, localEnv);
    // make sure every path has the expected return 
    if (!typeCheckHasReturn(func.stmts, env) && func.retType !== "None") {
        throw new Error("TYPECHECK ERROR: All paths in function/method must have a return statement: " + func.name);
    }
    return __assign(__assign({}, func), { params: typedParams, varInits: localTypedInits, stmts: typedStmts });
}
// simply assign the type to a
function typeCheckParams(params) {
    return params.map(function (p) { return __assign(__assign({}, p), { a: p.type }); });
}
// The tags of literals are their types.
function typeCheckLiteral(literal) {
    switch (literal.tag) {
        case "num":
            return __assign(__assign({}, literal), { a: "int" });
        case "bool":
            return __assign(__assign({}, literal), { a: "bool" });
        case "none":
            return __assign(__assign({}, literal), { a: "None" });
    }
}
/**
 * This function is used to check whether this body argument has the
 * desired return value
 * @param body
 * @param env
 */
function typeCheckHasReturn(body, env) {
    for (var idx = 0; idx < body.length; ++idx) {
        var stmt = body[idx];
        switch (stmt.tag) {
            case "return":
                return true;
            case "if":
                var ifHasRet = typeCheckHasReturn(stmt.ifOp.stmts, env);
                if (stmt.elifOp.cond !== null) {
                    ifHasRet = ifHasRet && typeCheckHasReturn(stmt.elifOp.stmts, env);
                }
                if (stmt.elseOp.stmts !== null) {
                    ifHasRet = ifHasRet && typeCheckHasReturn(stmt.elseOp.stmts, env);
                }
                // check if the above conditions are met
                if (ifHasRet) {
                    return true;
                }
                continue;
            case "pass":
                return false;
            case "expr":
            case "assign":
            case "while":
                continue;
            default:
                throw new Error("TYPECHECK ERROR: typeCheckHasReturn meets unknown statement");
        }
    }
    return false;
}


/***/ }),

/***/ "./webstart.ts":
/*!*********************!*
  !*** ./webstart.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _compiler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compiler */ "./compiler.ts");
/* harmony import */ var _runner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./runner */ "./runner.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


document.addEventListener("DOMContentLoaded", function () { return __awaiter(void 0, void 0, void 0, function () {
    function display(arg) {
        var elt = document.createElement("pre");
        document.getElementById("output").appendChild(elt);
        elt.innerText = arg;
    }
    var memory, importObject, runButton, userCode;
    return __generator(this, function (_a) {
        memory = new WebAssembly.Memory({ initial: 10, maximum: 100 });
        importObject = {
            imports: {
                print_num: function (arg) {
                    console.log("Logging from WASM: ", arg);
                    display(String(arg));
                    return arg;
                },
                print_bool: function (arg) {
                    if (arg === 0) {
                        display("False");
                    }
                    else {
                        display("True");
                    }
                    return arg;
                },
                print_none: function (arg) {
                    display("None");
                    return arg;
                },
                print: function (arg) {
                    console.log("Logging from WASM: ", arg);
                    var elt = document.createElement("pre");
                    document.getElementById("output").appendChild(elt);
                    // elt.innerText = arg;
                    return arg;
                },
                mem: memory,
                abs: Math.abs,
                max: Math.max,
                min: Math.min,
                pow: Math.pow
            },
        };
        runButton = document.getElementById("run");
        userCode = document.getElementById("user-code");
        runButton.addEventListener("click", function () { return __awaiter(void 0, void 0, void 0, function () {
            var program, output, wat, code, result, i32, i, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        program = userCode.value;
                        output = document.getElementById("output");
                        output.textContent = "";
                        console.log("program: " + program);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        wat = (0,_compiler__WEBPACK_IMPORTED_MODULE_0__.compile)(program);
                        code = document.getElementById("generated-code");
                        code.textContent = wat.wasmSource;
                        document.getElementById("");
                        return [4 /*yield*/, (0,_runner__WEBPACK_IMPORTED_MODULE_1__.runwatsrc)(program, { importObject: importObject })];
                    case 2:
                        result = _a.sent();
                        i32 = new Uint32Array(memory.buffer);
                        for (i = 0; i < 10; i++) {
                            console.log("i32[" + i + "]: " + i32[i]);
                        }
                        if (result !== undefined) {
                            output.textContent += String(result);
                        }
                        output.setAttribute("style", "color: black");
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        console.error(e_1);
                        output.textContent = String(e_1);
                        output.setAttribute("style", "color: red");
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        }); });
        userCode.value = localStorage.getItem("program");
        userCode.addEventListener("keypress", function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                localStorage.setItem("program", userCode.value);
                return [2 /*return*/];
            });
        }); });
        return [2 /*return*/];
    });
}); });


/***/ }),

/***/ "wabt":
/*!***********************!*
  !*** external "wabt" ***!
  \***********************/
/***/ ((module) => {

module.exports = wabt;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => module['default'] :
/******/ 				() => module;
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./webstart.ts");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWItYXNtLWppdC8uL25vZGVfbW9kdWxlcy9sZXplci1weXRob24vZGlzdC9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly93ZWItYXNtLWppdC8uL25vZGVfbW9kdWxlcy9sZXplci10cmVlL2Rpc3QvdHJlZS5lcy5qcyIsIndlYnBhY2s6Ly93ZWItYXNtLWppdC8uL25vZGVfbW9kdWxlcy9sZXplci9kaXN0L2luZGV4LmVzLmpzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vYXN0LnRzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vY29tcGlsZXIudHMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9wYXJzZXIudHMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9ydW5uZXIudHMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi90eXBlY2hlY2sudHMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi93ZWJzdGFydC50cyIsIndlYnBhY2s6Ly93ZWItYXNtLWppdC9leHRlcm5hbCBcIndhYnRcIiIsIndlYnBhY2s6Ly93ZWItYXNtLWppdC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly93ZWItYXNtLWppdC93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly93ZWItYXNtLWppdC93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly93ZWItYXNtLWppdC93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3dlYi1hc20taml0L3dlYnBhY2svc3RhcnR1cCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBNEQ7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUU7QUFDYjtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUyxFQUFFLEVBQUU7QUFDYjtBQUNBLEtBQUs7QUFDTCxDQUFDLEVBQUUsRUFBRTs7Ozs7Ozs7Ozs7QUNsSUwsc0I7Ozs7OztVQ0FBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3JCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsZ0NBQWdDLFlBQVk7V0FDNUM7V0FDQSxFOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0Esd0NBQXdDLHlDQUF5QztXQUNqRjtXQUNBO1dBQ0EsRTs7Ozs7V0NQQSxzRjs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSxzREFBc0Qsa0JBQWtCO1dBQ3hFO1dBQ0EsK0NBQStDLGNBQWM7V0FDN0QsRTs7OztVQ05BO1VBQ0E7VUFDQTtVQUNBIiwiZmlsZSI6IndlYnN0YXJ0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0ZXJuYWxUb2tlbml6ZXIsIFBhcnNlciwgTm9kZVByb3AgfSBmcm9tICdsZXplcic7XG5cbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxuY29uc3QgXG4gIHByaW50S2V5d29yZCA9IDEsXG4gIG5ld2xpbmUgPSAxNjQsXG4gIG5ld2xpbmVCcmFja2V0ZWQgPSAxNjUsXG4gIG5ld2xpbmVFbXB0eSA9IDE2NixcbiAgZW9mID0gMTY3LFxuICBjb250aW51ZUJvZHkgPSAxNjgsXG4gIGVuZEJvZHkgPSAxNjksXG4gIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uID0gMjEsXG4gIFR1cGxlRXhwcmVzc2lvbiA9IDQ4LFxuICBDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiA9IDQ5LFxuICBBcnJheUV4cHJlc3Npb24gPSA1MyxcbiAgQXJyYXlDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiA9IDU2LFxuICBEaWN0aW9uYXJ5RXhwcmVzc2lvbiA9IDU3LFxuICBEaWN0aW9uYXJ5Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24gPSA2MCxcbiAgU2V0RXhwcmVzc2lvbiA9IDYxLFxuICBTZXRDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiA9IDYyLFxuICBjb21wb3VuZFN0YXRlbWVudCA9IDIzMTtcblxuY29uc3QgbmV3bGluZSQxID0gMTAsIGNhcnJpYWdlUmV0dXJuID0gMTMsIHNwYWNlID0gMzIsIHRhYiA9IDksIGhhc2ggPSAzNSwgcGFyZW5PcGVuID0gNDAsIGRvdCA9IDQ2O1xuXG5jb25zdCBicmFja2V0ZWQgPSBbXG4gIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uLCBUdXBsZUV4cHJlc3Npb24sIENvbXByZWhlbnNpb25FeHByZXNzaW9uLCBBcnJheUV4cHJlc3Npb24sIEFycmF5Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24sXG4gIERpY3Rpb25hcnlFeHByZXNzaW9uLCBEaWN0aW9uYXJ5Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24sIFNldEV4cHJlc3Npb24sIFNldENvbXByZWhlbnNpb25FeHByZXNzaW9uXG5dLCBwYXJlbnRTdGF0ZW1lbnQgPSBbY29tcG91bmRTdGF0ZW1lbnRdO1xuXG5jb25zdCBjYWNoZXMgPSBuZXcgV2Vha01hcDtcblxuLy8gUGVyLWlucHV0LXN0cmVhbSBpbmRlbnRhdGlvbiBjYWNoZS4gYHByZXZgIG1hcHMgaW5kZW50YXRpb24gZGVwdGhzXG4vLyB0byB0aGUgbGFzdCBwb3NpdGlvbiBhdCB3aGljaCBhIHN0YXRlbWVudCBpbmRlbnRlZCB0byB0aGF0IGRlcHRoXG4vLyB3YXMgc2Vlbi4gVGhlcmUncyBhbiBleHRyYSBzZXQgb2Ygc2xvdHMgZm9yIHRoZSBfY3VycmVudF9cbi8vIGluZGVudGF0aW9uLCBzaW5jZSB0aGF0IG5lZWRzIHRvIGJlIGF2YWlsYWJsZSBhbG9uZ3NpZGUgYSBwcmV2aW91c1xuLy8gaW5kZW50YXRpb24gcG9zaXRpb24gYXQgdGhlIHNhbWUgbGV2ZWwuXG5jbGFzcyBDYWNoZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubGFzdCA9IHRoaXMubGFzdEluZGVudCA9IC0xO1xuICAgIHRoaXMucHJldiA9IFtdO1xuICB9XG5cbiAgZ2V0KHBvcykge1xuICAgIGlmICh0aGlzLmxhc3QgPT0gcG9zKSByZXR1cm4gdGhpcy5sYXN0SW5kZW50XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnByZXYubGVuZ3RoOyBpKyspIGlmICh0aGlzLnByZXZbaV0gPT0gcG9zKSByZXR1cm4gaVxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgc2V0KHBvcywgaW5kZW50KSB7XG4gICAgaWYgKHBvcyA9PSB0aGlzLmxhc3QpIHJldHVyblxuICAgIGlmICh0aGlzLmxhc3QgPiAtMSkgdGhpcy5zZXRQcmV2KHRoaXMubGFzdCwgdGhpcy5sYXN0SW5kZW50KTtcbiAgICB0aGlzLmxhc3QgPSBwb3M7XG4gICAgdGhpcy5sYXN0SW5kZW50ID0gaW5kZW50O1xuICB9XG5cbiAgc2V0UHJldihwb3MsIGluZGVudCkge1xuICAgIHdoaWxlICh0aGlzLnByZXYubGVuZ3RoIDwgaW5kZW50KSB0aGlzLnByZXYucHVzaCgtMSk7XG4gICAgdGhpcy5wcmV2W2luZGVudF0gPSBwb3M7XG4gIH1cblxuICBzdGF0aWMgZm9yKGlucHV0KSB7XG4gICAgbGV0IGZvdW5kID0gY2FjaGVzLmdldChpbnB1dCk7XG4gICAgaWYgKCFmb3VuZCkgY2FjaGVzLnNldChpbnB1dCwgZm91bmQgPSBuZXcgQ2FjaGUpO1xuICAgIHJldHVybiBmb3VuZFxuICB9XG59XG5cbmNvbnN0IG1heEluZGVudCA9IDUwO1xuXG5mdW5jdGlvbiBnZXRJbmRlbnQoaW5wdXQsIHBvcykge1xuICBsZXQgY2FjaGUgPSBDYWNoZS5mb3IoaW5wdXQpLCBmb3VuZCA9IGNhY2hlLmdldChwb3MpO1xuICBpZiAoZm91bmQgPiAtMSkgcmV0dXJuIGZvdW5kXG5cbiAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuIHZlcnkgb2Z0ZW4gKG9yIGV2ZW4gYXQgYWxsKSBpbiBub3JtYWxcbiAgLy8gcGFyc2luZywgc2luY2UgdGhlIGluZGVudGF0aW9ucyBhcmUgc3RvcmVkIGJ5IHRoZSBuZXdsaW5lXG4gIC8vIHRva2VuaXplciBhaGVhZCBvZiB0aW1lLiBCdXQgaXQncyBraW5kIG9mIHRyaWNreSB0byBwcm92ZSB3aGV0aGVyXG4gIC8vIHRoYXQgYWx3YXlzIGhhcHBlbnMgaW4gaW5jcmVtZW50YWwgcGFyc2luZyBzY2VuYXJpb3MsIHNvIGhlcmUncyBhXG4gIC8vIGZhbGxiYWNrIGFueXdheS5cbiAgbGV0IGJlZm9yZSA9IGlucHV0LnJlYWQoTWF0aC5tYXgoMCwgcG9zIC0gbWF4SW5kZW50KSwgcG9zKTtcbiAgbGV0IGNvdW50ID0gMCwgc3RhcnQgPSBiZWZvcmUubGVuZ3RoO1xuICBmb3IgKDsgc3RhcnQgPiAwOyBzdGFydC0tKSB7XG4gICAgbGV0IG5leHQgPSBiZWZvcmUuY2hhckNvZGVBdChzdGFydCAtIDEpO1xuICAgIGlmIChuZXh0ID09IG5ld2xpbmUkMSB8fCBuZXh0ID09IGNhcnJpYWdlUmV0dXJuKSBicmVha1xuICB9XG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGJlZm9yZS5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjaCA9IGJlZm9yZS5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjaCA9PSBzcGFjZSkgY291bnQrKztcbiAgICBlbHNlIGlmIChjaCA9PSB0YWIpIGNvdW50ICs9IDggLSAoY291bnQgJSA4KTtcbiAgICBlbHNlIGJyZWFrXG4gIH1cbiAgY2FjaGUuc2V0UHJldihwb3MsIGNvdW50KTtcbiAgcmV0dXJuIGNvdW50XG59XG5cbmNvbnN0IG5ld2xpbmVzID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgdG9rZW4sIHN0YWNrKSA9PiB7XG4gIGxldCBuZXh0ID0gaW5wdXQuZ2V0KHRva2VuLnN0YXJ0KTtcbiAgaWYgKG5leHQgPCAwKSB7XG4gICAgdG9rZW4uYWNjZXB0KGVvZiwgdG9rZW4uc3RhcnQpO1xuICAgIHJldHVyblxuICB9XG4gIGlmIChuZXh0ICE9IG5ld2xpbmUkMSAmJiBuZXh0ICE9IGNhcnJpYWdlUmV0dXJuKSByZXR1cm5cbiAgaWYgKHN0YWNrLnN0YXJ0T2YoYnJhY2tldGVkKSAhPSBudWxsKSB7XG4gICAgdG9rZW4uYWNjZXB0KG5ld2xpbmVCcmFja2V0ZWQsIHRva2VuLnN0YXJ0ICsgMSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgbGV0IHNjYW4gPSB0b2tlbi5zdGFydCArIDEsIGluZGVudCA9IDA7XG4gIGZvciAoOyBzY2FuIDwgaW5wdXQubGVuZ3RoOyBzY2FuKyspIHtcbiAgICBsZXQgY2ggPSBpbnB1dC5nZXQoc2Nhbik7XG4gICAgaWYgKGNoID09IHNwYWNlKSBpbmRlbnQrKztcbiAgICBlbHNlIGlmIChjaCA9PSB0YWIpIGluZGVudCArPSA4IC0gKGluZGVudCAlIDgpO1xuICAgIGVsc2UgaWYgKGNoID09IG5ld2xpbmUkMSB8fCBpbmRlbnQgPT0gY2FycmlhZ2VSZXR1cm4gfHwgY2ggPT0gaGFzaCkge1xuICAgICAgdG9rZW4uYWNjZXB0KG5ld2xpbmVFbXB0eSwgdG9rZW4uc3RhcnQgKyAxKTtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICB0b2tlbi5hY2NlcHQobmV3bGluZSwgdG9rZW4uc3RhcnQgKyAxKTtcbiAgQ2FjaGUuZm9yKGlucHV0KS5zZXQoc2NhbiwgaW5kZW50KTtcbn0sIHtjb250ZXh0dWFsOiB0cnVlLCBmYWxsYmFjazogdHJ1ZX0pO1xuXG5jb25zdCBib2R5Q29udGludWUgPSBuZXcgRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCB0b2tlbiwgc3RhY2spID0+IHtcbiAgbGV0IHBhcmVudCA9IHN0YWNrLnN0YXJ0T2YocGFyZW50U3RhdGVtZW50KTtcbiAgbGV0IHBhcmVudEluZGVudCA9IHBhcmVudCA9PSBudWxsID8gMCA6IGdldEluZGVudChpbnB1dCwgcGFyZW50KTtcbiAgbGV0IGluZGVudEhlcmUgPSBnZXRJbmRlbnQoaW5wdXQsIHRva2VuLnN0YXJ0KTtcbiAgdG9rZW4uYWNjZXB0KGluZGVudEhlcmUgPD0gcGFyZW50SW5kZW50ID8gZW5kQm9keSA6IGNvbnRpbnVlQm9keSwgdG9rZW4uc3RhcnQpO1xufSwge2NvbnRleHR1YWw6IHRydWUsIGZhbGxiYWNrOiB0cnVlfSk7XG5cbmNvbnN0IGxlZ2FjeVByaW50ID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgdG9rZW4pID0+IHtcbiAgbGV0IHBvcyA9IHRva2VuLnN0YXJ0O1xuICBmb3IgKGxldCBwcmludCA9IFwicHJpbnRcIiwgaSA9IDA7IGkgPCBwcmludC5sZW5ndGg7IGkrKywgcG9zKyspXG4gICAgaWYgKGlucHV0LmdldChwb3MpICE9IHByaW50LmNoYXJDb2RlQXQoaSkpIHJldHVyblxuICBsZXQgZW5kID0gcG9zO1xuICBpZiAoL1xcdy8udGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGlucHV0LmdldChwb3MpKSkpIHJldHVyblxuICBmb3IgKDs7IHBvcysrKSB7XG4gICAgbGV0IG5leHQgPSBpbnB1dC5nZXQocG9zKTtcbiAgICBpZiAobmV4dCA9PSBzcGFjZSB8fCBuZXh0ID09IHRhYikgY29udGludWVcbiAgICBpZiAobmV4dCAhPSBwYXJlbk9wZW4gJiYgbmV4dCAhPSBkb3QgJiYgbmV4dCAhPSBuZXdsaW5lJDEgJiYgbmV4dCAhPSBjYXJyaWFnZVJldHVybiAmJiBuZXh0ICE9IGhhc2gpXG4gICAgICB0b2tlbi5hY2NlcHQocHJpbnRLZXl3b3JkLCBlbmQpO1xuICAgIHJldHVyblxuICB9XG59KTtcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBzcGVjX2lkZW50aWZpZXIgPSB7X19wcm90b19fOm51bGwsYXdhaXQ6NDAsIG9yOjQ4LCBhbmQ6NTAsIGluOjU0LCBub3Q6NTYsIGlzOjU4LCBpZjo2NCwgZWxzZTo2NiwgbGFtYmRhOjcwLCBzZWxmOjc0LCB5aWVsZDo5MCwgZnJvbTo5MiwgYXN5bmM6MTAwLCBmb3I6MTAyLCBOb25lOjE1NCwgVHJ1ZToxNTYsIEZhbHNlOjE1NiwgZGVsOjE3MCwgcGFzczoxNzQsIGJyZWFrOjE3OCwgY29udGludWU6MTgyLCByZXR1cm46MTg2LCByYWlzZToxOTQsIGltcG9ydDoxOTgsIGFzOjIwMCwgZ2xvYmFsOjIwNCwgbm9ubG9jYWw6MjA2LCBhc3NlcnQ6MjEwLCBlbGlmOjIyMCwgd2hpbGU6MjI0LCB0cnk6MjMwLCBleGNlcHQ6MjMyLCBmaW5hbGx5OjIzNCwgd2l0aDoyMzgsIGRlZjoyNDIsIGNsYXNzOjI1Mn07XG5jb25zdCBwYXJzZXIgPSBQYXJzZXIuZGVzZXJpYWxpemUoe1xuICB2ZXJzaW9uOiAxMyxcbiAgc3RhdGVzOiBcIiE7W09gUSFMVE9PTyVmUSFMVU8nI0djT09RIUxRJyNDbScjQ21PT1EhTFEnI0NuJyNDbk8nVVEhTFNPJyNDbE8oelEhTFVPJyNHYk9PUSFMUScjR2MnI0djT09RIUxRJyNEUycjRFNPT1EhTFEnI0diJyNHYk8paFEhTFNPJyNDcU8peFEhTFNPJyNEY08qWVEhTFNPJyNEZ09PUSFMUScjRHQnI0R0TyptT1dPJyNEdE8qdU9gTycjRHRPKn1PcE8nI0R1TytZTyFiTycjRHVPK2VPI3RPJyNEdU8rcE8mak8nI0R1Ty1yUSFMVU8nI0dTT09RIUxRJyNHUycjR1NPJ1VRIUxTTycjR1JPL1VRIUxVTycjR1JPT1EhTFEnI0VeJyNFXk8vbVEhTFNPJyNFX09PUSFMUScjR1EnI0dRTy93USFMU08nI0dQT09RJkZWJyNHUCcjR1BPMFNRIUxTTycjRlFPT1EhTFEnI0Z0JyNGdE8wWFEhTFNPJyNGUE9PUSZGVicjSF0nI0hdT09RJkZWJyNHTycjR09PT1EhTFInI0ZTJyNGU1FgUSFMVE9PTydVUSFMU08nI0NvTzBnUSFMU08nI0N6TzBuUSFMU08nI0RPTzFQUSFMU08nI0dnTzFhUSFMVU8nI0VSTydVUSFMU08nI0VTT09RIUxRJyNFVScjRVVPT1EhTFEnI0VXJyNFV09PUSFMUScjRVknI0VZTzF1USFMU08nI0VbTzJTUSFMU08nI0VgTzBTUSFMU08nI0ViTzJnUSFMVU8nI0ViTzBTUSFMU08nI0VlTy9tUSFMU08nI0VoTy9tUSFMU08nI0VsTy9tUSFMU08nI0VvTzJyUSFMU08nI0VxTzJ5USFMU08nI0V2TzNVUSFMU08nI0VyTy9tUSFMU08nI0V2TzBTUSFMU08nI0V4TzBTUSFMU08nI0V9T09RIUxRJyNDYycjQ2NPT1EhTFEnI0NkJyNDZE9PUSFMUScjQ2UnI0NlT09RIUxRJyNDZicjQ2ZPT1EhTFEnI0NnJyNDZ09PUSFMUScjQ2gnI0NoT09RIUxRJyNDaicjQ2pPJ1VRIUxTTyw1OHxPJ1VRIUxTTyw1OHxPJ1VRIUxTTyw1OHxPJ1VRIUxTTyw1OHxPJ1VRIUxTTyw1OHxPJ1VRIUxTTyw1OHxPJ1VRIUxTTyw1OHxPM1pRIUxTTycjRG5PT1EhTFEsNTpYLDU6WE8zblEhTFNPLDU6W08ze1EjKVdPLDU6W080UVEhTFVPLDU5V08wZ1EhTFNPLDU5X08wZ1EhTFNPLDU5X08wZ1EhTFNPLDU5X082cFEhTFNPLDU5X082dVEhTFNPLDU5X082fFEhTFNPLDU5Z083VFEhTFNPJyNHYk84WlEhTFNPJyNHYU9PUSFMUScjR2EnI0dhT09RIUxRJyNEWScjRFlPOHJRIUxTTyw1OV1PJ1VRIUxTTyw1OV1POVFRIUxTTyw1OV1POVZRIUxTTyw1OlFPJ1VRIUxTTyw1OlFPT1EhTFEsNTl9LDU5fU85ZVEhTFNPLDU5fU85alEhTFNPLDU6V08nVVEhTFNPLDU6V08nVVEhTFNPLDU6VU9PUSFMUSw1OlIsNTpSTzl7USFMU08sNTpSTzpRUSFMU08sNTpWT09PTycjRl0nI0ZdTzpWT1dPLDU6YE9PUSFMUSw1OmAsNTpgT09PTycjRl4nI0ZeTzpfT2BPLDU6YE86Z1EhTFNPJyNEdk9PT08nI0ZfJyNGX086d09wTyw1OmFPT1EhTFEsNTphLDU6YU9PT08nI0ZiJyNGYk87U08hYk8sNTphT09PTycjRmMnI0ZjTztfTyN0Tyw1OmFPT09PJyNGZCcjRmRPO2pPJmpPLDU6YU9PUSFMUScjRmUnI0ZlTzt1USFMVU8sNTplTz5nUSFMVU8sNTxtTz9RUSM0Xk8nI0ZmTz90USFMVU8sNTxtT09RIUxRLDU6eSw1OnlPQF1RIUxUTycjRm1PQWxRIUxTTyw1O1VPT1EmRlYsNTxrLDU8a09Bd1EhTFVPJyNIWU9CYFEhTFNPLDU7bE9PUSFMUS1FOXItRTlyT09RJkZWLDU7ayw1O2tPM1BRIUxTTycjRXhPT1EhTFItRTlRLUU5UU9CaFEhTFVPLDU5Wk9Eb1EhTFVPLDU5Zk9FWVEhTFNPJyNHZE9FZVEhTFNPJyNHZE8wU1EhTFNPJyNHZE9FcFEhTFNPJyNEUU9FeFEhTFNPLDU5ak9FfVEhTFNPJyNHaE8nVVEhTFNPJyNHaE8vbVEhTFNPLDU9Uk9PUSFMUSw1PVIsNT1STy9tUSFMU08nI0R9T09RIUxRJyNFTycjRU9PRmxRIUxTTycjRmdPRnxRIUxTTyw1OHpPR1tRIUxTTyw1OHpPKWtRIUxTTyw1OmtPR2FRIUxVTycjR2pPT1EhTFEsNTpuLDU6bk9PUSFMUSw1OnYsNTp2T0d0USFMU08sNTp6T0hWUSFMU08sNTp8T09RIUxRJyNGaicjRmpPSGVRIUxVTyw1OnxPSHNRIUxTTyw1OnxPSHhRIUxTTycjSFtPT1EhTFEsNTtQLDU7UE9JV1EhTFNPJyNIWE9PUSFMUSw1O1MsNTtTTzNVUSFMU08sNTtXTzNVUSFMU08sNTtaT0lpUSFMVU8nI0heTydVUSFMU08nI0heT0lzUSFMU08sNTtdTzJyUSFMU08sNTtdTy9tUSFMU08sNTtiTzBTUSFMU08sNTtkT0l4USFMVE8nI0VtT0tSUSZGWE8sNTteT05qUSFMU08nI0hfTzNVUSFMU08sNTtiT051USFMU08sNTtkT056USFMU08sNTtpTyEjb1EhTFVPMUcuaE8hI3ZRIUxVTzFHLmhPISZnUSFMVU8xRy5oTyEmcVEhTFVPMUcuaE8hKVtRIUxVTzFHLmhPISlvUSFMVU8xRy5oTyEqU1EhTFVPMUcuaE8hLHJRIUxTTycjR3BPIS1RUSFMVU8nI0dTTy9tUSFMU08nI0dwTyEtW1EhTFNPJyNHb09PUSFMUSw1OlksNTpZTyEtZFEhTFNPLDU6WU8hLWlRIUxTTycjR3FPIS10USFMU08nI0dxTyEuWFEhTFNPMUcvdk9PUSFMUScjRHInI0RyT09RIUxRMUcvdjFHL3ZPT1EhTFExRy55MUcueU8hL1hRIUxVTzFHLnlPIS9gUSFMVU8xRy55TzBnUSFMU08xRy55TyEve1EhTFNPMUcvUk9PUSFMUScjRFgnI0RYTy9tUSFMU08sNTlyT09RIUxRMUcudzFHLndPITBTUSFMU08xRy9kTyEwZFEhTFNPMUcvZE8hMGxRIUxTTzFHL2VPJ1VRIUxTTycjR2lPITBxUSFMU08nI0dpTyEwdlEhTFVPMUcud08hMVdRIUxTTyw1OWZPITJeUSFMU08nI0ZYTyEycVEhTFNPLDU9WE8hMnlRIUxTTzFHL2xPITNPUSFMVU8xRy9sT09RIUxRMUcvaTFHL2lPITNgUSFMU08nI0ZVTyE0WVEhTFNPLDU9U08vbVEhTFNPMUcvcE8hNHdRIUxTTzFHL3JPITR8USFMVU8xRy9yTyE1XlEhTFVPMUcvcE9PUSFMUTFHL20xRy9tT09RIUxRMUcvcTFHL3FPT09PLUU5Wi1FOVpPT1EhTFExRy96MUcvek9PT08tRTlbLUU5W08hNW5RIUxTTycjR3xPL21RIUxTTycjR3xPITV8USFMU08sNTpiT09PTy1FOV0tRTldT09RIUxRMUcvezFHL3tPT09PLUU5YC1FOWBPT09PLUU5YS1FOWFPT09PLUU5Yi1FOWJPT1EhTFEtRTljLUU5Y08hNlhRIUxVTzFHMlhPJ1VRIUxTTyw1PFFPT1EhTFEsNTxRLDU8UU9PUSFMUS1FOWQtRTlkT09RIUxRLDU8WCw1PFhPT1EhTFEtRTlrLUU5a09PUSZGVjFHMHAxRzBwTzBTUSFMU08nI0ZpTyE2cFEhTFVPLDU9dE9PUSFMUTFHMVcxRzFXTyE3WFEhTFNPMUcxV09PUSFMUScjRFQnI0RUTy9tUSFMU08sNT1PT09RIUxRLDU9Tyw1PU9PITdeUSFMU08nI0ZUTyE3bFEhTFNPLDU5bE8hN3RRIUxTTzFHL1VPIThPUSFMVU8sNT1TT09RIUxRMUcybTFHMm1PT1EhTFEsNTppLDU6aU8hOG9RIUxTTycjR1JPT1EhTFEsNTxSLDU8Uk9PUSFMUS1FOWUtRTllTyE5UVEhTFNPMUcuZk9PUSFMUTFHMFYxRzBWTyE5YFEhTFNPJyNGV08hOXNRIUxTTyw1PVVPL21RIUxTTzFHMGZPL21RIUxTTzFHMGZPMFNRIUxTTzFHMGhPT1EhTFEtRTloLUU5aE8hOlVRIUxTTzFHMGhPITphUSFMU08xRzBoTyE6ZlEhTFNPJyNGbE8hOndRIUxTTyw1PXZPITtWUSFMU08nI0ZoTyE7cFEhTFNPLDU9c08hPFJRJkZYTzFHMHJPIT9nUSZGWE8xRzB1TyFCeFEhTFNPJyNGcE8hQ1ZRIUxTTyw1PXhPIUNfUSFMVU8sNT14Ty9tUSFMU08xRzB3TyFDaVEhTFNPMUcwd08zVVEhTFNPMUcwfE9OdVEhTFNPMUcxT09PUSZGViw1O1gsNTtYTyFDblEhTFRPLDU7WE8hRWFRJkZYTzFHMHhPIUh4USFMU08nI0ZxTzNVUSFMU08xRzB4TzNVUSFMU08xRzB4TyFJVlEhTFNPJyNGck8hSWdRIUxTTyw1PXlPMFNRIUxTTyw1PXlPT1EmRlYxRzB8MUcwfE8hSlFRIUxTTycjRXpPIUpYUSMpV08xRzFPT09RJkZWMUcxVDFHMVRPM1VRIUxTTzFHMVRPT1EhTFEsNT1bLDU9W09PUSFMUScjRG8nI0RvTy9tUSFMU08sNT1bTyFKYVEhTFNPJyNGWk8hSndRIUxTTyw1PVpPT1EhTFExRy90MUcvdE8hS1BRIUxTTycjRltPIUtkUSFMU08sNT1dTyFLbFEhTFNPLDU9XU8hTFBRIUxTTyw1PV1PIUxhUSFMU08sNT1dT09RIUxRNyslYjcrJWJPT1EhTFE3KyRlNyskZU8hN3RRIUxTTzcrJG1PIU5TUSFMU08xRy55TyFOWlEhTFNPMUcueU9PUSFMUTFHL14xRy9eT09RIUxRLDU7cSw1O3FPJ1VRIUxTTyw1O3FPT1EhTFE3KyVPNyslT08hTmJRIUxTTzcrJU9PT1EhTFEtRTlULUU5VE9PUSFMUTcrJVA3KyVQTyFOclEhTFNPLDU9VE8nVVEhTFNPLDU9VE9PUSFMUTcrJGM3KyRjTyFOd1EhTFNPNyslT08jIFBRIUxTTzcrJVBPT1EhTFEsNTtzLDU7c08nVVEhTFNPLDU7c09PUSFMUS1FOVYtRTlWT09RIUxRNyslVzcrJVdPIyBVUSFMU08xRzJzTyMgXlEhTFNPNyslV09PUSFMUSw1O3AsNTtwTydVUSFMU08sNTtwT09RIUxRLUU5Uy1FOVNPIyBjUSFMU083KyVbT09RIUxRNyslXjcrJV5PIyBxUSFMU08xRzJuTyMhYFEhTFNPNyslXk8jIWVRIUxTTycjRllPIyF4USFMU08xRzJ0TyMjUVEhTFNPNyslW08jI1ZRIUxTTycjRmBPIyNwUSFMU08sNT1oTyMjcFEhTFNPLDU9aE8jJE9PTWhPJyNEeE8jJFpPUU8nI0d9T09PTzFHL3wxRy98TyMkYFEhTFNPMUcvfE8jJGhRIUxVTzFHMWxPT1EhTFEsNTxULDU8VE9PUSFMUS1FOWctRTlnT09RIUxRNysmcjcrJnJPT1EhTFExRzJqMUcyak9PUSFMUSw1O28sNTtvT09RIUxRLUU5Ui1FOVJPT1EhTFE3KyRwNyskcE8jJVJRIUxTTycjRmZPIyVvUSFMU08sNTxtTyMmUVEhTFVPLDU7ck9PUSFMUS1FOVUtRTlVT09RIUxRNysmUTcrJlFPIyZlUSFMU083KyZRT09RIUxRNysmUzcrJlNPIyZzUSFMU08nI0haTzBTUSFMU083KyZTTyMnWFEhTFNPNysmU09PUSFMUSw1PFcsNTxXT09RIUxRLUU5ai1FOWpPT1EhTFEsNTxTLDU8U09PUSFMUS1FOWYtRTlmTyMnZFEmRlhPNysmXk8hSHhRIUxTTycjRm9PM1VRIUxTTzcrJl5PM1VRIUxTTzcrJmFPIyp4USFMVU8sNTxbTydVUSFMU08sNTxbT09RIUxRLUU5bi1FOW5PIytTUSFMU08xRzNkTzNVUSFMU083KyZjTy9tUSFMU083KyZjT09RJkZWNysmaDcrJmhPIUpYUSMpV083KyZqTyMrW1EmRldPMUcwc09PUSZGVi1FOW8tRTlvTzNVUSFMU083KyZkTzNVUSFMU083KyZkT09RJkZWLDU8XSw1PF1PIytnUSFMU08sNTxdT09RJkZWNysmZDcrJmRPIytyUSZGWE83KyZkTyMvVFEhTFNPLDU8Xk9PUSFMUS1FOXAtRTlwTyMvYFEhTFNPMUczZU8jL2hRIUxTTycjSGFPIy92USFMU08nI0hhTzBTUSFMU08nI0hhT09RIUxRJyNIYScjSGFPIzBSUSFMU08nI0hgT09RIUxRLDU7Ziw1O2ZPIzBaUSFMU08sNTtmTy9tUSFMU08nI0V8T09RJkZWNysmajcrJmpPM1VRIUxTTzcrJmpPT1EmRlY3KyZvNysmb09PUSFMUTFHMnYxRzJ2T09RIUxRLDU7dSw1O3VPT1EhTFEtRTlYLUU5WE8jMGBRIUxTTyw1O3ZPIzBrUSFMU08sNTt2T09RIUxRLUU5WS1FOVlPIzFPUSFMU08xRzJ3TyMxV1EhTFNPMUcyd08jMWhRIUxTTzFHMndPIzFPUSFMU08xRzJ3T09RIUxRPDxIWDw8SFhPIzFzUSFMVU8xRzFdT09RIUxRPDxIajw8SGpQIzF9USFMU08nI0ZWTzZ8USFMU08xRzJvTyMyW1EhTFNPMUcyb08jMmFRIUxTTzw8SGpPT1EhTFE8PEhrPDxIa08jMnFRIUxVTzFHMV9PT1EhTFE8PEhyPDxIck8jMntRIUxVTzFHMVtPIzNsUSFMU083KyhgTyMzdFEhTFNPPDxIdk9PUSFMUTw8SHg8PEh4TyMzeVEhTFNPLDU7dE8nVVEhTFNPLDU7dE9PUSFMUS1FOVctRTlXT09RIUxRPDxIdjw8SHZPT1EhTFEsNTt6LDU7ek8vbVEhTFNPLDU7ek9PUSFMUS1FOV4tRTleTyM0T1EhTFNPMUczU09PT08nI0ZhJyNGYU8jNF5PTWhPLDU6ZE9PT08sNT1pLDU9aU9PT083KyVoNyslaE8jNGlRIUxTTzFHMlhPL21RIUxTTzw8SWxPIzR6USFMU08nI0ZrTyM1YFEhTFNPLDU9dU8wU1EhTFNPLDU9dU8jNXFRIUxTTzw8SW5PT1EhTFE8PEluPDxJbk8wU1EhTFNPPDxJbk9PUSZGVi1FOW0tRTltTzNVUSFMU088PEl4T09RJkZWLDU8Wiw1PFpPM1VRIUxTTyw1PFpPT1EmRlY8PEl4PDxJeE9PUSZGVjw8SXs8PEl7TyM1dlEhTFVPMUcxdk8jNlFRJkZYTzw8SX1PM1VRIUxTTzw8SX1PT1EmRlY8PEpVPDxKVU8zVVEhTFNPPDxKVU8hQ25RIUxUTycjRm5PIzljUSZGV083KyZfT09RJkZWNysmXzcrJl9PT1EmRlY8PEpPPDxKT08jOW5RJkZYTzw8Sk9PT1EmRlYxRzF3MUcxd08wU1EhTFNPMUcxd08zVVEhTFNPPDxKT08wU1EhTFNPMUcxeE8jPVBRIUxTTzcrKVBPT1EhTFEnI0V7JyNFe08vbVEhTFNPLDU9e08jPVhRIUxTTyw1PXtPT1EhTFEsNT17LDU9e08jPWRRIUxTTycjRnNPIz1uUSFMU08sNT16T09RIUxRMUcxUTFHMVFPT1EhTFEsNTtoLDU7aE8jPXZRIUxTTzFHMWJPIz5aUSFMU08xRzFiTyM+a1EhTFNPMUcxYk8jPnZRIUxTTzcrKGNPIz52USFMU083KyhjTyM/T1EhTFNPNysoY08jP2BRIUxTTzcrKFpPNnxRIUxTTzcrKFpPT1EhTFFBTj5VQU4+VU9PUSFMUUFOPmJBTj5iTy9tUSFMU08xRzFgTyM/eVEhTFVPMUcxYE9PUSFMUTFHMWYxRzFmT09PTy1FOV8tRTlfT09RIUxRQU4/V0FOP1dPI0BUUSFMU08sNTxWT09RIUxRLUU5aS1FOWlPI0BpUSFMU08xRzNhT09RIUxRQU4/WUFOP1lPI0B6USFMU09BTj9ZT09RJkZWQU4/ZEFOP2RPT1EmRlYxRzF1MUcxdU8zVVEhTFNPQU4/aU8jQVBRJkZYT0FOP2lPT1EmRlZBTj9wQU4/cE9PUSZGVSw1PFksNTxZT09RJkZVLUU5bC1FOWxPT1EmRlY8PEl5PDxJeU8zVVEhTFNPQU4/ak8zVVEhTFNPNysnY09PUSZGVkFOP2pBTj9qT09RIUxRNysnZDcrJ2RPT1EhTFExRzNnMUczZ08vbVEhTFNPMUczZ09PUSFMUSw1PF8sNTxfT09RIUxRLUU5cS1FOXFPI0RiUSFMU083KyZ8TyNEclEhTFNPNysmfE9PUSFMUTcrJnw3KyZ8TyNEfVEhTFNPPDxLfU8jRH1RIUxTTzw8S31PI0VWUSFMU08nI0drT09RIUxRPDxLdTw8S3VPI0VhUSFMU088PEt1T09RIUxRNysmejcrJnpPMFNRIUxTTzFHMXFPI0V6USFMU083Kyh7T09RIUxRRzI0dEcyNHRPT1EmRlZHMjVURzI1VE8zVVEhTFNPRzI1VE9PUSZGVkcyNVVHMjVVT09RJkZWPDxKfTw8Sn1PT1EhTFE3KylSNyspUk9PUSFMUTw8Smg8PEpoTyNGXVEhTFNPPDxKaE8jRm1RIUxTT0FOQWlPI0Z1USFMU08nI0dsT09RIUxRJyNHbCcjR2xPMG5RIUxTTycjRGJPI0dgUSFMU08sNT1WT09RIUxRQU5BYUFOQWFPT1EhTFE3KyddNysnXU9PUSZGVkxEKm9MRCpvT09RIUxRQU5AU0FOQFNPI0d3USFMU08sNTl8T09RIUxRMUcycTFHMnFPI0VWUSFMU08xRy9oT09RIUxRNyslUzcrJVNPNnxRIUxTTycjQ3pPNnxRIUxTTyw1OV9PNnxRIUxTTyw1OV9PNnxRIUxTTyw1OV9PI0d8USFMVU8sNTxtTzZ8USFMU08xRy55Ty9tUSFMU08xRy9VTy9tUSFMU083KyRtTydVUSFMU08nI0dSTyNIYVEhTFNPLDU5X08jSGZRIUxTTyw1OV9PI0htUSFMU08sNTlqTyNIclEhTFNPMUcvUk8wblEhTFNPJyNET082fFEhTFNPLDU5Z1wiLFxuICBzdGF0ZURhdGE6IFwiI0lUfk8kcU9TJGxPUyRrT1NRT1N+T1BoT1RlT2RzT2ZYT2x0T3AhU09zdU91ZE99dk8hTyFQTyFTIVZPIVQhVU8hV1lPIVtaTyFnZE8hbmRPIW9kTyFwZE8hd3hPIXl5TyF7ek8hfXtPI1B8TyNUfU8jViFPTyNZIVFPI1ohUU8jXSFSTyNkIVRPI2chV08jayFYTyNtIVlPI3IhWk8jdWxPJGpxTyR8UU8kfVFPJVJSTyVTVk8lZ1tPJWhdTyVrXk8lbl9PJXRgTyV3YU8leWJPfk9UIWFPXSFhT18hYk9mIWpPIVchbE8hZSFtTyR3IVtPJHghXU8keSFeTyR6IV9PJHshX08kfCFgTyR9IWBPJU8hYU8lUCFhTyVRIWFPfk9oJVZYaSVWWGolVlhrJVZYbCVWWG0lVlhwJVZYeCVWWHklVlghdCVWWCNfJVZYJGolVlgkbSVWWCVYJVZYIVAlVlghUyVWWCFUJVZYJVklVlghWCVWWCFdJVZYIU8lVlgjVyVWWHElVlghayVWWH5QJGJPZHNPZlhPdWRPIVdZTyFbWk8hZ2RPIW5kTyFvZE8hcGRPJHxRTyR9UU8lUlJPJVNWTyVnW08laF1PJWteTyVuX08ldGBPJXdhTyV5Yk9+T3glVVh5JVVYI18lVVgkaiVVWCRtJVVYJVglVVh+T2ghcE9pIXFPaiFvT2shb09sIXJPbSFzT3AhdE8hdCVVWH5QKGZPVCF6T2wscU9zLU9PfXZPflAnVU9UIX1PbCxxT3MtT08hWCNPT35QJ1VPVCNST18jU09sLHFPcy1PTyFdI1RPflAnVU8laSNXTyVqI1lPfk8lbCNaTyVtI1lPfk8hWyNdTyVvI15PJXMjYE9+TyFbI11PJXUjYU8ldiNgT35PIVsjXU8laiNgTyV4I2NPfk8hWyNdTyVtI2BPJXojZU9+T1QkdlhdJHZYXyR2WGYkdlhoJHZYaSR2WGokdlhrJHZYbCR2WG0kdlhwJHZYeCR2WCFXJHZYIWUkdlgkdyR2WCR4JHZYJHkkdlgkeiR2WCR7JHZYJHwkdlgkfSR2WCVPJHZYJVAkdlglUSR2WCFQJHZYIVMkdlghVCR2WH5PJWdbTyVoXU8la15PJW5fTyV0YE8ld2FPJXliT3kkdlghdCR2WCNfJHZYJGokdlgkbSR2WCVYJHZYJVkkdlghWCR2WCFdJHZYIU8kdlgjVyR2WHEkdlghayR2WH5QK3tPeCNqT3kkdVghdCR1WCNfJHVYJGokdVgkbSR1WCVYJHVYfk9sLHFPcy1PT35QJ1VPI18jbU8kaiNvTyRtI29Pfk8lU1ZPfk8hUyN0TyNtIVlPI3IhWk8jdWxPfk9sdE9+UCdVT1QjeU9fI3pPdSN4TyVTVk95dFB+T1QkT09sLHFPcy1PTyFPJFBPflAnVU95JFJPIXQkV08lWCRTTyNfIXVYJGohdVgkbSF1WH5PVCRPT2wscU9zLU9PflAnVU9sLHFPcy1PTyNfI1NYJGojU1gkbSNTWH5QJ1VPIWUkXk8hbiReTyVTVk9+T1QkaE9+UCdVTyFUJGpPI2ska08jbSRsT35PeSRtT35PVCR8T18kfE9sLHFPcy1PTyFQJU9PflAnVU9sLHFPcy1PT3klUk9+UCdVTyVmJVRPfk9fIWJPZiFqTyFXIWxPIWUhbU9UYGFdYGFoYGFpYGFqYGFrYGFsYGFtYGFwYGF4YGF5YGEhdGBhI19gYSRqYGEkbWBhJHdgYSR4YGEkeWBhJHpgYSR7YGEkfGBhJH1gYSVPYGElUGBhJVFgYSVYYGEhUGBhIVNgYSFUYGElWWBhIVhgYSFdYGEhT2BhI1dgYXFgYSFrYGF+T2slWU9+T2wlWU9+UCdVT2wscU9+UCdVT2gsc09pLHRPaixyT2ssck9sLHpPbSx7T3AtUE8hUCVVWCFTJVVYIVQlVVglWSVVWCFYJVVYIV0lVVghTyVVWCNXJVVYIWslVVh+UChmTyVZJVtPeCVUWCFQJVRYIVMlVFghVCVUWCFYJVRYeSVUWH5PeCVfTyFQJV5PIVMlY08hVCViT35PIVAlXk9+T3glZk8hUyVjTyFUJWJPIVglYVh+TyFYJWpPfk94JWtPeSVtTyFTJWNPIVQlYk8hXSVbWH5PIV0lcU9+TyFdJXJPfk8laSNXTyVqJXRPfk8lbCNaTyVtJXRPfk9UJXdPbCxxT3MtT099dk9+UCdVTyFbI11PJW8jXk8lcyV6T35PIVsjXU8ldSNhTyV2JXpPfk8hWyNdTyVqJXpPJXgjY09+TyFbI11PJW0lek8leiNlT35PVCFtYV0hbWFfIW1hZiFtYWghbWFpIW1haiFtYWshbWFsIW1hbSFtYXAhbWF4IW1heSFtYSFXIW1hIWUhbWEhdCFtYSNfIW1hJGohbWEkbSFtYSR3IW1hJHghbWEkeSFtYSR6IW1hJHshbWEkfCFtYSR9IW1hJU8hbWElUCFtYSVRIW1hJVghbWEhUCFtYSFTIW1hIVQhbWElWSFtYSFYIW1hIV0hbWEhTyFtYSNXIW1hcSFtYSFrIW1hflAjeU94I2pPeSR1YSF0JHVhI18kdWEkaiR1YSRtJHVhJVgkdWF+UCRiT1QmUU9sdE9zdU94JFlYeSRZWCF0JFlYI18kWVgkaiRZWCRtJFlYJVgkWVh+UCdVT3gjak95JHVhIXQkdWEjXyR1YSRqJHVhJG0kdWElWCR1YX5PUGhPVGVPbHRPc3VPfXZPIU8hUE8hd3hPIXl5TyF7ek8hfXtPI1B8TyNUfU8jViFPTyNZIVFPI1ohUU8jXSFSTyNfJGFYJGokYVgkbSRhWH5QJ1VPI18jbU8kaiZWTyRtJlZPfk8hZSZXT2YlfFgkaiV8WCNXJXxYI18lfFgkbSV8WCNWJXxYfk9mIWpPJGomWU9+T2hjYWljYWpjYWtjYWxjYW1jYXBjYXhjYXljYSF0Y2EjX2NhJGpjYSRtY2ElWGNhIVBjYSFTY2EhVGNhJVljYSFYY2EhXWNhIU9jYSNXY2FxY2Eha2NhflAkYk9wbmF4bmF5bmEjX25hJGpuYSRtbmElWG5hfk9oIXBPaSFxT2ohb09rIW9PbCFyT20hc08hdG5hflBEV08lWCZbT3glV1h5JVdYfk8lU1ZPeCVXWHklV1h+T3gmX095dFh+T3kmYU9+T3gla08jXyVbWCRqJVtYJG0lW1ghUCVbWHklW1ghXSVbWCFrJVtYJVglW1h+T1QseU9sLHFPcy1PT312T35QJ1VPJVgkU08jX1NhJGpTYSRtU2F+TyVYJFNPfk94JmpPI18lXlgkaiVeWCRtJV5YayVeWH5QJGJPeCZtTyFPJmxPI18jU2EkaiNTYSRtI1Nhfk8jVyZuTyNfI1VhJGojVWEkbSNVYX5PIWUkXk8hbiReTyNWJnBPJVNWT35PI1YmcE9+T3gmck8jXyZPWCRqJk9YJG0mT1h+T3gmdE8jXyV7WCRqJXtYJG0le1h5JXtYfk94JnhPayZRWH5QJGJPayZ7T35PUGhPVGVPbHRPc3VPfXZPIU8hUE8hd3hPIXl5TyF7ek8hfXtPI1B8TyNUfU8jViFPTyNZIVFPI1ohUU8jXSFSTyRqJ1FPflAnVU9xJ1VPI2gnU08jaSdUT1AjZmFUI2ZhZCNmYWYjZmFsI2ZhcCNmYXMjZmF1I2ZhfSNmYSFPI2ZhIVMjZmEhVCNmYSFXI2ZhIVsjZmEhZyNmYSFuI2ZhIW8jZmEhcCNmYSF3I2ZhIXkjZmEheyNmYSF9I2ZhI1AjZmEjVCNmYSNWI2ZhI1kjZmEjWiNmYSNdI2ZhI2QjZmEjZyNmYSNrI2ZhI20jZmEjciNmYSN1I2ZhJGkjZmEkaiNmYSR8I2ZhJH0jZmElUiNmYSVTI2ZhJWcjZmElaCNmYSVrI2ZhJW4jZmEldCNmYSV3I2ZhJXkjZmEkbSNmYSRuI2ZhJG8jZmF+T3gnVk8jVydYT3kmUlh+T2YnWk9+T2Yhak95JG1Pfk9UIWFPXSFhT18hYk9mIWpPIVchbE8hZSFtTyR5IV5PJHohX08keyFfTyR8IWBPJH0hYE8lTyFhTyVQIWFPJVEhYU9oVWlpVWlqVWlrVWlsVWltVWlwVWl4VWl5VWkhdFVpI19VaSRqVWkkbVVpJHdVaSVYVWkhUFVpIVNVaSFUVWklWVVpIVhVaSFdVWkhT1VpI1dVaXFVaSFrVWl+TyR4IV1PflAhIFNPJHhVaX5QISBTT1QhYU9dIWFPXyFiT2Yhak8hVyFsTyFlIW1PJHwhYE8kfSFgTyVPIWFPJVAhYU8lUSFhT2hVaWlVaWpVaWtVaWxVaW1VaXBVaXhVaXlVaSF0VWkjX1VpJGpVaSRtVWkkd1VpJHhVaSR5VWklWFVpIVBVaSFTVWkhVFVpJVlVaSFYVWkhXVVpIU9VaSNXVWlxVWkha1Vpfk8keiFfTyR7IV9PflAhI31PJHpVaSR7VWl+UCEjfU9fIWJPZiFqTyFXIWxPIWUhbU9oVWlpVWlqVWlrVWlsVWltVWlwVWl4VWl5VWkhdFVpI19VaSRqVWkkbVVpJHdVaSR4VWkkeVVpJHpVaSR7VWkkfFVpJH1VaSVYVWkhUFVpIVNVaSFUVWklWVVpIVhVaSFdVWkhT1VpI1dVaXFVaSFrVWl+T1QhYU9dIWFPJU8hYU8lUCFhTyVRIWFPflAhJntPVFVpXVVpJU9VaSVQVWklUVVpflAhJntPZiFqTyFXIWxPIWUhbU9UVWldVWlfVWloVWlpVWlqVWlrVWlsVWltVWlwVWl4VWl5VWkhdFVpI19VaSRqVWkkbVVpJHdVaSR4VWkkeVVpJHpVaSR7VWkkfFVpJH1VaSVPVWklUFVpJVFVaSVYVWkhUFVpIVNVaSFUVWklWVVpIVhVaSFdVWkhT1VpI1dVaXFVaSFrVWl+TyFTJWNPIVQlYk94JWRYIVAlZFh+TyVYJ2BPJVknYE9+UCt7T3gnYk8hUCVjWH5PIVAnZE9+T3gnZU95J2dPIVglZVh+T2wscU9zLU9PeCdlT3knaE8hWCVlWH5QJ1VPIVgnak9+T2ohb09rIW9PbCFyT20hc09oZ2lwZ2l4Z2l5Z2khdGdpI19naSRqZ2kkbWdpJVhnaX5PaSFxT35QIS5eT2lnaX5QIS5eT2gsc09pLHRPaixyT2ssck9sLHpPbSx7T35PcSdsT35QIS9nT1QncU9sLHFPcy1PTyFQJ3JPflAnVU94J3NPIVAnck9+TyFQJ3VPfk8hVCd3T35PeCdzTyFQJ3hPIVMlY08hVCViT35QJGJPaCxzT2ksdE9qLHJPayxyT2wsek9tLHtPIVBuYSFTbmEhVG5hJVluYSFYbmEhXW5hIU9uYSNXbmFxbmEha25hflBEV09UJ3xPbCxxT3MtT094I3tYIVgje1h+UCdVT3glZk8hWCVhYX5PIVgoT09+T3glZk8hUyVjTyFUJWJPIVglYWF+UCRiT1QoU09sLHFPcy1PT3gjeFghXSN4WCNfI3hYJGojeFgkbSN4WCFQI3hYeSN4WCFrI3hYJVgjeFh+UCdVT3gla08hXSVbYSNfJVthJGolW2EkbSVbYSFQJVtheSVbYSFrJVthJVglW2F+TyFdKFZPfk94JWtPIVMlY08hVCViTyFdJVthflAkYk94KFlPIVMlY08hVCViTyFdJWJhflAkYk94KF1PeSVwWCFdJXBYIWslcFh+T3koYE8hXShiTyFrKGNPfk94I2pPeSR1aSF0JHVpI18kdWkkaiR1aSRtJHVpJVgkdWl+TyFlJldPZiV8YSRqJXxhI1clfGEjXyV8YSRtJXxhI1YlfGF+TyRqKGdPfk9UI3lPXyN6T3UjeE8lU1ZPfk94Jl9PeXRhfk9sdE9zdU9+UCdVT3gla08jXyVbYSRqJVthJG0lW2EhUCVbYXklW2EhXSVbYSFrJVthJVglW2F+UCRiT3gobE8jXyR1WCRqJHVYJG0kdVglWCR1WH5PJVgkU08jX1NpJGpTaSRtU2l+T3gjelgjXyN6WCRqI3pYJG0jelhrI3pYflAnVU94JmpPI18lXmEkaiVeYSRtJV5hayVeYX5PVChyT2YodE8lU1ZPfk8jVih1T35PJVNWT3gkYFgjXyRgWCRqJGBYJG0kYFh+T3gmck8jXyZPYSRqJk9hJG0mT2F+T2wscU9zLU9PeCRbWCNfJFtYJGokW1gkbSRbWHkkW1h+UCdVT3gmdE8jXyV7YSRqJXthJG0le2F5JXthfk9xKHxPI2Ioe09QI2BpVCNgaWQjYGlmI2BpbCNgaXAjYGlzI2BpdSNgaX0jYGkhTyNgaSFTI2BpIVQjYGkhVyNgaSFbI2BpIWcjYGkhbiNgaSFvI2BpIXAjYGkhdyNgaSF5I2BpIXsjYGkhfSNgaSNQI2BpI1QjYGkjViNgaSNZI2BpI1ojYGkjXSNgaSNkI2BpI2cjYGkjayNgaSNtI2BpI3IjYGkjdSNgaSRpI2BpJGojYGkkfCNgaSR9I2BpJVIjYGklUyNgaSVnI2BpJWgjYGklayNgaSVuI2BpJXQjYGkldyNgaSV5I2BpJG0jYGkkbiNgaSRvI2Bpfk9xKH1PUCNjaVQjY2lkI2NpZiNjaWwjY2lwI2NpcyNjaXUjY2l9I2NpIU8jY2khUyNjaSFUI2NpIVcjY2khWyNjaSFnI2NpIW4jY2khbyNjaSFwI2NpIXcjY2kheSNjaSF7I2NpIX0jY2kjUCNjaSNUI2NpI1YjY2kjWSNjaSNaI2NpI10jY2kjZCNjaSNnI2NpI2sjY2kjbSNjaSNyI2NpI3UjY2kkaSNjaSRqI2NpJHwjY2kkfSNjaSVSI2NpJVMjY2klZyNjaSVoI2NpJWsjY2klbiNjaSV0I2NpJXcjY2kleSNjaSRtI2NpJG4jY2kkbyNjaX5PVClQT2skZFh4JGRYflAnVU94JnhPayZRYX5PeCZ4T2smUWF+UCRiT2spVE9+T1BoT1RlT2x0T3AhU09zdU99dk8hTyFQTyFTIVZPIVQhVU8hd3hPIXl5TyF7ek8hfXtPI1B8TyNUfU8jViFPTyNZIVFPI1ohUU8jXSFSTyNkIVRPI2chV08jayFYTyNtIVlPI3IhWk8jdWxPflAnVU9xKVpPI2gnU08jaSlZT1AjZmlUI2ZpZCNmaWYjZmlsI2ZpcCNmaXMjZml1I2ZpfSNmaSFPI2ZpIVMjZmkhVCNmaSFXI2ZpIVsjZmkhZyNmaSFuI2ZpIW8jZmkhcCNmaSF3I2ZpIXkjZmkheyNmaSF9I2ZpI1AjZmkjVCNmaSNWI2ZpI1kjZmkjWiNmaSNdI2ZpI2QjZmkjZyNmaSNrI2ZpI20jZmkjciNmaSN1I2ZpJGkjZmkkaiNmaSR8I2ZpJH0jZmklUiNmaSVTI2ZpJWcjZmklaCNmaSVrI2ZpJW4jZmkldCNmaSV3I2ZpJXkjZmkkbSNmaSRuI2ZpJG8jZml+T2wscU9zLU9PeSRtT35QJ1VPbCxxT3MtT094JGZYeSRmWH5QJ1VPeCdWT3kmUmF+T1QpZE9fKWVPdSljTyVPKWZPJVNWT35PIVApaE9+UCFJb095JG1PJlUpak9+T1QkfE9fJHxPbCxxT3MtT094I31YIVAjfVh+UCdVT3gnYk8hUCVjYX5PbCxxT3MtT095KXJPeCRPWCFYJE9YflAnVU94J2VPIVglZWF+T2wscU9zLU9PeCdlT3kpdU8hWCVlYX5QJ1VPbCxxT3MtT094J2VPIVglZWF+UCdVT3gnZU95KXVPIVglZWF+T2osck9rLHJPbCx6T20se09oZ2lwZ2l4Z2khUGdpIVNnaSFUZ2klWWdpIVhnaXlnaSFdZ2kjX2dpJGpnaSRtZ2khT2dpI1dnaXFnaSFrZ2klWGdpfk9pLHRPflAhTGxPaWdpflAhTGxPVCdxT2wscU9zLU9PIVApek9+UCdVT2spfE9+T3gqT08hUCl6T35PIVAqUE9+T3glZk8hWCVhaX5PIVgqUk9+T3goWU8hUyVjTyFUJWJPIV0lYml+T3gla08hXSVbaSNfJVtpJGolW2kkbSVbaSFQJVtpeSVbaSFrJVtpJVglW2l+TyFdKlZPfk9fKlhPbCxxT3MtT094I3xYIV0jfFh+UCdVT3goWU8hXSViaX5PIV0qWk9+T1QqXU9sLHFPcy1PT3gkU1h5JFNYIV0kU1ghayRTWH5QJ1VPeChdT3klcGEhXSVwYSFrJXBhfk8hWyNdTyVyKmBPIV0hbFh+TyFdKmJPfk95KGBPIV0qY09+T3gkWWl5JFlpIXQkWWkjXyRZaSRqJFlpJG0kWWklWCRZaX5QJGJPVCZRT2wscU9zLU9PeCRZWCNfJFlYJGokWVgkbSRZWCVYJFlYflAnVU94KGxPI18kdWEkaiR1YSRtJHVhJVgkdWF+T3gjemEjXyN6YSRqI3phJG0jemFrI3phflAkYk94KmVPI18jU3EkaiNTcSRtI1Nxfk94KmZPI1cqaE8jXyV9WCRqJX1YJG0lfVghUCV9WH5PVCpqT2Yqa08lU1ZPfk9xKm1PI2Ioe09QI2BxVCNgcWQjYHFmI2BxbCNgcXAjYHFzI2BxdSNgcX0jYHEhTyNgcSFTI2BxIVQjYHEhVyNgcSFbI2BxIWcjYHEhbiNgcSFvI2BxIXAjYHEhdyNgcSF5I2BxIXsjYHEhfSNgcSNQI2BxI1QjYHEjViNgcSNZI2BxI1ojYHEjXSNgcSNkI2BxI2cjYHEjayNgcSNtI2BxI3IjYHEjdSNgcSRpI2BxJGojYHEkfCNgcSR9I2BxJVIjYHElUyNgcSVnI2BxJWgjYHElayNgcSVuI2BxJXQjYHEldyNgcSV5I2BxJG0jYHEkbiNgcSRvI2Bxfk9rJGRheCRkYX5QJGJPeCZ4T2smUWl+TyRtKnlPJG4qd08kbyp5T35PeCp9T3kkbU8jVyp9T35PI2krT09QI2ZxVCNmcWQjZnFmI2ZxbCNmcXAjZnFzI2ZxdSNmcX0jZnEhTyNmcSFTI2ZxIVQjZnEhVyNmcSFbI2ZxIWcjZnEhbiNmcSFvI2ZxIXAjZnEhdyNmcSF5I2ZxIXsjZnEhfSNmcSNQI2ZxI1QjZnEjViNmcSNZI2ZxI1ojZnEjXSNmcSNkI2ZxI2cjZnEjayNmcSNtI2ZxI3IjZnEjdSNmcSRpI2ZxJGojZnEkfCNmcSR9I2ZxJVIjZnElUyNmcSVnI2ZxJWgjZnElayNmcSVuI2ZxJXQjZnEldyNmcSV5I2ZxJG0jZnEkbiNmcSRvI2Zxfk8jVytQT3gkZmF5JGZhfk94J1ZPeSZSaX5PeSRSTyVYK1JPeCZUWCFQJlRYfk8lU1ZPeCZUWCFQJlRYfk94K1ZPIVAmU1h+TyFQK1hPfk95K1pPeCRPYSFYJE9hfk9sLHFPcy1PT3krW094JE9hIVgkT2F+UCdVT3gnZU8hWCVlaX5PbCxxT3MtT094J2VPIVglZWl+UCdVT3gnZU95K2BPIVglZWl+T3gjeWkhUCN5aX5QJGJPVCdxT2wscU9zLU9PflAnVU9rK2JPfk9UJ3FPbCxxT3MtT08hUCtjT35QJ1VPeCN7aSFYI3tpflAkYk94I3hpIV0jeGkjXyN4aSRqI3hpJG0jeGkhUCN4aXkjeGkhayN4aSVYI3hpflAkYk94KFlPIV0lYnF+TyFdK2RPfk95K2VPfk94KF1PeSVwaSFdJXBpIWslcGl+TyFbI11PJXIqYE8hXSFsYX5PeChsTyNfJHVpJGokdWkkbSR1aSVYJHVpfk8lU1ZPeCRfWCNfJF9YJGokX1gkbSRfWCFQJF9Yfk94KmZPI18lfWEkaiV9YSRtJX1hIVAlfWF+TyFQK21Pfk9rJGRpeCRkaX5QJGJPcStxT1AjZXlUI2V5ZCNleWYjZXlsI2V5cCNleXMjZXl1I2V5fSNleSFPI2V5IVMjZXkhVCNleSFXI2V5IVsjZXkhZyNleSFuI2V5IW8jZXkhcCNleSF3I2V5IXkjZXkheyNleSF9I2V5I1AjZXkjVCNleSNWI2V5I1kjZXkjWiNleSNdI2V5I2QjZXkjZyNleSNrI2V5I20jZXkjciNleSN1I2V5JGkjZXkkaiNleSR8I2V5JH0jZXklUiNleSVTI2V5JWcjZXklaCNleSVrI2V5JW4jZXkldCNleSV3I2V5JXkjZXkkbSNleSRuI2V5JG8jZXl+TyRtK3ZPJG4qd08kbyt2T35PI2krd09QI2Z5VCNmeWQjZnlmI2Z5bCNmeXAjZnlzI2Z5dSNmeX0jZnkhTyNmeSFTI2Z5IVQjZnkhVyNmeSFbI2Z5IWcjZnkhbiNmeSFvI2Z5IXAjZnkhdyNmeSF5I2Z5IXsjZnkhfSNmeSNQI2Z5I1QjZnkjViNmeSNZI2Z5I1ojZnkjXSNmeSNkI2Z5I2cjZnkjayNmeSNtI2Z5I3IjZnkjdSNmeSRpI2Z5JGojZnkkfCNmeSR9I2Z5JVIjZnklUyNmeSVnI2Z5JWgjZnklayNmeSVuI2Z5JXQjZnkldyNmeSV5I2Z5JG0jZnkkbiNmeSRvI2Z5fk94J1ZPeSZScX5PJVgrUk94JlRhIVAmVGF+T3gkZ1ghUCRnWH5QIUlvT3grVk8hUCZTYX5PbCxxT3MtT095LFBPeCRPaSFYJE9pflAnVU9sLHFPcy1PT3gkT2khWCRPaX5QJ1VPeSxQT3gkT2khWCRPaX5PeCdlTyFYJWVxfk9sLHFPcy1PT3gnZU8hWCVlcX5QJ1VPcCxVTyFTJWNPIVQlYk8hUCVdcSFYJV1xIV0lXXF4JV1xflAhL2dPeCN8aSFdI3xpflAkYk8jVyxZT3gkX2EjXyRfYSRqJF9hJG0kX2EhUCRfYX5PeCpmTyNfJX1pJGolfWkkbSV9aSFQJX1pfk8hUCxbT35PcSxeT1AjZSFSVCNlIVJkI2UhUmYjZSFSbCNlIVJwI2UhUnMjZSFSdSNlIVJ9I2UhUiFPI2UhUiFTI2UhUiFUI2UhUiFXI2UhUiFbI2UhUiFnI2UhUiFuI2UhUiFvI2UhUiFwI2UhUiF3I2UhUiF5I2UhUiF7I2UhUiF9I2UhUiNQI2UhUiNUI2UhUiNWI2UhUiNZI2UhUiNaI2UhUiNdI2UhUiNkI2UhUiNnI2UhUiNrI2UhUiNtI2UhUiNyI2UhUiN1I2UhUiRpI2UhUiRqI2UhUiR8I2UhUiR9I2UhUiVSI2UhUiVTI2UhUiVnI2UhUiVoI2UhUiVrI2UhUiVuI2UhUiV0I2UhUiV3I2UhUiV5I2UhUiRtI2UhUiRuI2UhUiRvI2UhUn5PbCxxT3MtT094JE9xIVgkT3F+UCdVT3ksY094JE9xIVgkT3F+T3gnZU8hWCVleX5PbCxxT3MsZ09+UCdVT3AsVU8hUyVjTyFUJWJPIVAlXXkhWCVdeSFdJV15eCVdeX5QIS9nT3gqZk8jXyV9cSRqJX1xJG0lfXEhUCV9cX5PbCxxT3MtT094JE95IVgkT3l+UCdVT3gnZU8hWCVlIVJ+T3AlYFghUCVgWCFTJWBYIVQlYFghWCVgWCFdJWBYeCVgWH5QIS9nT3AsVU8hUyVjTyFUJWJPIVAlX2EhWCVfYSFdJV9heCVfYX5PeSxvT35PeChsTyNfJHVhJGokdWEkbSR1YSVYJHVhflAkYk9rLHZPfk9sLHZPflAnVU95LHdPfk9xLHhPflAhL2dPJWglayV3JXklZyVuJXQlUyVnflwiLFxuICBnb3RvOiBcIiEmaCZVUFBQUCZWUCZfKHwpZCl7KmUrTytqUCxWUCZfLHQsdCZfUCZfUC9jUFBQUFBQL2MxYlBQMWJQMn1QM1c3YFBQN2M3bzdyUFBQJl8mX1BQOE8mX1BQJl8mX1BQJl8mXyZfJl84Uzh4Jl9QOHtQOU85TztxUDxWJl9QUFA8WjxhJlZQJlYmVlAmVlAmVlAmVlAmVlAmViZWJlZQJlZQUCZWUFAmVlA8Z1A8bjx0UDxuUDxuPG5QUFA8blA+bVA+dj58P1M+bVA8bj9ZUD9hP2c/bT95QFRAWkBlQG9AdUFjQWlBb0F1QlBCVkJdQmNCaUJvQ1JDXUNjQ2lDb0N5RFBEVkRdRGNEbURzRH1FVFBQUFBQUFBQUEVeRWhFcUV7RldQUFBQUFBQUFBQUFBJfUpnTlUhIXFQUCEheSEjWCEjYiEkVyEjfSEkYSEkZyEkaiEkbSEkcCEkdlBQUFBQUFBQUFAhJHkhJHxQUFBQUFBQUFAhJVMhJWAhJWwhJXghJXshJlIhJlghJl8hJmJdaU9yI20kbSdRKncmWGRPU1hZWmVocnN0dnh8fSFSIVMhVCFVIVghYyFkIWUhZiFnIWghaSFqIWwhbyFwIXEhcyF0IXohfSNSI1MjXSNqI20kTyRQJFIkVCRXJGgkaiRrJG0kfCVSJVklXSVfJWIlZiVrJW0ldyZRJl0mYSZqJmwmbSZ0JngmeydRJ1MnVidhJ2InZSdnJ2gnbCdxJ3Mndyd8KFMoWShdKGwoeylQKVQpailyKXUpeyl8Kk8qWCpdKmUqdytTK1orWytgK2IrZSt8LFAsVSxjLG8scSxyLHMsdCx2LHcseCx5LHstUHkhY1AjaSN2JFgkZyVkJWklbyVwJmImeihkKG4pTyl5KlEqUypyK2YsdXshZFAjaSN2JFgkZyRzJWQlaSVvJXAmYiZ6KGQobilPKXkqUSpTKnIrZix1fSFlUCNpI3YkWCRnJHMkdCVkJWklbyVwJmImeihkKG4pTyl5KlEqUypyK2YsdSFQIWZQI2kjdiRYJGckcyR0JHUlZCVpJW8lcCZiJnooZChuKU8peSpRKlMqcitmLHUhUiFnUCNpI3YkWCRnJHMkdCR1JHYlZCVpJW8lcCZiJnooZChuKU8peSpRKlMqcitmLHUhVCFoUCNpI3YkWCRnJHMkdCR1JHYkdyVkJWklbyVwJmImeihkKG4pTyl5KlEqUypyK2YsdSFYIWlQIW4jaSN2JFgkZyRzJHQkdSR2JHckeCVkJWklbyVwJmImeihkKG4pTyl5KlEqUypyK2YsdSZYU09TWFlaZWhyc3R2eHx9IVIhUyFUIVUhWCFjIWQhZSFmIWchaCFpIWohbCFvIXAhcSFzIXQheiF9I1IjUyNdI2ojbSRPJFAkUiRUJFckaCRqJGskbSR8JVIlWSVdJV8lYiVmJWslbSV3JlEmXSZhJmombCZtJnQmeCZ7J1EnUydWJ2EnYidlJ2cnaCdsJ3Encyd3J3woUyhZKF0obCh7KVApVClqKXIpdSl7KXwqTypYKl0qZSp3K1MrWitbK2ArYitlK3wsUCxVLGMsbyxxLHIscyx0LHYsdyx4LHksey1QJHlVT1hZWmhydHZ8fSFSIVMhVCFYIWohbCFvIXAhcSFzIXQjXSNqI20kUCRSJFQkVyRrJG0kfCVSJVklXSVfJWYlayVtJXcmXSZhJmwmbSZ0JnsnUSdTJ1YnYSdiJ2UnZydoJ2wncyhZKF0obCh7KVQpailyKXUpeyl8Kk8qXSplKncrUytaK1srYCtiK2UrfCxQLFUsYyxvLHEscixzLHQsdix3LHgsey1QJFRXT1hZWmhydnx9IVIhUyFUIVghaiFsI10jaiNtJFAkUiRUJFckayRtJHwlUiVdJV8lZiVrJW0ldyZdJmEmbCZtJnQmeydRJ1MnVidhJ2InZSdnJ2gnbCdzKFkoXShsKHspVClqKXIpdSl7Kk8qXSplKncrUytaK1srYCtlK3wsUCxjLHcseFEjfHVRLG0sZ1IsfC1PJlNkT1NYWVplaHJzdHZ4fH0hUiFTIVQhVSFYIWMhZCFlIWYhZyFoIWkhbCFvIXAhcSFzIXQheiF9I1IjUyNdI2ojbSRPJFAkUiRUJFckaCRqJGskbSR8JVIlWSVdJV8lYiVmJWslbSV3JlEmXSZhJmombCZtJnQmeCZ7J1EnUydWJ2EnZSdnJ2gnbCdxJ3Mndyd8KFMoWShdKGwoeylQKVQpailyKXUpeyl8Kk8qWCpdKmUqdytTK1orWytgK2IrZSt8LFAsVSxjLG8scSxyLHMsdCx2LHcseCx5LHstUFcjcGwhTyFQJF9XI3h1Jl8sZy1PUSRhIVFRJHEhWVEkciFaUyR7IWonYlMmXiN5I3pRJ08kbFEoZSZXUShyJm5XKHMmcCh0KHUqa1EodiZyUSliJ1hTKWMnWitWUytVKWQpZVEraipmUStsKmhRK3gqfVEreitQUixqLFlSJl0jeGUhd1hZIVMhVCVfJWYncyh7KXsqT1IlXSF2USF7WFEleCNdUSZmJFRSJmkkV1QsZixVLG8hWSFrUCFuI2kjdiRYJGckcyR0JHUkdiR3JHgkeSVkJWklbyVwJmImeihkKG4pTyl5KlEqUypyK2YsdVEmWiNxUideJHJSJ2Eke1IlVSFtJldjT1NYWVplaHJzdHZ4fH0hUiFTIVQhVSFYIWMhZCFlIWYhZyFoIWkhaiFsIW8hcCFxIXMhdCF6IX0jUiNTI10jaiNtJE8kUCRSJFQkVyRoJGokayRtJHwlUiVZJV0lXyViJWYlayVtJXcmUSZdJmEmaiZsJm0mdCZ4JnsnUSdTJ1YnYSdiJ2UnZydoJ2wncSdzJ3cnfChTKFkoXShsKHspUClUKWopcil1KXspfCpPKlgqXSplKncrUytaK1srYCtiK2UrfCxQLFUsYyxvLHEscixzLHQsdix3LHgseSx7LVBUI2djI2hTI15fI19TI2FgI2JTI2NhI2RTI2ViI2ZUKmAoYCphVChhJXgoY1EkVndSK1QpY1gkVHckVSRWJmhaa09yJG0nUSp3WG9PcidRKndRJG4hV1EmdiRlUSZ3JGZRJ1kkcFEnXSRyUSlVJn1RKVsnU1EpXidUUSlfJ1VRKWsnW1EpbSdeUSpuKHtRKnAofFEqcSh9USpzKVNTKnUpVilsUSp6KVlRKnspWlEqfCldUStvKm1RK3Aqb1Ercip0UStzKnZRK3krT1EsXStxUSxfK3dRLGAreFIsayxeV29PcidRKndSI3NuUSdbJHFSKVYnT1ErUyljUit8K1RRKWwnW1IqdilWWm1PbnInUSp3UXJPUiN1clEmYCN7UihqJmBTJWwjUSN9UyhUJWwoV1QoVyVvJmJRJWAheVMndCVgJ3lSJ3klZFEmayRYUihvJmtRJWchfFMnfSVnKFBSKFAlaVEoWiVwUSpUKFVUKlkoWipUUSdjJH1SKXAnY1MnZiVRJVJZKXMnZil0K14sUyxkVSl0J2cnaCdpVSteKXUpdil3UyxTK18rYFIsZCxUUSNYXVIlcyNYUSNbXlIldSNbUSNfX1IleSNfUSheJXZTKl4oXipfUipfKF9RKmEoYFIraCphUSNiYFIleyNiUSNkYVIlfCNkUSNmYlIlfSNmUSNoY1ImTyNoUSNrZlEmUCNpVyZTI2smUChtKmRRKG0mZVIqZCx1USRVd1MmZyRVJmhSJmgkVlEmdSRjUih5JnVRJlgjcFIoZiZYUSRfIVBSJm8kX1EqZyhzUytrKmcsWlIsWitsUSZzJGFSKHcmc1EjbmpSJlUjblEqeClXUit1KnhRKHomdlIqbCh6USZ5JGdTKVEmeSlSUilSJnpRJ1IkblIpWCdSUSdXJG9TKWEnVytRUitRKWJRK1cpZ1IsTytXV25PcidRKndSI3JuU3FPclEpVydRUit0KndXcE9yJ1Eqd1InUCRtWWpPciRtJ1Eqd1ImVCNtW3dPciNtJG0nUSp3UiZmJFQkeFBPWFlaaHJ0dnx9IVIhUyFUIVghaiFsIW8hcCFxIXMhdCNdI2ojbSRQJFIkVCRXJGskbSR8JVIlWSVdJV8lZiVrJW0ldyZdJmEmbCZtJnQmeydRJ1MnVidhJ2InZSdnJ2gnbCdzKFkoXShsKHspVClqKXIpdSl7KXwqTypdKmUqdytTK1orWytgK2IrZSt8LFAsVSxjLG8scSxyLHMsdCx2LHcseCx7LVBRIW5TUSNpZVEjdnNVJFh4JWInd1MkZyFVJGpRJHMhY1EkdCFkUSR1IWVRJHYhZlEkdyFnUSR4IWhRJHkhaVElZCF6USVpIX1RJW8jUlElcCNTUSZiJE9RJnokaFEoZCZRUShuJmpRKU8meFEpeSdxUSpRJ3xRKlMoU1EqcilQUStmKlhSLHUseVEheVhRIXxZUSRlIVNRJGYhVFcncCVfJ3MpeypPUSd7JWZSKm8oe1tmT3IjbSRtJ1Eqd2QhdlhZIVMhVCVfJWYncyh7KXsqT1EjUVpRI2xoUyN9dnxRJFt9VyRjIVIkVyZ7KVRTJG8hWCRrUyR6IWonYlElUSFsUSV2I11TJlIjaihsUSZjJFBRJmQkUlEmZSRUUSdfJHxRJ2klUlEnbyVdUShSJWtRKFUlbVEoXyV3UShoJl1TKGsmYSx3UShwJmxRKHEmbVEoeCZ0USldJ1NRKWAnVlEpbidhUSlxJ2VRKXYnZ1EpdydoUyl4J2wseFEqVyhZUSpbKF1RK1kpalErXSlyUStfKXVRK2cqXVEraSplUSt7K1NRLFErWlEsUitbUSxUK2BRLFgrZVEsYSt8USxiLFBSLGwsY2JUT3IjaiNtJG0mYSdRJ2wqdyNwIXVYWVpodnx9IVIhUyFUIVghaiFsI10kUCRSJFQkVyRrJHwlUiVdJV8lZiVrJW0ldyZdJmwmbSZ0JnsnUydWJ2EnYidlJ2cnaCdzKFkoXShsKHspVClqKXIpdSl7Kk8qXSplK1MrWitbK2ArZSt8LFAsYyx3LHhRI3d0VyVWIW8hcyxyLHtRJVchcFElWCFxUSVaIXRRJWUscVMnayVZLHZRJ20sc1Enbix0USthKXxRLFcrYlMsZSxVLG9SLH0tUFUje3UsZy1PUihpJl9bZ09yI20kbSdRKndYIXhYI10kVCRXUSNWWlEkUXZSJFp8USVhIXlRJWghfFElbiNRUSdfJHpRJ3olZFEoUSVpUShYJW9RKFslcFEqVShVUSxWK2FRLGksV1IsbixoUSRZeFEndiViUil9J3dRLGgsVVIscCxvUiNQWVIjVVpSJVAhalEkfSFqUilvJ2JSJVMhbFIleCNdUShiJXhSKmMoY1EkZCFSUSZpJFdRKVMme1IqdClUUSNxbFEkXSFPUSRgIVBSJnEkX1EociZwUSppKHRRKmoodVIrbiprUiRiIVFYcE9yJ1Eqd1EkaSFVUiZ8JGpRJHAhWFImfSRrUilpJ1pRKWcnWlIrfStWXCIsXG4gIG5vZGVOYW1lczogXCLimqAgcHJpbnQgQ29tbWVudCBTY3JpcHQgQXNzaWduU3RhdGVtZW50ICogQmluYXJ5RXhwcmVzc2lvbiBCaXRPcCBCaXRPcCBCaXRPcCBCaXRPcCBBcml0aE9wIEFyaXRoT3AgQCBBcml0aE9wICoqIFVuYXJ5RXhwcmVzc2lvbiBBcml0aE9wIEJpdE9wIEF3YWl0RXhwcmVzc2lvbiBhd2FpdCBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiAoIEJpbmFyeUV4cHJlc3Npb24gb3IgYW5kIENvbXBhcmVPcCBpbiBub3QgaXMgVW5hcnlFeHByZXNzaW9uIENvbmRpdGlvbmFsRXhwcmVzc2lvbiBpZiBlbHNlIExhbWJkYUV4cHJlc3Npb24gbGFtYmRhIFBhcmFtTGlzdCBzZWxmIFZhcmlhYmxlTmFtZSBBc3NpZ25PcCAsIDogTmFtZWRFeHByZXNzaW9uIEFzc2lnbk9wIFlpZWxkRXhwcmVzc2lvbiB5aWVsZCBmcm9tICkgVHVwbGVFeHByZXNzaW9uIENvbXByZWhlbnNpb25FeHByZXNzaW9uIGFzeW5jIGZvciBMYW1iZGFFeHByZXNzaW9uIEFycmF5RXhwcmVzc2lvbiBbIF0gQXJyYXlDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiBEaWN0aW9uYXJ5RXhwcmVzc2lvbiB7IH0gRGljdGlvbmFyeUNvbXByZWhlbnNpb25FeHByZXNzaW9uIFNldEV4cHJlc3Npb24gU2V0Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24gQ2FsbEV4cHJlc3Npb24gQXJnTGlzdCBBc3NpZ25PcCBNZW1iZXJFeHByZXNzaW9uIC4gUHJvcGVydHlOYW1lIE51bWJlciBTdHJpbmcgRm9ybWF0U3RyaW5nIEZvcm1hdFJlcGxhY2VtZW50IEZvcm1hdENvbnZlcnNpb24gRm9ybWF0U3BlYyBDb250aW51ZWRTdHJpbmcgRWxsaXBzaXMgTm9uZSBCb29sZWFuIFR5cGVEZWYgQXNzaWduT3AgVXBkYXRlU3RhdGVtZW50IFVwZGF0ZU9wIEV4cHJlc3Npb25TdGF0ZW1lbnQgRGVsZXRlU3RhdGVtZW50IGRlbCBQYXNzU3RhdGVtZW50IHBhc3MgQnJlYWtTdGF0ZW1lbnQgYnJlYWsgQ29udGludWVTdGF0ZW1lbnQgY29udGludWUgUmV0dXJuU3RhdGVtZW50IHJldHVybiBZaWVsZFN0YXRlbWVudCBQcmludFN0YXRlbWVudCBSYWlzZVN0YXRlbWVudCByYWlzZSBJbXBvcnRTdGF0ZW1lbnQgaW1wb3J0IGFzIFNjb3BlU3RhdGVtZW50IGdsb2JhbCBub25sb2NhbCBBc3NlcnRTdGF0ZW1lbnQgYXNzZXJ0IFN0YXRlbWVudEdyb3VwIDsgSWZTdGF0ZW1lbnQgQm9keSBlbGlmIFdoaWxlU3RhdGVtZW50IHdoaWxlIEZvclN0YXRlbWVudCBUcnlTdGF0ZW1lbnQgdHJ5IGV4Y2VwdCBmaW5hbGx5IFdpdGhTdGF0ZW1lbnQgd2l0aCBGdW5jdGlvbkRlZmluaXRpb24gZGVmIFBhcmFtTGlzdCBBc3NpZ25PcCBUeXBlRGVmIENsYXNzRGVmaW5pdGlvbiBjbGFzcyBEZWNvcmF0ZWRTdGF0ZW1lbnQgRGVjb3JhdG9yIEF0XCIsXG4gIG1heFRlcm06IDIzNixcbiAgbm9kZVByb3BzOiBbXG4gICAgW05vZGVQcm9wLmdyb3VwLCAtMTQsNCw4MSw4Myw4NCw4Niw4OCw5MCw5Miw5NCw5NSw5Niw5OCwxMDEsMTA0LFwiU3RhdGVtZW50IFN0YXRlbWVudFwiLC0yMyw2LDE2LDE5LDIxLDM3LDM4LDQ4LDQ5LDUzLDU2LDU3LDYwLDYxLDYyLDYzLDY2LDY5LDcwLDcxLDc1LDc2LDc3LDc4LFwiRXhwcmVzc2lvblwiLC05LDEwNiwxMDgsMTExLDExMywxMTQsMTE4LDEyMCwxMjUsMTI3LFwiU3RhdGVtZW50XCJdXG4gIF0sXG4gIHNraXBwZWROb2RlczogWzAsMl0sXG4gIHJlcGVhdE5vZGVDb3VudDogMzMsXG4gIHRva2VuRGF0YTogXCIhRX1NZ1IhXk9YJH1YWSV3WVskfVtdJXddcCR9cHEld3FyKGNycypVc3QyT3R1JH11djRRdnc1VXd4NXh4eUFXeXpBdHp7QmJ7fENyfH1EZn0hT0VTIU8hUEZaIVAhUUthIVEhUkxxIVIhWyEoUCFbIV0hKWkhXSFeISptIV4hXyErWiFfIWAhLGshYCFhIS1fIWEhYiR9IWIhYyEubCFjIWQhL2IhZCFlITFmIWUhaCEvYiFoIWkhOE8haSF0IS9iIXQhdSE9YiF1IXchL2IhdyF4IT9gIXghfSEvYiF9I08hQHQjTyNQIUFiI1AjUSFCYyNRI1IhQ1AjUiNTIS9iI1MjVCR9I1QjVSEvYiNVI1YhMWYjViNZIS9iI1kjWiE4TyNaI2YhL2IjZiNnIT1iI2cjaSEvYiNpI2ohP2AjaiNvIS9iI28jcCFDcyNwI3EhRFsjcSNyIUVPI3IjcyFFYSNzJGckfSRnfiEvYjxyJWBSJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyNvJWkjcCNxJWkjcn4laTdbJW5SJXI3W08jbyVpI3AjcSVpI3J+JWlNZyZbWiVvYCV1cCVyN1sleCFiJXojdCVpUyVsVyRxMXNPWCVpWFkmfVlbJWlbXSZ9XXAlaXBxJn1xI08laSNPI1AndyNQI28laSNwI3ElaSNyfiVpSFAnVVolcjdbJHExc09YJWlYWSZ9WVslaVtdJn1dcCVpcHEmfXEjTyVpI08jUCd3I1AjbyVpI3AjcSVpI3J+JWlIUCd8ViVyN1tPWSVpWVomfVpdJWldXiZ9XiNvJWkjcCNxJWkjcn4laTx1KHRZJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFfJWkhXyFgKWQhYCNUJWkjVCNVKXQjVSNmJWkjZiNnKXQjZyNoKXQjaCNvJWkjcCNxJWkjcn4laTdfKWtSalIlcjdbTyNvJWkjcCNxJWkjcn4laTdfKXtSIWtSJXI3W08jbyVpI3AjcSVpI3J+JWlHeyplXSV2cCVvYCVyN1sleCFiJWlTJWcsWE9ZK15ZWi57Wl0rXl1eLntecitecnMvXXMjTyteI08jUDB8I1AjbyteI28jcDFiI3AjcSteI3EjcjFiI3J+K15CbStnXSVyN1slbFclZyxYT1ksYFlaJWlaXSxgXV4laV5yLGBycy1gcyNPLGAjTyNQLXAjUCNvLGAjbyNwLlUjcCNxLGAjcSNyLlUjcn4sYEJlLGddJXI3WyVnLFhPWSxgWVolaVpdLGBdXiVpXnIsYHJzLWBzI08sYCNPI1AtcCNQI28sYCNvI3AuVSNwI3EsYCNxI3IuVSNyfixgQmUtZ1IlcjdbJWcsWE8jbyVpI3AjcSVpI3J+JWlCZS11VCVyN1tPI28sYCNvI3AuVSNwI3EsYCNxI3IuVSNyfixgLFguWlYlZyxYT1kuVVpdLlVeci5VcnMucHMjTy5VI08jUC51I1B+LlUsWC51TyVnLFgsWC54UE9+LlU3ZC9TUiVyN1slbFdPI28laSNwI3ElaSNyfiVpRWMvZFglcjdbJWcsWE9yLntyczBQcyNPLnsjTyNQMGMjUCNvLnsjbyNwMHcjcCNxLnsjcSNyMHcjcn4ue0VjMFlSJW0jfCVyN1slayxYTyNvJWkjcCNxJWkjcn4laTdkMGhUJXI3W08jby57I28jcDB3I3AjcS57I3EjcjB3I3J+LntXMHxPJWxXQm0xUlQlcjdbTyNvK14jbyNwMWIjcCNxK14jcSNyMWIjcn4rXixhMWlWJWxXJWcsWE9ZLlVaXS5VXnIuVXJzLnBzI08uVSNPI1AudSNQfi5VTWcyY1hRMXMlb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPWTNPWVolaVpdM09dXiVpXiNvM08jbyNwM3IjcCNxM08jcSNyM3Ijcn4zT0hQM1ZYUTFzJXI3W09ZM09ZWiVpWl0zT11eJWleI28zTyNvI3AzciNwI3EzTyNxI3IzciNyfjNPMXMzd1JRMXNPWTNyWl0zcl5+M3JHejRlVCVQUSVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08hXyVpIV8hYDR0IWAjbyVpI3AjcSVpI3J+JWlCZDR7UiF0LFclcjdbTyNvJWkjcCNxJWkjcn4laUd6NWlUJHlRJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFfJWkhXyFgNHQhYCNvJWkjcCNxJWkjcn4laUd7NlhfJXNgJXVwJXI3WyV6I3QlbFclZyxYT1k3V1laOmRaXTdXXV46ZF5yN1dyczp4c3c3V3d4O3x4I083VyNPI1A+biNQI283VyNvI3A/dCNwI3E3VyNxI3I/UyNyfjdXRnE3ZV0lcjdbJXghYiV6I3QlaVMlZyxYT1k4XllaJWlaXTheXV4laV53OF53eC1geCNPOF4jTyNQOV4jUCNvOF4jbyNwOXIjcCNxOF4jcSNyOXIjcn44XkJlOGVdJXI3WyVnLFhPWTheWVolaVpdOF5dXiVpXnc4Xnd4LWB4I084XiNPI1A5XiNQI284XiNvI3A5ciNwI3E4XiNxI3I5ciNyfjheQmU5Y1QlcjdbTyNvOF4jbyNwOXIjcCNxOF4jcSNyOXIjcn44XixYOXdWJWcsWE9ZOXJaXTlyXnc5cnd4LnB4I085ciNPI1A6XiNQfjlyLFg6YVBPfjlyO2g6b1IlcjdbJXghYiV6I3QlaVNPI28laSNwI3ElaSNyfiVpQ3s7VF0lcjdbJXghYiVpUyVnLFhPWTheWVolaVpdOF5dXiVpXnc4Xnd4LWB4I084XiNPI1A5XiNQI284XiNvI3A5ciNwI3E4XiNxI3I5ciNyfjheRnE8VlolcjdbJXojdCVnLFhPcjpkcnM8eHN3OmR3eD1beCNPOmQjTyNQPXAjUCNvOmQjbyNwPl8jcCNxOmQjcSNyPlUjcn46ZDhyPVJSJXI3WyV4IWIlaVNPI28laSNwI3ElaSNyfiVpRnE9Z1IlaiFmJXI3WyV6I3QlaCxYTyNvJWkjcCNxJWkjcn4laTtoPXVUJXI3W08jbzpkI28jcD5VI3AjcTpkI3Ejcj5VI3J+OmQlWz5fTyV4IWIleiN0JWlTJVs+ZFAlaVMjbyNwPmclVz5uTyV4IWIleiN0RnE+c1QlcjdbTyNvN1cjbyNwP1MjcCNxN1cjcSNyP1Mjcn43VzBlP19WJXghYiV6I3QlaVMlZyxYT1k5clpdOXJedzlyd3gucHgjTzlyI08jUDpeI1B+OXIwZT97WCVpUyVnLFhPWTlyWl05cl53OXJ3eC5weCNPOXIjTyNQOl4jUCNvOXIjbyNwQGgjcH45cjBhQHFWJXghYiV6I3QlZyxYT1k5clpdOXJedzlyd3gucHgjTzlyI08jUDpeI1B+OXJHe0FrUmYsWCVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08jbyVpI3AjcSVpI3J+JWk8dUJYUiFQUiVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08jbyVpI3AjcSVpI3J+JWlHe0J1VlQsWCVvYCV1cCVyN1sleCFiJXojdCVpUyVsV096JWl6e0NbeyFfJWkhXyFgNHQhYCNvJWkjcCNxJWkjcn4laUJlQ2NUX1IlcjdbTyFfJWkhXyFgNHQhYCNvJWkjcCNxJWkjcn4laUd7RFZUJHwsWCVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08hXyVpIV8hYDR0IWAjbyVpI3AjcSVpI3J+JWlHe0R5UngsWCVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08jbyVpI3AjcSVpI3J+JWlNZ0VnVSR9LFglb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPIV8laSFfIWA0dCFgIWFFeSFhI28laSNwI3ElaSNyfiVpPHZGUVImVSZqJXI3W08jbyVpI3AjcSVpI3J+JWlHe0ZuViFlUSVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08hTyVpIU8hUEdUIVAhUSVpIVEhW0d5IVsjbyVpI3AjcSVpI3J+JWlCZUdZVCVyN1tPIU8laSFPIVBHaSFQI28laSNwI3ElaSNyfiVpQmVHcFIhbixYJXI3W08jbyVpI3AjcSVpI3J+JWlCY0hRXyFnLFYlcjdbTyFRJWkhUSFbR3khWyFnJWkhZyFoSVAhaCFsJWkhbCFtS1AhbSNSJWkjUiNTR3kjUyNYJWkjWCNZSVAjWSNeJWkjXiNfS1AjXyNvJWkjcCNxJWkjcn4laUJjSVVYJXI3W097JWl7fElxfH0laX0hT0lxIU8hUSVpIVEhW0pWIVsjbyVpI3AjcSVpI3J+JWlCY0l2VCVyN1tPIVElaSFRIVtKViFbI28laSNwI3ElaSNyfiVpQmNKXlohZyxWJXI3W08hUSVpIVEhW0pWIVshbCVpIWwhbUtQIW0jUiVpI1IjU0pWI1MjXiVpI14jX0tQI18jbyVpI3AjcSVpI3J+JWlCY0tXUiFnLFYlcjdbTyNvJWkjcCNxJWkjcn4laUd7S3RWJU9SJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFQJWkhUCFRTFohUSFfJWkhXyFgNHQhYCNvJWkjcCNxJWkjcn4laUJkTGJUJVFRJXI3W08hXyVpIV8hYDR0IWAjbyVpI3AjcSVpI3J+JWlHeU1VbSFnLFYlb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPIU8laSFPIVAhIFAhUCFRJWkhUSFbISFrIVshZCVpIWQhZSEjdyFlIWclaSFnIWhJUCFoIWwlaSFsIW1LUCFtIXElaSFxIXIhJVYhciF6JWkheiF7ISZfIXsjUiVpI1IjUyEhayNTI1UlaSNVI1YhI3cjViNYJWkjWCNZSVAjWSNeJWkjXiNfS1AjXyNjJWkjYyNkISVWI2QjbCVpI2wjbSEmXyNtI28laSNwI3ElaSNyfiVpQmMhIFVUJXI3W08hUSVpIVEhWyEgZSFbI28laSNwI3ElaSNyfiVpQmMhIGxfIWcsViVyN1tPIVElaSFRIVshIGUhWyFnJWkhZyFoSVAhaCFsJWkhbCFtS1AhbSNSJWkjUiNTISBlI1MjWCVpI1gjWUlQI1kjXiVpI14jX0tQI18jbyVpI3AjcSVpI3J+JWlCYyEhcmEhZyxWJXI3W08hTyVpIU8hUCEgUCFQIVElaSFRIVshIWshWyFnJWkhZyFoSVAhaCFsJWkhbCFtS1AhbSNSJWkjUiNTISFrI1MjWCVpI1gjWUlQI1kjXiVpI14jX0tQI18jbyVpI3AjcSVpI3J+JWlCYyEjfFclcjdbTyFRJWkhUSFSISRmIVIhUyEkZiFTI1IlaSNSI1MhJGYjUyNvJWkjcCNxJWkjcn4laUJjISRtVyFnLFYlcjdbTyFRJWkhUSFSISRmIVIhUyEkZiFTI1IlaSNSI1MhJGYjUyNvJWkjcCNxJWkjcn4laUJjISVbViVyN1tPIVElaSFRIVkhJXEhWSNSJWkjUiNTISVxI1MjbyVpI3AjcSVpI3J+JWlCYyEleFYhZyxWJXI3W08hUSVpIVEhWSElcSFZI1IlaSNSI1MhJXEjUyNvJWkjcCNxJWkjcn4laUJjISZkWiVyN1tPIVElaSFRIVshJ1YhWyFjJWkhYyFpISdWIWkjUiVpI1IjUyEnViNTI1QlaSNUI1ohJ1YjWiNvJWkjcCNxJWkjcn4laUJjISdeWiFnLFYlcjdbTyFRJWkhUSFbISdWIVshYyVpIWMhaSEnViFpI1IlaSNSI1MhJ1YjUyNUJWkjVCNaISdWI1ojbyVpI3AjcSVpI3J+JWlHeSEoZGEhZyxWJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFPJWkhTyFQISBQIVAhUSVpIVEhWyEhayFbIWclaSFnIWhJUCFoIWwlaSFsIW1LUCFtI1IlaSNSI1MhIWsjUyNYJWkjWCNZSVAjWSNeJWkjXiNfS1AjXyNvJWkjcCNxJWkjcn4laU1nISl8VHkxcyVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08hXyVpIV8hYCEqXSFgI28laSNwI3ElaSNyfiVpN18hKmRSJVlSJXI3W08jbyVpI3AjcSVpI3J+JWlHeyErUVIjXyxYJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyNvJWkjcCNxJWkjcn4laUd7IStuVmpSJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFeJWkhXiFfISxUIV8hYClkIWAhYSlkIWEjbyVpI3AjcSVpI3J+JWlCZCEsW1QkelElcjdbTyFfJWkhXyFgNHQhYCNvJWkjcCNxJWkjcn4laUd7IS1PVCVYLFglb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPIV8laSFfIWApZCFgI28laSNwI3ElaSNyfiVpR3shLXJValIlb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPIV8laSFfIWApZCFgIWEhLlUhYSNvJWkjcCNxJWkjcn4laUJkIS5dVCR7USVyN1tPIV8laSFfIWA0dCFgI28laSNwI3ElaSNyfiVpR3shL1JUXVEjdVAlb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPIV8laSFfIWA0dCFgI28laSNwI3ElaSNyfiVpTWchL3daJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXJWYmaiVTLFhPIVElaSFRIVshMGohWyFjJWkhYyF9ITBqIX0jUiVpI1IjUyEwaiNTI1QlaSNUI28hMGojcCNxJWkjciRnJWkkZ34hMGpIUCEwc1olcjdbJWYmaiVTLFhPIVElaSFRIVshMGohWyFjJWkhYyF9ITBqIX0jUiVpI1IjUyEwaiNTI1QlaSNUI28hMGojcCNxJWkjciRnJWkkZ34hMGpNZyExe2Mlb2AldXAlcjdbJXghYiV6I3QlaVMlbFclZiZqJVMsWE9yJWlycyEzV3N3JWl3eCE1T3ghUSVpIVEhWyEwaiFbIWMlaSFjIXQhMGohdCF1ITZ2IXUhfSEwaiF9I1IlaSNSI1MhMGojUyNUJWkjVCNmITBqI2YjZyE2diNnI28hMGojcCNxJWkjciRnJWkkZ34hMGpCZSEzX10lcjdbJWcsWE9ZLGBZWiVpWl0sYF1eJWlecixgcnMhNFdzI08sYCNPI1AtcCNQI28sYCNvI3AuVSNwI3EsYCNxI3IuVSNyfixgQmUhNF9UJXI3WyVnLFhPciVpcnMhNG5zI28laSNwI3ElaSNyfiVpQmUhNHVSJXI3WyVrLFhPI28laSNwI3ElaSNyfiVpQmUhNVZdJXI3WyVnLFhPWTheWVolaVpdOF5dXiVpXnc4Xnd4ITZPeCNPOF4jTyNQOV4jUCNvOF4jbyNwOXIjcCNxOF4jcSNyOXIjcn44XkJlITZWVCVyN1slZyxYT3claXd4ITZmeCNvJWkjcCNxJWkjcn4laUJlITZtUiVyN1slaCxYTyNvJWkjcCNxJWkjcn4laUhQITdQXyVyN1slZiZqJVMsWE9yJWlycyEzV3N3JWl3eCE1T3ghUSVpIVEhWyEwaiFbIWMlaSFjIX0hMGohfSNSJWkjUiNTITBqI1MjVCVpI1QjbyEwaiNwI3ElaSNyJGclaSRnfiEwak1nIThlYyVvYCV1cCVyN1sleCFiJXojdCVpUyVsVyVmJmolUyxYT3IlaXJzITlwc3claXd4ITp8eCFRJWkhUSFbITBqIVshYyVpIWMhdCEwaiF0IXUhPFkhdSF9ITBqIX0jUiVpI1IjUyEwaiNTI1QlaSNUI2YhMGojZiNnITxZI2cjbyEwaiNwI3ElaSNyJGclaSRnfiEwakJlITl3VCVyN1sldCxYT3IlaXJzITpXcyNvJWkjcCNxJWkjcn4laUJlITpdVCVyN1tPciVpcnMhOmxzI28laSNwI3ElaSNyfiVpQmUhOnNSJXI3WyV5LFhPI28laSNwI3ElaSNyfiVpQmUhO1RUJXI3WyVuLFhPdyVpd3ghO2R4I28laSNwI3ElaSNyfiVpQmUhO2lUJXI3W093JWl3eCE7eHgjbyVpI3AjcSVpI3J+JWlCZSE8UFIlcjdbJXcsWE8jbyVpI3AjcSVpI3J+JWlIUCE8Y18lcjdbJWYmaiVTLFhPciVpcnMhOXBzdyVpd3ghOnx4IVElaSFRIVshMGohWyFjJWkhYyF9ITBqIX0jUiVpI1IjUyEwaiNTI1QlaSNUI28hMGojcCNxJWkjciRnJWkkZ34hMGpNZyE9d2clb2AldXAlcjdbJXghYiV6I3QlaVMlbFclZiZqJVMsWE9yJWlycyEzV3N3JWl3eCE1T3ghUSVpIVEhWyEwaiFbIWMlaSFjIWghMGohaCFpITxZIWkhdCEwaiF0IXUhNnYhdSF9ITBqIX0jUiVpI1IjUyEwaiNTI1QlaSNUI1UhMGojVSNWITZ2I1YjWSEwaiNZI1ohPFkjWiNvITBqI3AjcSVpI3IkZyVpJGd+ITBqTWchP3VfJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXJWYmaiVTLFhPciVpcnMhM1dzdyVpd3ghNU94IVElaSFRIVshMGohWyFjJWkhYyF9ITBqIX0jUiVpI1IjUyEwaiNTI1QlaSNUI28hMGojcCNxJWkjciRnJWkkZ34hMGpHeyFBWFIhVyxYJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyNvJWkjcCNxJWkjcn4laU1nIUFnWCVyN1tPWSR9WVold1pdJH1dXiV3XiNvJH0jbyNwIUJTI3AjcSR9I3EjciFCUyNyfiR9JmYhQmNPJW9gJXVwJXghYiV6I3QlaVMlbFc8dSFCdlIhWFIlb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPI28laSNwI3ElaSNyfiVpR3ohQ2RUJHhRJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFfJWkhXyFgNHQhYCNvJWkjcCNxJWkjcn4laUd5IUN8UCFbR20laVMlbFcjbyNwIURQJlkhRFtPJW9gJXVwJXghYiV6I3RHeiFEb1Qkd1Elb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPIV8laSFfIWA0dCFgI28laSNwI3ElaSNyfiVpPHUhRWFPIV03XyVvYCV1cCV4IWIleiN0JWlTJWxXR3khRXRSJVIsViVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08jbyVpI3AjcSVpI3J+JWlcIixcbiAgdG9rZW5pemVyczogW2xlZ2FjeVByaW50LCAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgbmV3bGluZXMsIGJvZHlDb250aW51ZV0sXG4gIHRvcFJ1bGVzOiB7XCJTY3JpcHRcIjpbMCwzXX0sXG4gIHNwZWNpYWxpemVkOiBbe3Rlcm06IDE4OCwgZ2V0OiB2YWx1ZSA9PiBzcGVjX2lkZW50aWZpZXJbdmFsdWVdIHx8IC0xfV0sXG4gIHRva2VuUHJlYzogNjA2N1xufSk7XG5cbmV4cG9ydCB7IHBhcnNlciB9O1xuIiwiLy8vIFRoZSBkZWZhdWx0IG1heGltdW0gbGVuZ3RoIG9mIGEgYFRyZWVCdWZmZXJgIG5vZGUuXG5jb25zdCBEZWZhdWx0QnVmZmVyTGVuZ3RoID0gMTAyNDtcbmxldCBuZXh0UHJvcElEID0gMDtcbmNvbnN0IENhY2hlZE5vZGUgPSBuZXcgV2Vha01hcCgpO1xuLy8vIEVhY2ggW25vZGUgdHlwZV0oI3RyZWUuTm9kZVR5cGUpIGNhbiBoYXZlIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aFxuLy8vIGl0IGluIHByb3BzLiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyByZXByZXNlbnQgcHJvcCBuYW1lcy5cbmNsYXNzIE5vZGVQcm9wIHtcbiAgICAvLy8gQ3JlYXRlIGEgbmV3IG5vZGUgcHJvcCB0eXBlLiBZb3UgY2FuIG9wdGlvbmFsbHkgcGFzcyBhXG4gICAgLy8vIGBkZXNlcmlhbGl6ZWAgZnVuY3Rpb24uXG4gICAgY29uc3RydWN0b3IoeyBkZXNlcmlhbGl6ZSB9ID0ge30pIHtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRQcm9wSUQrKztcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplIHx8ICgoKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG5vZGUgdHlwZSBkb2Vzbid0IGRlZmluZSBhIGRlc2VyaWFsaXplIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8vIENyZWF0ZSBhIHN0cmluZy12YWx1ZWQgbm9kZSBwcm9wIHdob3NlIGRlc2VyaWFsaXplIGZ1bmN0aW9uIGlzXG4gICAgLy8vIHRoZSBpZGVudGl0eSBmdW5jdGlvbi5cbiAgICBzdGF0aWMgc3RyaW5nKCkgeyByZXR1cm4gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIgfSk7IH1cbiAgICAvLy8gQ3JlYXRlIGEgbnVtYmVyLXZhbHVlZCBub2RlIHByb3Agd2hvc2UgZGVzZXJpYWxpemUgZnVuY3Rpb24gaXNcbiAgICAvLy8ganVzdCBgTnVtYmVyYC5cbiAgICBzdGF0aWMgbnVtYmVyKCkgeyByZXR1cm4gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IE51bWJlciB9KTsgfVxuICAgIC8vLyBDcmVhdGVzIGEgYm9vbGVhbi12YWx1ZWQgbm9kZSBwcm9wIHdob3NlIGRlc2VyaWFsaXplIGZ1bmN0aW9uXG4gICAgLy8vIHJldHVybnMgdHJ1ZSBmb3IgYW55IGlucHV0LlxuICAgIHN0YXRpYyBmbGFnKCkgeyByZXR1cm4gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6ICgpID0+IHRydWUgfSk7IH1cbiAgICAvLy8gU3RvcmUgYSB2YWx1ZSBmb3IgdGhpcyBwcm9wIGluIHRoZSBnaXZlbiBvYmplY3QuIFRoaXMgY2FuIGJlXG4gICAgLy8vIHVzZWZ1bCB3aGVuIGJ1aWxkaW5nIHVwIGEgcHJvcCBvYmplY3QgdG8gcGFzcyB0byB0aGVcbiAgICAvLy8gW2BOb2RlVHlwZWBdKCN0cmVlLk5vZGVUeXBlKSBjb25zdHJ1Y3Rvci4gUmV0dXJucyBpdHMgZmlyc3RcbiAgICAvLy8gYXJndW1lbnQuXG4gICAgc2V0KHByb3BPYmosIHZhbHVlKSB7XG4gICAgICAgIHByb3BPYmpbdGhpcy5pZF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHByb3BPYmo7XG4gICAgfVxuICAgIC8vLyBUaGlzIGlzIG1lYW50IHRvIGJlIHVzZWQgd2l0aFxuICAgIC8vLyBbYE5vZGVTZXQuZXh0ZW5kYF0oI3RyZWUuTm9kZVNldC5leHRlbmQpIG9yXG4gICAgLy8vIFtgUGFyc2VyLndpdGhQcm9wc2BdKCNsZXplci5QYXJzZXIud2l0aFByb3BzKSB0byBjb21wdXRlIHByb3BcbiAgICAvLy8gdmFsdWVzIGZvciBlYWNoIG5vZGUgdHlwZSBpbiB0aGUgc2V0LiBUYWtlcyBhIFttYXRjaFxuICAgIC8vLyBvYmplY3RdKCN0cmVlLk5vZGVUeXBlXm1hdGNoKSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdW5kZWZpbmVkXG4gICAgLy8vIGlmIHRoZSBub2RlIHR5cGUgZG9lc24ndCBnZXQgdGhpcyBwcm9wLCBhbmQgdGhlIHByb3AncyB2YWx1ZSBpZlxuICAgIC8vLyBpdCBkb2VzLlxuICAgIGFkZChtYXRjaCkge1xuICAgICAgICBpZiAodHlwZW9mIG1hdGNoICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIG1hdGNoID0gTm9kZVR5cGUubWF0Y2gobWF0Y2gpO1xuICAgICAgICByZXR1cm4gKHR5cGUpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBtYXRjaCh0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBbdGhpcywgcmVzdWx0XTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4vLy8gUHJvcCB0aGF0IGlzIHVzZWQgdG8gZGVzY3JpYmUgbWF0Y2hpbmcgZGVsaW1pdGVycy4gRm9yIG9wZW5pbmdcbi8vLyBkZWxpbWl0ZXJzLCB0aGlzIGhvbGRzIGFuIGFycmF5IG9mIG5vZGUgbmFtZXMgKHdyaXR0ZW4gYXMgYVxuLy8vIHNwYWNlLXNlcGFyYXRlZCBzdHJpbmcgd2hlbiBkZWNsYXJpbmcgdGhpcyBwcm9wIGluIGEgZ3JhbW1hcilcbi8vLyBmb3IgdGhlIG5vZGUgdHlwZXMgb2YgY2xvc2luZyBkZWxpbWl0ZXJzIHRoYXQgbWF0Y2ggaXQuXG5Ob2RlUHJvcC5jbG9zZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8vLyBUaGUgaW52ZXJzZSBvZiBbYG9wZW5lZEJ5YF0oI3RyZWUuTm9kZVByb3BeY2xvc2VkQnkpLiBUaGlzIGlzXG4vLy8gYXR0YWNoZWQgdG8gY2xvc2luZyBkZWxpbWl0ZXJzLCBob2xkaW5nIGFuIGFycmF5IG9mIG5vZGUgbmFtZXNcbi8vLyBvZiB0eXBlcyBvZiBtYXRjaGluZyBvcGVuaW5nIGRlbGltaXRlcnMuXG5Ob2RlUHJvcC5vcGVuZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8vLyBVc2VkIHRvIGFzc2lnbiBub2RlIHR5cGVzIHRvIGdyb3VwcyAoZm9yIGV4YW1wbGUsIGFsbCBub2RlXG4vLy8gdHlwZXMgdGhhdCByZXByZXNlbnQgYW4gZXhwcmVzc2lvbiBjb3VsZCBiZSB0YWdnZWQgd2l0aCBhblxuLy8vIGBcIkV4cHJlc3Npb25cImAgZ3JvdXApLlxuTm9kZVByb3AuZ3JvdXAgPSBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogc3RyID0+IHN0ci5zcGxpdChcIiBcIikgfSk7XG5jb25zdCBub1Byb3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8vLyBFYWNoIG5vZGUgaW4gYSBzeW50YXggdHJlZSBoYXMgYSBub2RlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIGl0LlxuY2xhc3MgTm9kZVR5cGUge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIG5hbWUgb2YgdGhlIG5vZGUgdHlwZS4gTm90IG5lY2Vzc2FyaWx5IHVuaXF1ZSwgYnV0IGlmIHRoZVxuICAgIC8vLyBncmFtbWFyIHdhcyB3cml0dGVuIHByb3Blcmx5LCBkaWZmZXJlbnQgbm9kZSB0eXBlcyB3aXRoIHRoZVxuICAgIC8vLyBzYW1lIG5hbWUgd2l0aGluIGEgbm9kZSBzZXQgc2hvdWxkIHBsYXkgdGhlIHNhbWUgc2VtYW50aWNcbiAgICAvLy8gcm9sZS5cbiAgICBuYW1lLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgcHJvcHMsIFxuICAgIC8vLyBUaGUgaWQgb2YgdGhpcyBub2RlIGluIGl0cyBzZXQuIENvcnJlc3BvbmRzIHRvIHRoZSB0ZXJtIGlkc1xuICAgIC8vLyB1c2VkIGluIHRoZSBwYXJzZXIuXG4gICAgaWQsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBmbGFncyA9IDApIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7XG4gICAgICAgIGxldCBwcm9wcyA9IHNwZWMucHJvcHMgJiYgc3BlYy5wcm9wcy5sZW5ndGggPyBPYmplY3QuY3JlYXRlKG51bGwpIDogbm9Qcm9wcztcbiAgICAgICAgbGV0IGZsYWdzID0gKHNwZWMudG9wID8gMSAvKiBUb3AgKi8gOiAwKSB8IChzcGVjLnNraXBwZWQgPyAyIC8qIFNraXBwZWQgKi8gOiAwKSB8XG4gICAgICAgICAgICAoc3BlYy5lcnJvciA/IDQgLyogRXJyb3IgKi8gOiAwKSB8IChzcGVjLm5hbWUgPT0gbnVsbCA/IDggLyogQW5vbnltb3VzICovIDogMCk7XG4gICAgICAgIGxldCB0eXBlID0gbmV3IE5vZGVUeXBlKHNwZWMubmFtZSB8fCBcIlwiLCBwcm9wcywgc3BlYy5pZCwgZmxhZ3MpO1xuICAgICAgICBpZiAoc3BlYy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHNyYyBvZiBzcGVjLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNyYykpXG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYyh0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3JjKVxuICAgICAgICAgICAgICAgICAgICBzcmNbMF0uc2V0KHByb3BzLCBzcmNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgLy8vIFJldHJpZXZlcyBhIG5vZGUgcHJvcCBmb3IgdGhpcyB0eXBlLiBXaWxsIHJldHVybiBgdW5kZWZpbmVkYCBpZlxuICAgIC8vLyB0aGUgcHJvcCBpc24ndCBwcmVzZW50IG9uIHRoaXMgbm9kZS5cbiAgICBwcm9wKHByb3ApIHsgcmV0dXJuIHRoaXMucHJvcHNbcHJvcC5pZF07IH1cbiAgICAvLy8gVHJ1ZSB3aGVuIHRoaXMgaXMgdGhlIHRvcCBub2RlIG9mIGEgZ3JhbW1hci5cbiAgICBnZXQgaXNUb3AoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDEgLyogVG9wICovKSA+IDA7IH1cbiAgICAvLy8gVHJ1ZSB3aGVuIHRoaXMgbm9kZSBpcyBwcm9kdWNlZCBieSBhIHNraXAgcnVsZS5cbiAgICBnZXQgaXNTa2lwcGVkKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyIC8qIFNraXBwZWQgKi8pID4gMDsgfVxuICAgIC8vLyBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGFuIGVycm9yIG5vZGUuXG4gICAgZ2V0IGlzRXJyb3IoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDQgLyogRXJyb3IgKi8pID4gMDsgfVxuICAgIC8vLyBXaGVuIHRydWUsIHRoaXMgbm9kZSB0eXBlIGRvZXNuJ3QgY29ycmVzcG9uZCB0byBhIHVzZXItZGVjbGFyZWRcbiAgICAvLy8gbmFtZWQgbm9kZSwgZm9yIGV4YW1wbGUgYmVjYXVzZSBpdCBpcyB1c2VkIHRvIGNhY2hlIHJlcGV0aXRpb24uXG4gICAgZ2V0IGlzQW5vbnltb3VzKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA4IC8qIEFub255bW91cyAqLykgPiAwOyB9XG4gICAgLy8vIFJldHVybnMgdHJ1ZSB3aGVuIHRoaXMgbm9kZSdzIG5hbWUgb3Igb25lIG9mIGl0c1xuICAgIC8vLyBbZ3JvdXBzXSgjdHJlZS5Ob2RlUHJvcF5ncm91cCkgbWF0Y2hlcyB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgIGlzKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uYW1lID09IG5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBsZXQgZ3JvdXAgPSB0aGlzLnByb3AoTm9kZVByb3AuZ3JvdXApO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwID8gZ3JvdXAuaW5kZXhPZihuYW1lKSA+IC0xIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaWQgPT0gbmFtZTtcbiAgICB9XG4gICAgLy8vIENyZWF0ZSBhIGZ1bmN0aW9uIGZyb20gbm9kZSB0eXBlcyB0byBhcmJpdHJhcnkgdmFsdWVzIGJ5XG4gICAgLy8vIHNwZWNpZnlpbmcgYW4gb2JqZWN0IHdob3NlIHByb3BlcnR5IG5hbWVzIGFyZSBub2RlIG9yXG4gICAgLy8vIFtncm91cF0oI3RyZWUuTm9kZVByb3BeZ3JvdXApIG5hbWVzLiBPZnRlbiB1c2VmdWwgd2l0aFxuICAgIC8vLyBbYE5vZGVQcm9wLmFkZGBdKCN0cmVlLk5vZGVQcm9wLmFkZCkuIFlvdSBjYW4gcHV0IG11bHRpcGxlXG4gICAgLy8vIG5hbWVzLCBzZXBhcmF0ZWQgYnkgc3BhY2VzLCBpbiBhIHNpbmdsZSBwcm9wZXJ0eSBuYW1lIHRvIG1hcFxuICAgIC8vLyBtdWx0aXBsZSBub2RlIG5hbWVzIHRvIGEgc2luZ2xlIHZhbHVlLlxuICAgIHN0YXRpYyBtYXRjaChtYXApIHtcbiAgICAgICAgbGV0IGRpcmVjdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gbWFwKVxuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBvZiBwcm9wLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgICAgICBkaXJlY3RbbmFtZV0gPSBtYXBbcHJvcF07XG4gICAgICAgIHJldHVybiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXBzID0gbm9kZS5wcm9wKE5vZGVQcm9wLmdyb3VwKSwgaSA9IC0xOyBpIDwgKGdyb3VwcyA/IGdyb3Vwcy5sZW5ndGggOiAwKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZGlyZWN0W2kgPCAwID8gbm9kZS5uYW1lIDogZ3JvdXBzW2ldXTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG4vLy8gQW4gZW1wdHkgZHVtbXkgbm9kZSB0eXBlIHRvIHVzZSB3aGVuIG5vIGFjdHVhbCB0eXBlIGlzIGF2YWlsYWJsZS5cbk5vZGVUeXBlLm5vbmUgPSBuZXcgTm9kZVR5cGUoXCJcIiwgT2JqZWN0LmNyZWF0ZShudWxsKSwgMCwgOCAvKiBBbm9ueW1vdXMgKi8pO1xuLy8vIEEgbm9kZSBzZXQgaG9sZHMgYSBjb2xsZWN0aW9uIG9mIG5vZGUgdHlwZXMuIEl0IGlzIHVzZWQgdG9cbi8vLyBjb21wYWN0bHkgcmVwcmVzZW50IHRyZWVzIGJ5IHN0b3JpbmcgdGhlaXIgdHlwZSBpZHMsIHJhdGhlciB0aGFuIGFcbi8vLyBmdWxsIHBvaW50ZXIgdG8gdGhlIHR5cGUgb2JqZWN0LCBpbiBhIG51bWJlciBhcnJheS4gRWFjaCBwYXJzZXJcbi8vLyBbaGFzXSgjbGV6ZXIuUGFyc2VyLm5vZGVTZXQpIGEgbm9kZSBzZXQsIGFuZCBbdHJlZVxuLy8vIGJ1ZmZlcnNdKCN0cmVlLlRyZWVCdWZmZXIpIGNhbiBvbmx5IHN0b3JlIGNvbGxlY3Rpb25zIG9mIG5vZGVzXG4vLy8gZnJvbSB0aGUgc2FtZSBzZXQuIEEgc2V0IGNhbiBoYXZlIGEgbWF4aW11bSBvZiAyKioxNiAoNjU1MzYpXG4vLy8gbm9kZSB0eXBlcyBpbiBpdCwgc28gdGhhdCB0aGUgaWRzIGZpdCBpbnRvIDE2LWJpdCB0eXBlZCBhcnJheVxuLy8vIHNsb3RzLlxuY2xhc3MgTm9kZVNldCB7XG4gICAgLy8vIENyZWF0ZSBhIHNldCB3aXRoIHRoZSBnaXZlbiB0eXBlcy4gVGhlIGBpZGAgcHJvcGVydHkgb2YgZWFjaFxuICAgIC8vLyB0eXBlIHNob3VsZCBjb3JyZXNwb25kIHRvIGl0cyBwb3NpdGlvbiB3aXRoaW4gdGhlIGFycmF5LlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgbm9kZSB0eXBlcyBpbiB0aGlzIHNldCwgYnkgaWQuXG4gICAgdHlwZXMpIHtcbiAgICAgICAgdGhpcy50eXBlcyA9IHR5cGVzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHR5cGVzW2ldLmlkICE9IGkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJOb2RlIHR5cGUgaWRzIHNob3VsZCBjb3JyZXNwb25kIHRvIGFycmF5IHBvc2l0aW9ucyB3aGVuIGNyZWF0aW5nIGEgbm9kZSBzZXRcIik7XG4gICAgfVxuICAgIC8vLyBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgc2V0IHdpdGggc29tZSBub2RlIHByb3BlcnRpZXMgYWRkZWQuIFRoZVxuICAgIC8vLyBhcmd1bWVudHMgdG8gdGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNyZWF0ZWQgd2l0aFxuICAgIC8vLyBbYE5vZGVQcm9wLmFkZGBdKCN0cmVlLk5vZGVQcm9wLmFkZCkuXG4gICAgZXh0ZW5kKC4uLnByb3BzKSB7XG4gICAgICAgIGxldCBuZXdUeXBlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0eXBlIG9mIHRoaXMudHlwZXMpIHtcbiAgICAgICAgICAgIGxldCBuZXdQcm9wcyA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2YgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWRkID0gc291cmNlKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdQcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgdHlwZS5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFswXS5zZXQobmV3UHJvcHMsIGFkZFsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3VHlwZXMucHVzaChuZXdQcm9wcyA/IG5ldyBOb2RlVHlwZSh0eXBlLm5hbWUsIG5ld1Byb3BzLCB0eXBlLmlkLCB0eXBlLmZsYWdzKSA6IHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVNldChuZXdUeXBlcyk7XG4gICAgfVxufVxuLy8vIEEgcGllY2Ugb2Ygc3ludGF4IHRyZWUuIFRoZXJlIGFyZSB0d28gd2F5cyB0byBhcHByb2FjaCB0aGVzZVxuLy8vIHRyZWVzOiB0aGUgd2F5IHRoZXkgYXJlIGFjdHVhbGx5IHN0b3JlZCBpbiBtZW1vcnksIGFuZCB0aGVcbi8vLyBjb252ZW5pZW50IHdheS5cbi8vL1xuLy8vIFN5bnRheCB0cmVlcyBhcmUgc3RvcmVkIGFzIGEgdHJlZSBvZiBgVHJlZWAgYW5kIGBUcmVlQnVmZmVyYFxuLy8vIG9iamVjdHMuIEJ5IHBhY2tpbmcgZGV0YWlsIGluZm9ybWF0aW9uIGludG8gYFRyZWVCdWZmZXJgIGxlYWZcbi8vLyBub2RlcywgdGhlIHJlcHJlc2VudGF0aW9uIGlzIG1hZGUgYSBsb3QgbW9yZSBtZW1vcnktZWZmaWNpZW50LlxuLy8vXG4vLy8gSG93ZXZlciwgd2hlbiB5b3Ugd2FudCB0byBhY3R1YWxseSB3b3JrIHdpdGggdHJlZSBub2RlcywgdGhpc1xuLy8vIHJlcHJlc2VudGF0aW9uIGlzIHZlcnkgYXdrd2FyZCwgc28gbW9zdCBjbGllbnQgY29kZSB3aWxsIHdhbnQgdG9cbi8vLyB1c2UgdGhlIGBUcmVlQ3Vyc29yYCBpbnRlcmZhY2UgaW5zdGVhZCwgd2hpY2ggcHJvdmlkZXMgYSB2aWV3IG9uXG4vLy8gc29tZSBwYXJ0IG9mIHRoaXMgZGF0YSBzdHJ1Y3R1cmUsIGFuZCBjYW4gYmUgdXNlZCB0byBtb3ZlIGFyb3VuZFxuLy8vIHRvIGFkamFjZW50IG5vZGVzLlxuY2xhc3MgVHJlZSB7XG4gICAgLy8vIENvbnN0cnVjdCBhIG5ldyB0cmVlLiBZb3UgdXN1YWxseSB3YW50IHRvIGdvIHRocm91Z2hcbiAgICAvLy8gW2BUcmVlLmJ1aWxkYF0oI3RyZWUuVHJlZV5idWlsZCkgaW5zdGVhZC5cbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBcbiAgICAvLy8gVGhlIHRyZWUncyBjaGlsZCBub2Rlcy4gQ2hpbGRyZW4gc21hbGwgZW5vdWdoIHRvIGZpdCBpbiBhXG4gICAgLy8vIGBUcmVlQnVmZmVyIHdpbGwgYmUgcmVwcmVzZW50ZWQgYXMgc3VjaCwgb3RoZXIgY2hpbGRyZW4gY2FuIGJlXG4gICAgLy8vIGZ1cnRoZXIgYFRyZWVgIGluc3RhbmNlcyB3aXRoIHRoZWlyIG93biBpbnRlcm5hbCBzdHJ1Y3R1cmUuXG4gICAgY2hpbGRyZW4sIFxuICAgIC8vLyBUaGUgcG9zaXRpb25zIChvZmZzZXRzIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGlzIHRyZWUpIG9mXG4gICAgLy8vIHRoZSBjaGlsZHJlbi5cbiAgICBwb3NpdGlvbnMsIFxuICAgIC8vLyBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoaXMgdHJlZVxuICAgIGxlbmd0aCkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLm1hcChjID0+IGMudG9TdHJpbmcoKSkuam9pbigpO1xuICAgICAgICByZXR1cm4gIXRoaXMudHlwZS5uYW1lID8gY2hpbGRyZW4gOlxuICAgICAgICAgICAgKC9cXFcvLnRlc3QodGhpcy50eXBlLm5hbWUpICYmICF0aGlzLnR5cGUuaXNFcnJvciA/IEpTT04uc3RyaW5naWZ5KHRoaXMudHlwZS5uYW1lKSA6IHRoaXMudHlwZS5uYW1lKSArXG4gICAgICAgICAgICAgICAgKGNoaWxkcmVuLmxlbmd0aCA/IFwiKFwiICsgY2hpbGRyZW4gKyBcIilcIiA6IFwiXCIpO1xuICAgIH1cbiAgICAvLy8gR2V0IGEgW3RyZWUgY3Vyc29yXSgjdHJlZS5UcmVlQ3Vyc29yKSByb290ZWQgYXQgdGhpcyB0cmVlLiBXaGVuXG4gICAgLy8vIGBwb3NgIGlzIGdpdmVuLCB0aGUgY3Vyc29yIGlzIFttb3ZlZF0oI3RyZWUuVHJlZUN1cnNvci5tb3ZlVG8pXG4gICAgLy8vIHRvIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgc2lkZS5cbiAgICBjdXJzb3IocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgc2NvcGUgPSAocG9zICE9IG51bGwgJiYgQ2FjaGVkTm9kZS5nZXQodGhpcykpIHx8IHRoaXMudG9wTm9kZTtcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBUcmVlQ3Vyc29yKHNjb3BlKTtcbiAgICAgICAgaWYgKHBvcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjdXJzb3IubW92ZVRvKHBvcywgc2lkZSk7XG4gICAgICAgICAgICBDYWNoZWROb2RlLnNldCh0aGlzLCBjdXJzb3IuX3RyZWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJzb3I7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbdHJlZSBjdXJzb3JdKCN0cmVlLlRyZWVDdXJzb3IpIHRoYXQsIHVubGlrZSByZWd1bGFyXG4gICAgLy8vIGN1cnNvcnMsIGRvZXNuJ3Qgc2tpcCBbYW5vbnltb3VzXSgjdHJlZS5Ob2RlVHlwZS5pc0Fub255bW91cylcbiAgICAvLy8gbm9kZXMuXG4gICAgZnVsbEN1cnNvcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMudG9wTm9kZSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbc3ludGF4IG5vZGVdKCN0cmVlLlN5bnRheE5vZGUpIG9iamVjdCBmb3IgdGhlIHRvcCBvZiB0aGVcbiAgICAvLy8gdHJlZS5cbiAgICBnZXQgdG9wTm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZSh0aGlzLCAwLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLy8vIEdldCB0aGUgW3N5bnRheCBub2RlXSgjdHJlZS5TeW50YXhOb2RlKSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgLy8vIElmIGBzaWRlYCBpcyAtMSwgdGhpcyB3aWxsIG1vdmUgaW50byBub2RlcyB0aGF0IGVuZCBhdCB0aGVcbiAgICAvLy8gcG9zaXRpb24uIElmIDEsIGl0J2xsIG1vdmUgaW50byBub2RlcyB0aGF0IHN0YXJ0IGF0IHRoZVxuICAgIC8vLyBwb3NpdGlvbi4gV2l0aCAwLCBpdCdsbCBvbmx5IGVudGVyIG5vZGVzIHRoYXQgY292ZXIgdGhlIHBvc2l0aW9uXG4gICAgLy8vIGZyb20gYm90aCBzaWRlcy5cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yKHBvcywgc2lkZSkubm9kZTtcbiAgICB9XG4gICAgLy8vIEl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBhbmQgaXRzIGNoaWxkcmVuLCBjYWxsaW5nIGBlbnRlcmAgZm9yIGFueVxuICAgIC8vLyBub2RlIHRoYXQgdG91Y2hlcyB0aGUgYGZyb21gL2B0b2AgcmVnaW9uIChpZiBnaXZlbikgYmVmb3JlXG4gICAgLy8vIHJ1bm5pbmcgb3ZlciBzdWNoIGEgbm9kZSdzIGNoaWxkcmVuLCBhbmQgYGxlYXZlYCAoaWYgZ2l2ZW4pIHdoZW5cbiAgICAvLy8gbGVhdmluZyB0aGUgbm9kZS4gV2hlbiBgZW50ZXJgIHJldHVybnMgYGZhbHNlYCwgdGhlIGdpdmVuIG5vZGVcbiAgICAvLy8gd2lsbCBub3QgaGF2ZSBpdHMgY2hpbGRyZW4gaXRlcmF0ZWQgb3ZlciAob3IgYGxlYXZlYCBjYWxsZWQpLlxuICAgIGl0ZXJhdGUoc3BlYykge1xuICAgICAgICBsZXQgeyBlbnRlciwgbGVhdmUsIGZyb20gPSAwLCB0byA9IHRoaXMubGVuZ3RoIH0gPSBzcGVjO1xuICAgICAgICBmb3IgKGxldCBjID0gdGhpcy5jdXJzb3IoKTs7KSB7XG4gICAgICAgICAgICBsZXQgbXVzdExlYXZlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYy5mcm9tIDw9IHRvICYmIGMudG8gPj0gZnJvbSAmJiAoYy50eXBlLmlzQW5vbnltb3VzIHx8IGVudGVyKGMudHlwZSwgYy5mcm9tLCBjLnRvKSAhPT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMuZmlyc3RDaGlsZCgpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWMudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAobXVzdExlYXZlICYmIGxlYXZlKVxuICAgICAgICAgICAgICAgICAgICBsZWF2ZShjLnR5cGUsIGMuZnJvbSwgYy50byk7XG4gICAgICAgICAgICAgICAgbXVzdExlYXZlID0gYy50eXBlLmlzQW5vbnltb3VzO1xuICAgICAgICAgICAgICAgIGlmIChjLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICghYy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEJhbGFuY2UgdGhlIGRpcmVjdCBjaGlsZHJlbiBvZiB0aGlzIHRyZWUuXG4gICAgYmFsYW5jZShtYXhCdWZmZXJMZW5ndGggPSBEZWZhdWx0QnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA8PSBCYWxhbmNlQnJhbmNoRmFjdG9yID8gdGhpc1xuICAgICAgICAgICAgOiBiYWxhbmNlUmFuZ2UodGhpcy50eXBlLCBOb2RlVHlwZS5ub25lLCB0aGlzLmNoaWxkcmVuLCB0aGlzLnBvc2l0aW9ucywgMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgsIDAsIG1heEJ1ZmZlckxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuICAgIH1cbiAgICAvLy8gQnVpbGQgYSB0cmVlIGZyb20gYSBwb3N0Zml4LW9yZGVyZWQgYnVmZmVyIG9mIG5vZGUgaW5mb3JtYXRpb24sXG4gICAgLy8vIG9yIGEgY3Vyc29yIG92ZXIgc3VjaCBhIGJ1ZmZlci5cbiAgICBzdGF0aWMgYnVpbGQoZGF0YSkgeyByZXR1cm4gYnVpbGRUcmVlKGRhdGEpOyB9XG59XG4vLy8gVGhlIGVtcHR5IHRyZWVcblRyZWUuZW1wdHkgPSBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBbXSwgW10sIDApO1xuLy8vIFRyZWUgYnVmZmVycyBjb250YWluICh0eXBlLCBzdGFydCwgZW5kLCBlbmRJbmRleCkgcXVhZHMgZm9yIGVhY2hcbi8vLyBub2RlLiBJbiBzdWNoIGEgYnVmZmVyLCBub2RlcyBhcmUgc3RvcmVkIGluIHByZWZpeCBvcmRlciAocGFyZW50c1xuLy8vIGJlZm9yZSBjaGlsZHJlbiwgd2l0aCB0aGUgZW5kSW5kZXggb2YgdGhlIHBhcmVudCBpbmRpY2F0aW5nIHdoaWNoXG4vLy8gY2hpbGRyZW4gYmVsb25nIHRvIGl0KVxuY2xhc3MgVHJlZUJ1ZmZlciB7XG4gICAgLy8vIENyZWF0ZSBhIHRyZWUgYnVmZmVyIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBidWZmZXIsIFxuICAgIC8vIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGdyb3VwIG9mIG5vZGVzIGluIHRoZSBidWZmZXIuXG4gICAgbGVuZ3RoLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgc2V0LCB0eXBlID0gTm9kZVR5cGUubm9uZSkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuYnVmZmVyLmxlbmd0aDspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuY2hpbGRTdHJpbmcoaW5kZXgpKTtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5idWZmZXJbaW5kZXggKyAzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIsXCIpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgY2hpbGRTdHJpbmcoaW5kZXgpIHtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5idWZmZXJbaW5kZXhdLCBlbmRJbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5zZXQudHlwZXNbaWRdLCByZXN1bHQgPSB0eXBlLm5hbWU7XG4gICAgICAgIGlmICgvXFxXLy50ZXN0KHJlc3VsdCkgJiYgIXR5cGUuaXNFcnJvcilcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgIGlmIChlbmRJbmRleCA9PSBpbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkU3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIFwiKFwiICsgY2hpbGRyZW4uam9pbihcIixcIikgKyBcIilcIjtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZpbmRDaGlsZChzdGFydEluZGV4LCBlbmRJbmRleCwgZGlyLCBhZnRlcikge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMsIHBpY2sgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgIT0gZW5kSW5kZXg7IGkgPSBidWZmZXJbaSArIDNdKSB7XG4gICAgICAgICAgICBpZiAoYWZ0ZXIgIT0gLTEwMDAwMDAwMCAvKiBOb25lICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gYnVmZmVyW2kgKyAxXSwgZW5kID0gYnVmZmVyW2kgKyAyXTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kID4gYWZ0ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBwaWNrID0gaTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA+IGFmdGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPCBhZnRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpY2sgPSBpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kID49IGFmdGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGljayA9IGk7XG4gICAgICAgICAgICAgICAgaWYgKGRpciA+IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaWNrO1xuICAgIH1cbn1cbmNsYXNzIFRyZWVOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBmcm9tLCBpbmRleCwgX3BhcmVudCkge1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gdGhpcy5ub2RlLnR5cGU7IH1cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMubm9kZS50eXBlLm5hbWU7IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmZyb20gKyB0aGlzLm5vZGUubGVuZ3RoOyB9XG4gICAgbmV4dENoaWxkKGksIGRpciwgYWZ0ZXIsIGZ1bGwgPSBmYWxzZSkge1xuICAgICAgICBmb3IgKGxldCBwYXJlbnQgPSB0aGlzOzspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHsgY2hpbGRyZW4sIHBvc2l0aW9ucyB9ID0gcGFyZW50Lm5vZGUsIGUgPSBkaXIgPiAwID8gY2hpbGRyZW4ubGVuZ3RoIDogLTE7IGkgIT0gZTsgaSArPSBkaXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGNoaWxkcmVuW2ldLCBzdGFydCA9IHBvc2l0aW9uc1tpXSArIHBhcmVudC5mcm9tO1xuICAgICAgICAgICAgICAgIGlmIChhZnRlciAhPSAtMTAwMDAwMDAwIC8qIE5vbmUgKi8gJiYgKGRpciA8IDAgPyBzdGFydCA+PSBhZnRlciA6IHN0YXJ0ICsgbmV4dC5sZW5ndGggPD0gYWZ0ZXIpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gbmV4dC5maW5kQ2hpbGQoMCwgbmV4dC5idWZmZXIubGVuZ3RoLCBkaXIsIGFmdGVyID09IC0xMDAwMDAwMDAgLyogTm9uZSAqLyA/IC0xMDAwMDAwMDAgLyogTm9uZSAqLyA6IGFmdGVyIC0gc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZShuZXcgQnVmZmVyQ29udGV4dChwYXJlbnQsIG5leHQsIGksIHN0YXJ0KSwgbnVsbCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmdWxsIHx8ICghbmV4dC50eXBlLmlzQW5vbnltb3VzIHx8IGhhc0NoaWxkKG5leHQpKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBuZXcgVHJlZU5vZGUobmV4dCwgc3RhcnQsIGksIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdWxsIHx8ICFpbm5lci50eXBlLmlzQW5vbnltb3VzID8gaW5uZXIgOiBpbm5lci5uZXh0Q2hpbGQoZGlyIDwgMCA/IG5leHQuY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDAsIGRpciwgYWZ0ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmdWxsIHx8ICFwYXJlbnQudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGkgPSBwYXJlbnQuaW5kZXggKyBkaXI7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgLTEwMDAwMDAwMCAvKiBOb25lICovKTsgfVxuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCh0aGlzLm5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIC0xMDAwMDAwMDAgLyogTm9uZSAqLyk7IH1cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgcG9zKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQodGhpcy5ub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDEsIC0xLCBwb3MpOyB9XG4gICAgbmV4dFNpZ25pZmljYW50UGFyZW50KCkge1xuICAgICAgICBsZXQgdmFsID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHZhbC50eXBlLmlzQW5vbnltb3VzICYmIHZhbC5fcGFyZW50KVxuICAgICAgICAgICAgdmFsID0gdmFsLl9wYXJlbnQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgbmV4dFNpYmxpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggKyAxLCAxLCAtMSkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgcHJldlNpYmxpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggLSAxLCAtMSwgLTEpIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IGN1cnNvcigpIHsgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMpOyB9XG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnNvci5tb3ZlVG8ocG9zLCBzaWRlKS5ub2RlO1xuICAgIH1cbiAgICBnZXRDaGlsZCh0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgbGV0IHIgPSBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICAgICAgcmV0dXJuIHIubGVuZ3RoID8gclswXSA6IG51bGw7XG4gICAgfVxuICAgIGdldENoaWxkcmVuKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMubm9kZS50b1N0cmluZygpOyB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZHJlbihub2RlLCB0eXBlLCBiZWZvcmUsIGFmdGVyKSB7XG4gICAgbGV0IGN1ciA9IG5vZGUuY3Vyc29yLCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIWN1ci5maXJzdENoaWxkKCkpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKGJlZm9yZSAhPSBudWxsKVxuICAgICAgICB3aGlsZSAoIWN1ci50eXBlLmlzKGJlZm9yZSkpXG4gICAgICAgICAgICBpZiAoIWN1ci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoYWZ0ZXIgIT0gbnVsbCAmJiBjdXIudHlwZS5pcyhhZnRlcikpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBpZiAoY3VyLnR5cGUuaXModHlwZSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaChjdXIubm9kZSk7XG4gICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICByZXR1cm4gYWZ0ZXIgPT0gbnVsbCA/IHJlc3VsdCA6IFtdO1xuICAgIH1cbn1cbmNsYXNzIEJ1ZmZlckNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgYnVmZmVyLCBpbmRleCwgc3RhcnQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB9XG59XG5jbGFzcyBCdWZmZXJOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBfcGFyZW50LCBpbmRleCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMudHlwZSA9IGNvbnRleHQuYnVmZmVyLnNldC50eXBlc1tjb250ZXh0LmJ1ZmZlci5idWZmZXJbaW5kZXhdXTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLnR5cGUubmFtZTsgfVxuICAgIGdldCBmcm9tKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LnN0YXJ0ICsgdGhpcy5jb250ZXh0LmJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDFdOyB9XG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LnN0YXJ0ICsgdGhpcy5jb250ZXh0LmJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDJdOyB9XG4gICAgY2hpbGQoZGlyLCBhZnRlcikge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgYWZ0ZXIgPT0gLTEwMDAwMDAwMCAvKiBOb25lICovID8gLTEwMDAwMDAwMCAvKiBOb25lICovIDogYWZ0ZXIgLSB0aGlzLmNvbnRleHQuc3RhcnQpO1xuICAgICAgICByZXR1cm4gaW5kZXggPCAwID8gbnVsbCA6IG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcywgaW5kZXgpO1xuICAgIH1cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY2hpbGQoMSwgLTEwMDAwMDAwMCAvKiBOb25lICovKTsgfVxuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkKC0xLCAtMTAwMDAwMDAwIC8qIE5vbmUgKi8pOyB9XG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMuY2hpbGQoMSwgcG9zKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgcG9zKTsgfVxuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgfHwgdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKTtcbiAgICB9XG4gICAgZXh0ZXJuYWxTaWJsaW5nKGRpcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gbnVsbCA6IHRoaXMuY29udGV4dC5wYXJlbnQubmV4dENoaWxkKHRoaXMuY29udGV4dC5pbmRleCArIGRpciwgZGlyLCAtMSk7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoYWZ0ZXIgPCAodGhpcy5fcGFyZW50ID8gYnVmZmVyLmJ1ZmZlclt0aGlzLl9wYXJlbnQuaW5kZXggKyAzXSA6IGJ1ZmZlci5idWZmZXIubGVuZ3RoKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlcm5hbFNpYmxpbmcoMSk7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBwYXJlbnRTdGFydCA9IHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5pbmRleCArIDQgOiAwO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSBwYXJlbnRTdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygtMSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYnVmZmVyLmZpbmRDaGlsZChwYXJlbnRTdGFydCwgdGhpcy5pbmRleCwgLTEsIC0xMDAwMDAwMDAgLyogTm9uZSAqLykpO1xuICAgIH1cbiAgICBnZXQgY3Vyc29yKCkgeyByZXR1cm4gbmV3IFRyZWVDdXJzb3IodGhpcyk7IH1cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yLm1vdmVUbyhwb3MsIHNpZGUpLm5vZGU7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCk7IH1cbiAgICBnZXRDaGlsZCh0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgbGV0IHIgPSBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICAgICAgcmV0dXJuIHIubGVuZ3RoID8gclswXSA6IG51bGw7XG4gICAgfVxuICAgIGdldENoaWxkcmVuKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgfVxufVxuLy8vIEEgdHJlZSBjdXJzb3Igb2JqZWN0IGZvY3VzZXMgb24gYSBnaXZlbiBub2RlIGluIGEgc3ludGF4IHRyZWUsIGFuZFxuLy8vIGFsbG93cyB5b3UgdG8gbW92ZSB0byBhZGphY2VudCBub2Rlcy5cbmNsYXNzIFRyZWVDdXJzb3Ige1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBmdWxsID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5mdWxsID0gZnVsbDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmJ1ZmZlck5vZGUgPSBudWxsO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RyZWUgPSBub2RlLmNvbnRleHQucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBuID0gbm9kZS5fcGFyZW50OyBuOyBuID0gbi5fcGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sudW5zaGlmdChuLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBTaG9ydGhhbmQgZm9yIGAudHlwZS5uYW1lYC5cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5uYW1lOyB9XG4gICAgeWllbGROb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLl90cmVlID0gbm9kZTtcbiAgICAgICAgdGhpcy50eXBlID0gbm9kZS50eXBlO1xuICAgICAgICB0aGlzLmZyb20gPSBub2RlLmZyb207XG4gICAgICAgIHRoaXMudG8gPSBub2RlLnRvO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgeWllbGRCdWYoaW5kZXgsIHR5cGUpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICBsZXQgeyBzdGFydCwgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZSB8fCBidWZmZXIuc2V0LnR5cGVzW2J1ZmZlci5idWZmZXJbaW5kZXhdXTtcbiAgICAgICAgdGhpcy5mcm9tID0gc3RhcnQgKyBidWZmZXIuYnVmZmVyW2luZGV4ICsgMV07XG4gICAgICAgIHRoaXMudG8gPSBzdGFydCArIGJ1ZmZlci5idWZmZXJbaW5kZXggKyAyXTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHlpZWxkKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgsIG5vZGUudHlwZSk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gdGhpcy5idWZmZXIuYnVmZmVyLmNoaWxkU3RyaW5nKHRoaXMuaW5kZXgpIDogdGhpcy5fdHJlZS50b1N0cmluZygpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZW50ZXIoZGlyLCBhZnRlcikge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGQodGhpcy5fdHJlZS5uZXh0Q2hpbGQoZGlyIDwgMCA/IHRoaXMuX3RyZWUubm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBhZnRlciwgdGhpcy5mdWxsKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBkaXIsIGFmdGVyID09IC0xMDAwMDAwMDAgLyogTm9uZSAqLyA/IC0xMDAwMDAwMDAgLyogTm9uZSAqLyA6IGFmdGVyIC0gdGhpcy5idWZmZXIuc3RhcnQpO1xuICAgICAgICBpZiAoaW5kZXggPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5pbmRleCk7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGluZGV4KTtcbiAgICB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGlzIG5vZGUncyBmaXJzdCBjaGlsZC4gV2hlbiB0aGlzIHJldHVybnNcbiAgICAvLy8gZmFsc2UsIHRoZSBub2RlIGhhcyBubyBjaGlsZCwgYW5kIHRoZSBjdXJzb3IgaGFzIG5vdCBiZWVuIG1vdmVkLlxuICAgIGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmVudGVyKDEsIC0xMDAwMDAwMDAgLyogTm9uZSAqLyk7IH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGxhc3QgY2hpbGQuXG4gICAgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5lbnRlcigtMSwgLTEwMDAwMDAwMCAvKiBOb25lICovKTsgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGZpcnN0IGNoaWxkIHRoYXQgc3RhcnRzIGF0IG9yIGFmdGVyIGBwb3NgLlxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmVudGVyKDEsIHBvcyk7IH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbGFzdCBjaGlsZCB0aGF0IGVuZHMgYXQgb3IgYmVmb3JlIGBwb3NgLlxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5lbnRlcigtMSwgcG9zKTsgfVxuICAgIC8vLyBNb3ZlIHRoZSBub2RlJ3MgcGFyZW50IG5vZGUsIGlmIHRoaXMgaXNuJ3QgdGhlIHRvcCBub2RlLlxuICAgIHBhcmVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZSh0aGlzLmZ1bGwgPyB0aGlzLl90cmVlLl9wYXJlbnQgOiB0aGlzLl90cmVlLnBhcmVudCk7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKHRoaXMuc3RhY2sucG9wKCkpO1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5mdWxsID8gdGhpcy5idWZmZXIucGFyZW50IDogdGhpcy5idWZmZXIucGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZShwYXJlbnQpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2libGluZyhkaXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5fdHJlZS5fcGFyZW50ID8gZmFsc2VcbiAgICAgICAgICAgICAgICA6IHRoaXMueWllbGQodGhpcy5fdHJlZS5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLl90cmVlLmluZGV4ICsgZGlyLCBkaXIsIC0xMDAwMDAwMDAgLyogTm9uZSAqLywgdGhpcy5mdWxsKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXIsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChkaXIgPCAwKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50U3RhcnQgPSBkIDwgMCA/IDAgOiB0aGlzLnN0YWNrW2RdICsgNDtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ICE9IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGJ1ZmZlci5maW5kQ2hpbGQocGFyZW50U3RhcnQsIHRoaXMuaW5kZXgsIC0xLCAtMTAwMDAwMDAwIC8qIE5vbmUgKi8pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICAgICAgaWYgKGFmdGVyIDwgKGQgPCAwID8gYnVmZmVyLmJ1ZmZlci5sZW5ndGggOiBidWZmZXIuYnVmZmVyW3RoaXMuc3RhY2tbZF0gKyAzXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoYWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkIDwgMCA/IHRoaXMueWllbGQodGhpcy5idWZmZXIucGFyZW50Lm5leHRDaGlsZCh0aGlzLmJ1ZmZlci5pbmRleCArIGRpciwgZGlyLCAtMTAwMDAwMDAwIC8qIE5vbmUgKi8sIHRoaXMuZnVsbCkpIDogZmFsc2U7XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRvIHRoaXMgbm9kZSdzIG5leHQgc2libGluZywgaWYgYW55LlxuICAgIG5leHRTaWJsaW5nKCkgeyByZXR1cm4gdGhpcy5zaWJsaW5nKDEpOyB9XG4gICAgLy8vIE1vdmUgdG8gdGhpcyBub2RlJ3MgcHJldmlvdXMgc2libGluZywgaWYgYW55LlxuICAgIHByZXZTaWJsaW5nKCkgeyByZXR1cm4gdGhpcy5zaWJsaW5nKC0xKTsgfVxuICAgIGF0TGFzdE5vZGUoZGlyKSB7XG4gICAgICAgIGxldCBpbmRleCwgcGFyZW50LCB7IGJ1ZmZlciB9ID0gdGhpcztcbiAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgICAgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA8IGJ1ZmZlci5idWZmZXIuYnVmZmVyLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluZGV4OyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIuYnVmZmVyLmJ1ZmZlcltpICsgM10gPCB0aGlzLmluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKHsgaW5kZXgsIHBhcmVudCB9ID0gYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICh7IGluZGV4LCBfcGFyZW50OiBwYXJlbnQgfSA9IHRoaXMuX3RyZWUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBwYXJlbnQ7IHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gcGFyZW50KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gaW5kZXggKyBkaXIsIGUgPSBkaXIgPCAwID8gLTEgOiBwYXJlbnQubm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgIT0gZTsgaSArPSBkaXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSBwYXJlbnQubm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mdWxsIHx8ICFjaGlsZC50eXBlLmlzQW5vbnltb3VzIHx8IGNoaWxkIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCBoYXNDaGlsZChjaGlsZCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbW92ZShkaXIpIHtcbiAgICAgICAgaWYgKHRoaXMuZW50ZXIoZGlyLCAtMTAwMDAwMDAwIC8qIE5vbmUgKi8pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNpYmxpbmcoZGlyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmF0TGFzdE5vZGUoZGlyKSB8fCAhdGhpcy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIE1vdmUgdG8gdGhlIG5leHQgbm9kZSBpbiBhXG4gICAgLy8vIFtwcmUtb3JkZXJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RyZWVfdHJhdmVyc2FsI1ByZS1vcmRlcl8oTkxSKSlcbiAgICAvLy8gdHJhdmVyc2FsLCBnb2luZyBmcm9tIGEgbm9kZSB0byBpdHMgZmlyc3QgY2hpbGQgb3IsIGlmIHRoZVxuICAgIC8vLyBjdXJyZW50IG5vZGUgaXMgZW1wdHksIGl0cyBuZXh0IHNpYmxpbmcgb3IgdGhlIG5leHQgc2libGluZyBvZlxuICAgIC8vLyB0aGUgZmlyc3QgcGFyZW50IG5vZGUgdGhhdCBoYXMgb25lLlxuICAgIG5leHQoKSB7IHJldHVybiB0aGlzLm1vdmUoMSk7IH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGEgbGFzdC10by1maXJzdCBwcmUtb3JkZXIgdHJhdmVyYWwuIEFcbiAgICAvLy8gbm9kZSBpcyBmb2xsb3dlZCBieSBpc3QgbGFzdCBjaGlsZCBvciwgaWYgaXQgaGFzIG5vbmUsIGl0c1xuICAgIC8vLyBwcmV2aW91cyBzaWJsaW5nIG9yIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnRcbiAgICAvLy8gbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgcHJldigpIHsgcmV0dXJuIHRoaXMubW92ZSgtMSk7IH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBpbm5lcm1vc3Qgbm9kZSB0aGF0IGNvdmVycyBgcG9zYC4gSWZcbiAgICAvLy8gYHNpZGVgIGlzIC0xLCBpdCB3aWxsIGVudGVyIG5vZGVzIHRoYXQgZW5kIGF0IGBwb3NgLiBJZiBpdCBpcyAxLFxuICAgIC8vLyBpdCB3aWxsIGVudGVyIG5vZGVzIHRoYXQgc3RhcnQgYXQgYHBvc2AuXG4gICAgbW92ZVRvKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgLy8gTW92ZSB1cCB0byBhIG5vZGUgdGhhdCBhY3R1YWxseSBob2xkcyB0aGUgcG9zaXRpb24sIGlmIHBvc3NpYmxlXG4gICAgICAgIHdoaWxlICh0aGlzLmZyb20gPT0gdGhpcy50byB8fFxuICAgICAgICAgICAgKHNpZGUgPCAxID8gdGhpcy5mcm9tID49IHBvcyA6IHRoaXMuZnJvbSA+IHBvcykgfHxcbiAgICAgICAgICAgIChzaWRlID4gLTEgPyB0aGlzLnRvIDw9IHBvcyA6IHRoaXMudG8gPCBwb3MpKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBUaGVuIHNjYW4gZG93biBpbnRvIGNoaWxkIG5vZGVzIGFzIGZhciBhcyBwb3NzaWJsZVxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoc2lkZSA8IDAgPyAhdGhpcy5jaGlsZEJlZm9yZShwb3MpIDogIXRoaXMuY2hpbGRBZnRlcihwb3MpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHRoaXMuZnJvbSA9PSB0aGlzLnRvIHx8XG4gICAgICAgICAgICAgICAgKHNpZGUgPCAxID8gdGhpcy5mcm9tID49IHBvcyA6IHRoaXMuZnJvbSA+IHBvcykgfHxcbiAgICAgICAgICAgICAgICAoc2lkZSA+IC0xID8gdGhpcy50byA8PSBwb3MgOiB0aGlzLnRvIDwgcG9zKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbc3ludGF4IG5vZGVdKCN0cmVlLlN5bnRheE5vZGUpIGF0IHRoZSBjdXJzb3IncyBjdXJyZW50XG4gICAgLy8vIHBvc2l0aW9uLlxuICAgIGdldCBub2RlKCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWU7XG4gICAgICAgIGxldCBjYWNoZSA9IHRoaXMuYnVmZmVyTm9kZSwgcmVzdWx0ID0gbnVsbCwgZGVwdGggPSAwO1xuICAgICAgICBpZiAoY2FjaGUgJiYgY2FjaGUuY29udGV4dCA9PSB0aGlzLmJ1ZmZlcikge1xuICAgICAgICAgICAgc2NhbjogZm9yIChsZXQgaW5kZXggPSB0aGlzLmluZGV4LCBkID0gdGhpcy5zdGFjay5sZW5ndGg7IGQgPj0gMDspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjID0gY2FjaGU7IGM7IGMgPSBjLl9wYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChjLmluZGV4ID09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5pbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXB0aCA9IGQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5zdGFja1stLWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBkZXB0aDsgaSA8IHRoaXMuc3RhY2subGVuZ3RoOyBpKyspXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQnVmZmVyTm9kZSh0aGlzLmJ1ZmZlciwgcmVzdWx0LCB0aGlzLnN0YWNrW2ldKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyTm9kZSA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuaW5kZXgpO1xuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBbdHJlZV0oI3RyZWUuVHJlZSkgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IG5vZGUsIGlmXG4gICAgLy8vIGFueS4gV2lsbCByZXR1cm4gbnVsbCB3aGVuIHRoZSBub2RlIGlzIGluIGEgW3RyZWVcbiAgICAvLy8gYnVmZmVyXSgjdHJlZS5UcmVlQnVmZmVyKS5cbiAgICBnZXQgdHJlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gbnVsbCA6IHRoaXMuX3RyZWUubm9kZTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNDaGlsZCh0cmVlKSB7XG4gICAgcmV0dXJuIHRyZWUuY2hpbGRyZW4uc29tZShjaCA9PiAhY2gudHlwZS5pc0Fub255bW91cyB8fCBjaCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHwgaGFzQ2hpbGQoY2gpKTtcbn1cbmNsYXNzIEZsYXRCdWZmZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlciwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB9XG4gICAgZ2V0IGlkKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDRdOyB9XG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDNdOyB9XG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAyXTsgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDFdOyB9XG4gICAgZ2V0IHBvcygpIHsgcmV0dXJuIHRoaXMuaW5kZXg7IH1cbiAgICBuZXh0KCkgeyB0aGlzLmluZGV4IC09IDQ7IH1cbiAgICBmb3JrKCkgeyByZXR1cm4gbmV3IEZsYXRCdWZmZXJDdXJzb3IodGhpcy5idWZmZXIsIHRoaXMuaW5kZXgpOyB9XG59XG5jb25zdCBCYWxhbmNlQnJhbmNoRmFjdG9yID0gODtcbmZ1bmN0aW9uIGJ1aWxkVHJlZShkYXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCB7IGJ1ZmZlciwgbm9kZVNldCwgdG9wSUQgPSAwLCBtYXhCdWZmZXJMZW5ndGggPSBEZWZhdWx0QnVmZmVyTGVuZ3RoLCByZXVzZWQgPSBbXSwgbWluUmVwZWF0VHlwZSA9IG5vZGVTZXQudHlwZXMubGVuZ3RoIH0gPSBkYXRhO1xuICAgIGxldCBjdXJzb3IgPSBBcnJheS5pc0FycmF5KGJ1ZmZlcikgPyBuZXcgRmxhdEJ1ZmZlckN1cnNvcihidWZmZXIsIGJ1ZmZlci5sZW5ndGgpIDogYnVmZmVyO1xuICAgIGxldCB0eXBlcyA9IG5vZGVTZXQudHlwZXM7XG4gICAgZnVuY3Rpb24gdGFrZU5vZGUocGFyZW50U3RhcnQsIG1pblBvcywgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5SZXBlYXQpIHtcbiAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgd2hpbGUgKGlkID09IGluUmVwZWF0KSB7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgKHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gc3RhcnQgLSBwYXJlbnRTdGFydDtcbiAgICAgICAgaWYgKHNpemUgPCAwKSB7IC8vIFJldXNlZCBub2RlXG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHJldXNlZFtpZF0pO1xuICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnRQb3MpO1xuICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2lkXSwgbm9kZSwgYnVmZmVyO1xuICAgICAgICBpZiAoZW5kIC0gc3RhcnQgPD0gbWF4QnVmZmVyTGVuZ3RoICYmIChidWZmZXIgPSBmaW5kQnVmZmVyU2l6ZShjdXJzb3IucG9zIC0gbWluUG9zLCBpblJlcGVhdCkpKSB7XG4gICAgICAgICAgICAvLyBTbWFsbCBlbm91Z2ggZm9yIGEgYnVmZmVyLCBhbmQgbm8gcmV1c2VkIG5vZGVzIGluc2lkZVxuICAgICAgICAgICAgbGV0IGRhdGEgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyLnNpemUgLSBidWZmZXIuc2tpcCk7XG4gICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIGJ1ZmZlci5zaXplLCBpbmRleCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpXG4gICAgICAgICAgICAgICAgaW5kZXggPSBjb3B5VG9CdWZmZXIoYnVmZmVyLnN0YXJ0LCBkYXRhLCBpbmRleCwgaW5SZXBlYXQpO1xuICAgICAgICAgICAgbm9kZSA9IG5ldyBUcmVlQnVmZmVyKGRhdGEsIGVuZCAtIGJ1ZmZlci5zdGFydCwgbm9kZVNldCwgaW5SZXBlYXQgPCAwID8gTm9kZVR5cGUubm9uZSA6IHR5cGVzW2luUmVwZWF0XSk7XG4gICAgICAgICAgICBzdGFydFBvcyA9IGJ1ZmZlci5zdGFydCAtIHBhcmVudFN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBNYWtlIGl0IGEgbm9kZVxuICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSBzaXplO1xuICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgICAgICAgICBsZXQgbG9jYWxJblJlcGVhdCA9IGlkID49IG1pblJlcGVhdFR5cGUgPyBpZCA6IC0xO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpXG4gICAgICAgICAgICAgICAgdGFrZU5vZGUoc3RhcnQsIGVuZFBvcywgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGxvY2FsSW5SZXBlYXQpO1xuICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5yZXZlcnNlKCk7XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+IC0xICYmIGxvY2FsQ2hpbGRyZW4ubGVuZ3RoID4gQmFsYW5jZUJyYW5jaEZhY3RvcilcbiAgICAgICAgICAgICAgICBub2RlID0gYmFsYW5jZVJhbmdlKHR5cGUsIHR5cGUsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCAwLCBsb2NhbENoaWxkcmVuLmxlbmd0aCwgMCwgbWF4QnVmZmVyTGVuZ3RoLCBlbmQgLSBzdGFydCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5ldyBUcmVlKHR5cGUsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBlbmQgLSBzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnRQb3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQnVmZmVyU2l6ZShtYXhTaXplLCBpblJlcGVhdCkge1xuICAgICAgICAvLyBTY2FuIHRocm91Z2ggdGhlIGJ1ZmZlciB0byBmaW5kIHByZXZpb3VzIHNpYmxpbmdzIHRoYXQgZml0XG4gICAgICAgIC8vIHRvZ2V0aGVyIGluIGEgVHJlZUJ1ZmZlciwgYW5kIGRvbid0IGNvbnRhaW4gYW55IHJldXNlZCBub2Rlc1xuICAgICAgICAvLyAod2hpY2ggY2FuJ3QgYmUgc3RvcmVkIGluIGEgYnVmZmVyKS5cbiAgICAgICAgLy8gSWYgYGluUmVwZWF0YCBpcyA+IC0xLCBpZ25vcmUgbm9kZSBib3VuZGFyaWVzIG9mIHRoYXQgdHlwZSBmb3JcbiAgICAgICAgLy8gbmVzdGluZywgYnV0IG1ha2Ugc3VyZSB0aGUgZW5kIGZhbGxzIGVpdGhlciBhdCB0aGUgc3RhcnRcbiAgICAgICAgLy8gKGBtYXhTaXplYCkgb3IgYmVmb3JlIHN1Y2ggYSBub2RlLlxuICAgICAgICBsZXQgZm9yayA9IGN1cnNvci5mb3JrKCk7XG4gICAgICAgIGxldCBzaXplID0gMCwgc3RhcnQgPSAwLCBza2lwID0gMCwgbWluU3RhcnQgPSBmb3JrLmVuZCAtIG1heEJ1ZmZlckxlbmd0aDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgc2l6ZTogMCwgc3RhcnQ6IDAsIHNraXA6IDAgfTtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgbWluUG9zID0gZm9yay5wb3MgLSBtYXhTaXplOyBmb3JrLnBvcyA+IG1pblBvczspIHtcbiAgICAgICAgICAgIC8vIFByZXRlbmQgbmVzdGVkIHJlcGVhdCBub2RlcyBvZiB0aGUgc2FtZSB0eXBlIGRvbid0IGV4aXN0XG4gICAgICAgICAgICBpZiAoZm9yay5pZCA9PSBpblJlcGVhdCkge1xuICAgICAgICAgICAgICAgIC8vIEV4Y2VwdCB0aGF0IHdlIHN0b3JlIHRoZSBjdXJyZW50IHN0YXRlIGFzIGEgdmFsaWQgcmV0dXJuXG4gICAgICAgICAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNpemUgPSBzaXplO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHJlc3VsdC5za2lwID0gc2tpcDtcbiAgICAgICAgICAgICAgICBza2lwICs9IDQ7XG4gICAgICAgICAgICAgICAgc2l6ZSArPSA0O1xuICAgICAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5vZGVTaXplID0gZm9yay5zaXplLCBzdGFydFBvcyA9IGZvcmsucG9zIC0gbm9kZVNpemU7XG4gICAgICAgICAgICBpZiAobm9kZVNpemUgPCAwIHx8IHN0YXJ0UG9zIDwgbWluUG9zIHx8IGZvcmsuc3RhcnQgPCBtaW5TdGFydClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBsb2NhbFNraXBwZWQgPSBmb3JrLmlkID49IG1pblJlcGVhdFR5cGUgPyA0IDogMDtcbiAgICAgICAgICAgIGxldCBub2RlU3RhcnQgPSBmb3JrLnN0YXJ0O1xuICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoZm9yay5wb3MgPiBzdGFydFBvcykge1xuICAgICAgICAgICAgICAgIGlmIChmb3JrLnNpemUgPCAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgIGlmIChmb3JrLmlkID49IG1pblJlcGVhdFR5cGUpXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2tpcHBlZCArPSA0O1xuICAgICAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgPSBub2RlU3RhcnQ7XG4gICAgICAgICAgICBzaXplICs9IG5vZGVTaXplO1xuICAgICAgICAgICAgc2tpcCArPSBsb2NhbFNraXBwZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluUmVwZWF0IDwgMCB8fCBzaXplID09IG1heFNpemUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuc2l6ZSA+IDQgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCwgaW5SZXBlYXQpIHtcbiAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgaWYgKGlkID09IGluUmVwZWF0KVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICBpZiAoc2l6ZSA+IDQpIHtcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gKHNpemUgLSA0KTtcbiAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKVxuICAgICAgICAgICAgICAgIGluZGV4ID0gY29weVRvQnVmZmVyKGJ1ZmZlclN0YXJ0LCBidWZmZXIsIGluZGV4LCBpblJlcGVhdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkIDwgbWluUmVwZWF0VHlwZSkgeyAvLyBEb24ndCBjb3B5IHJlcGVhdCBub2RlcyBpbnRvIGJ1ZmZlcnNcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IHN0YXJ0SW5kZXg7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBlbmQgLSBidWZmZXJTdGFydDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IHN0YXJ0IC0gYnVmZmVyU3RhcnQ7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBpZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IDApXG4gICAgICAgIHRha2VOb2RlKGRhdGEuc3RhcnQgfHwgMCwgMCwgY2hpbGRyZW4sIHBvc2l0aW9ucywgLTEpO1xuICAgIGxldCBsZW5ndGggPSAoX2EgPSBkYXRhLmxlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKGNoaWxkcmVuLmxlbmd0aCA/IHBvc2l0aW9uc1swXSArIGNoaWxkcmVuWzBdLmxlbmd0aCA6IDApO1xuICAgIHJldHVybiBuZXcgVHJlZSh0eXBlc1t0b3BJRF0sIGNoaWxkcmVuLnJldmVyc2UoKSwgcG9zaXRpb25zLnJldmVyc2UoKSwgbGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGJhbGFuY2VSYW5nZShvdXRlclR5cGUsIGlubmVyVHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgZnJvbSwgdG8sIHN0YXJ0LCBtYXhCdWZmZXJMZW5ndGgsIGxlbmd0aCkge1xuICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgaWYgKGxlbmd0aCA8PSBtYXhCdWZmZXJMZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucHVzaChwb3NpdGlvbnNbaV0gLSBzdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBtYXhDaGlsZCA9IE1hdGgubWF4KG1heEJ1ZmZlckxlbmd0aCwgTWF0aC5jZWlsKGxlbmd0aCAqIDEuNSAvIEJhbGFuY2VCcmFuY2hGYWN0b3IpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzspIHtcbiAgICAgICAgICAgIGxldCBncm91cEZyb20gPSBpLCBncm91cFN0YXJ0ID0gcG9zaXRpb25zW2ldO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgZm9yICg7IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRFbmQgPSBwb3NpdGlvbnNbaV0gKyBjaGlsZHJlbltpXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRFbmQgLSBncm91cFN0YXJ0ID4gbWF4Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT0gZ3JvdXBGcm9tICsgMSkge1xuICAgICAgICAgICAgICAgIGxldCBvbmx5ID0gY2hpbGRyZW5bZ3JvdXBGcm9tXTtcbiAgICAgICAgICAgICAgICBpZiAob25seSBpbnN0YW5jZW9mIFRyZWUgJiYgb25seS50eXBlID09IGlubmVyVHlwZSAmJiBvbmx5Lmxlbmd0aCA+IG1heENoaWxkIDw8IDEpIHsgLy8gVG9vIGJpZywgY29sbGFwc2VcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBvbmx5LmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2gob25seS5jaGlsZHJlbltqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5wdXNoKG9ubHkucG9zaXRpb25zW2pdICsgZ3JvdXBTdGFydCAtIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKG9ubHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSA9PSBncm91cEZyb20gKyAxKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGNoaWxkcmVuW2dyb3VwRnJvbV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGlubmVyID0gYmFsYW5jZVJhbmdlKGlubmVyVHlwZSwgaW5uZXJUeXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBncm91cEZyb20sIGksIGdyb3VwU3RhcnQsIG1heEJ1ZmZlckxlbmd0aCwgcG9zaXRpb25zW2kgLSAxXSArIGNoaWxkcmVuW2kgLSAxXS5sZW5ndGggLSBncm91cFN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXJUeXBlICE9IE5vZGVUeXBlLm5vbmUgJiYgIWNvbnRhaW5zVHlwZShpbm5lci5jaGlsZHJlbiwgaW5uZXJUeXBlKSlcbiAgICAgICAgICAgICAgICAgICAgaW5uZXIgPSBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBpbm5lci5jaGlsZHJlbiwgaW5uZXIucG9zaXRpb25zLCBpbm5lci5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChpbm5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5wdXNoKGdyb3VwU3RhcnQgLSBzdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmVlKG91dGVyVHlwZSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGxlbmd0aCk7XG59XG5mdW5jdGlvbiBjb250YWluc1R5cGUobm9kZXMsIHR5cGUpIHtcbiAgICBmb3IgKGxldCBlbHQgb2Ygbm9kZXMpXG4gICAgICAgIGlmIChlbHQudHlwZSA9PSB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8vIFRyZWUgZnJhZ21lbnRzIGFyZSB1c2VkIGR1cmluZyBbaW5jcmVtZW50YWxcbi8vLyBwYXJzaW5nXSgjbGV6ZXIuUGFyc2VPcHRpb25zLmZyYWdtZW50cykgdG8gdHJhY2sgcGFydHMgb2Ygb2xkXG4vLy8gdHJlZXMgdGhhdCBjYW4gYmUgcmV1c2VkIGluIGEgbmV3IHBhcnNlLiBBbiBhcnJheSBvZiBmcmFnbWVudHMgaXNcbi8vLyB1c2VkIHRvIHRyYWNrIHJlZ2lvbnMgb2YgYW4gb2xkIHRyZWUgd2hvc2Ugbm9kZXMgbWlnaHQgYmUgcmV1c2VkXG4vLy8gaW4gbmV3IHBhcnNlcy4gVXNlIHRoZSBzdGF0aWNcbi8vLyBbYGFwcGx5Q2hhbmdlc2BdKCN0cmVlLlRyZWVGcmFnbWVudF5hcHBseUNoYW5nZXMpIG1ldGhvZCB0byB1cGRhdGVcbi8vLyBmcmFnbWVudHMgZm9yIGRvY3VtZW50IGNoYW5nZXMuXG5jbGFzcyBUcmVlRnJhZ21lbnQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgc3RhcnQgb2YgdGhlIHVuY2hhbmdlZCByYW5nZSBwb2ludGVkIHRvIGJ5IHRoaXMgZnJhZ21lbnQuXG4gICAgLy8vIFRoaXMgcmVmZXJzIHRvIGFuIG9mZnNldCBpbiB0aGUgX3VwZGF0ZWRfIGRvY3VtZW50IChhcyBvcHBvc2VkXG4gICAgLy8vIHRvIHRoZSBvcmlnaW5hbCB0cmVlKS5cbiAgICBmcm9tLCBcbiAgICAvLy8gVGhlIGVuZCBvZiB0aGUgdW5jaGFuZ2VkIHJhbmdlLlxuICAgIHRvLCBcbiAgICAvLy8gVGhlIHRyZWUgdGhhdCB0aGlzIGZyYWdtZW50IGlzIGJhc2VkIG9uLlxuICAgIHRyZWUsIFxuICAgIC8vLyBUaGUgb2Zmc2V0IGJldHdlZW4gdGhlIGZyYWdtZW50J3MgdHJlZSBhbmQgdGhlIGRvY3VtZW50IHRoYXRcbiAgICAvLy8gdGhpcyBmcmFnbWVudCBjYW4gYmUgdXNlZCBhZ2FpbnN0LiBBZGQgdGhpcyB3aGVuIGdvaW5nIGZyb21cbiAgICAvLy8gZG9jdW1lbnQgdG8gdHJlZSBwb3NpdGlvbnMsIHN1YnRyYWN0IGl0IHRvIGdvIGZyb20gdHJlZSB0b1xuICAgIC8vLyBkb2N1bWVudCBwb3NpdGlvbnMuXG4gICAgb2Zmc2V0LCBvcGVuKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMub3BlbiA9IG9wZW47XG4gICAgfVxuICAgIGdldCBvcGVuU3RhcnQoKSB7IHJldHVybiAodGhpcy5vcGVuICYgMSAvKiBTdGFydCAqLykgPiAwOyB9XG4gICAgZ2V0IG9wZW5FbmQoKSB7IHJldHVybiAodGhpcy5vcGVuICYgMiAvKiBFbmQgKi8pID4gMDsgfVxuICAgIC8vLyBBcHBseSBhIHNldCBvZiBlZGl0cyB0byBhbiBhcnJheSBvZiBmcmFnbWVudHMsIHJlbW92aW5nIG9yXG4gICAgLy8vIHNwbGl0dGluZyBmcmFnbWVudHMgYXMgbmVjZXNzYXJ5IHRvIHJlbW92ZSBlZGl0ZWQgcmFuZ2VzLCBhbmRcbiAgICAvLy8gYWRqdXN0aW5nIG9mZnNldHMgZm9yIGZyYWdtZW50cyB0aGF0IG1vdmVkLlxuICAgIHN0YXRpYyBhcHBseUNoYW5nZXMoZnJhZ21lbnRzLCBjaGFuZ2VzLCBtaW5HYXAgPSAxMjgpIHtcbiAgICAgICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudHM7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGZJID0gMSwgbmV4dEYgPSBmcmFnbWVudHMubGVuZ3RoID8gZnJhZ21lbnRzWzBdIDogbnVsbDtcbiAgICAgICAgbGV0IGNJID0gMCwgcG9zID0gMCwgb2ZmID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5leHRDID0gY0kgPCBjaGFuZ2VzLmxlbmd0aCA/IGNoYW5nZXNbY0krK10gOiBudWxsO1xuICAgICAgICAgICAgbGV0IG5leHRQb3MgPSBuZXh0QyA/IG5leHRDLmZyb21BIDogMWU5O1xuICAgICAgICAgICAgaWYgKG5leHRQb3MgLSBwb3MgPj0gbWluR2FwKVxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0RiAmJiBuZXh0Ri5mcm9tIDwgbmV4dFBvcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3V0ID0gbmV4dEY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gY3V0LmZyb20gfHwgbmV4dFBvcyA8PSBjdXQudG8gfHwgb2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZkZyb20gPSBNYXRoLm1heChjdXQuZnJvbSwgcG9zKSAtIG9mZiwgZlRvID0gTWF0aC5taW4oY3V0LnRvLCBuZXh0UG9zKSAtIG9mZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1dCA9IGZGcm9tID49IGZUbyA/IG51bGwgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBUcmVlRnJhZ21lbnQoZkZyb20sIGZUbywgY3V0LnRyZWUsIGN1dC5vZmZzZXQgKyBvZmYsIChjSSA+IDAgPyAxIC8qIFN0YXJ0ICovIDogMCkgfCAobmV4dEMgPyAyIC8qIEVuZCAqLyA6IDApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY3V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRGLnRvID4gbmV4dFBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBuZXh0RiA9IGZJIDwgZnJhZ21lbnRzLmxlbmd0aCA/IGZyYWdtZW50c1tmSSsrXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0QylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBvcyA9IG5leHRDLnRvQTtcbiAgICAgICAgICAgIG9mZiA9IG5leHRDLnRvQSAtIG5leHRDLnRvQjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLy8gQ3JlYXRlIGEgc2V0IG9mIGZyYWdtZW50cyBmcm9tIGEgZnJlc2hseSBwYXJzZWQgdHJlZSwgb3IgdXBkYXRlXG4gICAgLy8vIGFuIGV4aXN0aW5nIHNldCBvZiBmcmFnbWVudHMgYnkgcmVwbGFjaW5nIHRoZSBvbmVzIHRoYXQgb3ZlcmxhcFxuICAgIC8vLyB3aXRoIGEgdHJlZSB3aXRoIGNvbnRlbnQgZnJvbSB0aGUgbmV3IHRyZWUuIFdoZW4gYHBhcnRpYWxgIGlzXG4gICAgLy8vIHRydWUsIHRoZSBwYXJzZSBpcyB0cmVhdGVkIGFzIGluY29tcGxldGUsIGFuZCB0aGUgdG9rZW4gYXQgaXRzXG4gICAgLy8vIGVuZCBpcyBub3QgaW5jbHVkZWQgaW4gW2BzYWZlVG9gXSgjdHJlZS5UcmVlRnJhZ21lbnQuc2FmZVRvKS5cbiAgICBzdGF0aWMgYWRkVHJlZSh0cmVlLCBmcmFnbWVudHMgPSBbXSwgcGFydGlhbCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbbmV3IFRyZWVGcmFnbWVudCgwLCB0cmVlLmxlbmd0aCwgdHJlZSwgMCwgcGFydGlhbCA/IDIgLyogRW5kICovIDogMCldO1xuICAgICAgICBmb3IgKGxldCBmIG9mIGZyYWdtZW50cylcbiAgICAgICAgICAgIGlmIChmLnRvID4gdHJlZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8gQ3JlYXRlcyBhbiBgSW5wdXRgIHRoYXQgaXMgYmFja2VkIGJ5IGEgc2luZ2xlLCBmbGF0IHN0cmluZy5cbmZ1bmN0aW9uIHN0cmluZ0lucHV0KGlucHV0KSB7IHJldHVybiBuZXcgU3RyaW5nSW5wdXQoaW5wdXQpOyB9XG5jbGFzcyBTdHJpbmdJbnB1dCB7XG4gICAgY29uc3RydWN0b3Ioc3RyaW5nLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB9XG4gICAgZ2V0KHBvcykge1xuICAgICAgICByZXR1cm4gcG9zIDwgMCB8fCBwb3MgPj0gdGhpcy5sZW5ndGggPyAtMSA6IHRoaXMuc3RyaW5nLmNoYXJDb2RlQXQocG9zKTtcbiAgICB9XG4gICAgbGluZUFmdGVyKHBvcykge1xuICAgICAgICBpZiAocG9zIDwgMClcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICBsZXQgZW5kID0gdGhpcy5zdHJpbmcuaW5kZXhPZihcIlxcblwiLCBwb3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UocG9zLCBlbmQgPCAwID8gdGhpcy5sZW5ndGggOiBNYXRoLm1pbihlbmQsIHRoaXMubGVuZ3RoKSk7XG4gICAgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20sIE1hdGgubWluKHRoaXMubGVuZ3RoLCB0bykpOyB9XG4gICAgY2xpcChhdCkgeyByZXR1cm4gbmV3IFN0cmluZ0lucHV0KHRoaXMuc3RyaW5nLCBhdCk7IH1cbn1cblxuZXhwb3J0IHsgRGVmYXVsdEJ1ZmZlckxlbmd0aCwgTm9kZVByb3AsIE5vZGVTZXQsIE5vZGVUeXBlLCBUcmVlLCBUcmVlQnVmZmVyLCBUcmVlQ3Vyc29yLCBUcmVlRnJhZ21lbnQsIHN0cmluZ0lucHV0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmVlLmVzLmpzLm1hcFxuIiwiaW1wb3J0IHsgRGVmYXVsdEJ1ZmZlckxlbmd0aCwgTm9kZVNldCwgTm9kZVR5cGUsIHN0cmluZ0lucHV0LCBUcmVlLCBUcmVlQnVmZmVyIH0gZnJvbSAnbGV6ZXItdHJlZSc7XG5leHBvcnQgeyBOb2RlUHJvcCwgTm9kZVNldCwgTm9kZVR5cGUsIFRyZWUsIFRyZWVDdXJzb3IgfSBmcm9tICdsZXplci10cmVlJztcblxuLy8vIEEgcGFyc2Ugc3RhY2suIFRoZXNlIGFyZSB1c2VkIGludGVybmFsbHkgYnkgdGhlIHBhcnNlciB0byB0cmFja1xuLy8vIHBhcnNpbmcgcHJvZ3Jlc3MuIFRoZXkgYWxzbyBwcm92aWRlIHNvbWUgcHJvcGVydGllcyBhbmQgbWV0aG9kc1xuLy8vIHRoYXQgZXh0ZXJuYWwgY29kZSBzdWNoIGFzIGEgdG9rZW5pemVyIGNhbiB1c2UgdG8gZ2V0IGluZm9ybWF0aW9uXG4vLy8gYWJvdXQgdGhlIHBhcnNlIHN0YXRlLlxuY2xhc3MgU3RhY2sge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gQSBncm91cCBvZiB2YWx1ZXMgdGhhdCB0aGUgc3RhY2sgd2lsbCBzaGFyZSB3aXRoIGFsbFxuICAgIC8vLyBzcGxpdCBpbnN0YW5jZXNcbiAgICAvLy9AaW50ZXJuYWxcbiAgICBjeCwgXG4gICAgLy8vIEhvbGRzIHN0YXRlLCBwb3MsIHZhbHVlIHN0YWNrIHBvcyAoMTUgYml0cyBhcnJheSBpbmRleCwgMTUgYml0c1xuICAgIC8vLyBidWZmZXIgaW5kZXgpIHRyaXBsZXRzIGZvciBhbGwgYnV0IHRoZSB0b3Agc3RhdGVcbiAgICAvLy8gQGludGVybmFsXG4gICAgc3RhY2ssIFxuICAgIC8vLyBUaGUgY3VycmVudCBwYXJzZSBzdGF0ZSBAaW50ZXJuYWxcbiAgICBzdGF0ZSwgXG4gICAgLy8gVGhlIHBvc2l0aW9uIGF0IHdoaWNoIHRoZSBuZXh0IHJlZHVjZSBzaG91bGQgdGFrZSBwbGFjZS4gVGhpc1xuICAgIC8vIGNhbiBiZSBsZXNzIHRoYW4gYHRoaXMucG9zYCB3aGVuIHNraXBwZWQgZXhwcmVzc2lvbnMgaGF2ZSBiZWVuXG4gICAgLy8gYWRkZWQgdG8gdGhlIHN0YWNrICh3aGljaCBzaG91bGQgYmUgbW92ZWQgb3V0c2lkZSBvZiB0aGUgbmV4dFxuICAgIC8vIHJlZHVjdGlvbilcbiAgICAvLy8gQGludGVybmFsXG4gICAgcmVkdWNlUG9zLCBcbiAgICAvLy8gVGhlIGlucHV0IHBvc2l0aW9uIHVwIHRvIHdoaWNoIHRoaXMgc3RhY2sgaGFzIHBhcnNlZC5cbiAgICBwb3MsIFxuICAgIC8vLyBUaGUgZHluYW1pYyBzY29yZSBvZiB0aGUgc3RhY2ssIGluY2x1ZGluZyBkeW5hbWljIHByZWNlZGVuY2VcbiAgICAvLy8gYW5kIGVycm9yLXJlY292ZXJ5IHBlbmFsdGllc1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzY29yZSwgXG4gICAgLy8gVGhlIG91dHB1dCBidWZmZXIuIEhvbGRzICh0eXBlLCBzdGFydCwgZW5kLCBzaXplKSBxdWFkc1xuICAgIC8vIHJlcHJlc2VudGluZyBub2RlcyBjcmVhdGVkIGJ5IHRoZSBwYXJzZXIsIHdoZXJlIGBzaXplYCBpc1xuICAgIC8vIGFtb3VudCBvZiBidWZmZXIgYXJyYXkgZW50cmllcyBjb3ZlcmVkIGJ5IHRoaXMgbm9kZS5cbiAgICAvLy8gQGludGVybmFsXG4gICAgYnVmZmVyLCBcbiAgICAvLyBUaGUgYmFzZSBvZmZzZXQgb2YgdGhlIGJ1ZmZlci4gV2hlbiBzdGFja3MgYXJlIHNwbGl0LCB0aGUgc3BsaXRcbiAgICAvLyBpbnN0YW5jZSBzaGFyZWQgdGhlIGJ1ZmZlciBoaXN0b3J5IHdpdGggaXRzIHBhcmVudCB1cCB0b1xuICAgIC8vIGBidWZmZXJCYXNlYCwgd2hpY2ggaXMgdGhlIGFic29sdXRlIG9mZnNldCAoaW5jbHVkaW5nIHRoZVxuICAgIC8vIG9mZnNldCBvZiBwcmV2aW91cyBzcGxpdHMpIGludG8gdGhlIGJ1ZmZlciBhdCB3aGljaCB0aGlzIHN0YWNrXG4gICAgLy8gc3RhcnRzIHdyaXRpbmcuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGJ1ZmZlckJhc2UsIFxuICAgIC8vIEEgcGFyZW50IHN0YWNrIGZyb20gd2hpY2ggdGhpcyB3YXMgc3BsaXQgb2ZmLCBpZiBhbnkuIFRoaXMgaXNcbiAgICAvLyBzZXQgdXAgc28gdGhhdCBpdCBhbHdheXMgcG9pbnRzIHRvIGEgc3RhY2sgdGhhdCBoYXMgc29tZVxuICAgIC8vIGFkZGl0aW9uYWwgYnVmZmVyIGNvbnRlbnQsIG5ldmVyIHRvIGEgc3RhY2sgd2l0aCBhbiBlcXVhbFxuICAgIC8vIGBidWZmZXJCYXNlYC5cbiAgICAvLy8gQGludGVybmFsXG4gICAgcGFyZW50KSB7XG4gICAgICAgIHRoaXMuY3ggPSBjeDtcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMucmVkdWNlUG9zID0gcmVkdWNlUG9zO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5zY29yZSA9IHNjb3JlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5idWZmZXJCYXNlID0gYnVmZmVyQmFzZTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBbJHt0aGlzLnN0YWNrLmZpbHRlcigoXywgaSkgPT4gaSAlIDMgPT0gMCkuY29uY2F0KHRoaXMuc3RhdGUpfV1AJHt0aGlzLnBvc30ke3RoaXMuc2NvcmUgPyBcIiFcIiArIHRoaXMuc2NvcmUgOiBcIlwifWA7XG4gICAgfVxuICAgIC8vIFN0YXJ0IGFuIGVtcHR5IHN0YWNrXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0YXRpYyBzdGFydChjeCwgc3RhdGUsIHBvcyA9IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFjayhjeCwgW10sIHN0YXRlLCBwb3MsIHBvcywgMCwgW10sIDAsIG51bGwpO1xuICAgIH1cbiAgICAvLyBQdXNoIGEgc3RhdGUgb250byB0aGUgc3RhY2ssIHRyYWNraW5nIGl0cyBzdGFydCBwb3NpdGlvbiBhcyB3ZWxsXG4gICAgLy8gYXMgdGhlIGJ1ZmZlciBiYXNlIGF0IHRoYXQgcG9pbnQuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHB1c2hTdGF0ZShzdGF0ZSwgc3RhcnQpIHtcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuc3RhdGUsIHN0YXJ0LCB0aGlzLmJ1ZmZlckJhc2UgKyB0aGlzLmJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgfVxuICAgIC8vIEFwcGx5IGEgcmVkdWNlIGFjdGlvblxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWR1Y2UoYWN0aW9uKSB7XG4gICAgICAgIGxldCBkZXB0aCA9IGFjdGlvbiA+PiAxOSAvKiBSZWR1Y2VEZXB0aFNoaWZ0ICovLCB0eXBlID0gYWN0aW9uICYgNjU1MzUgLyogVmFsdWVNYXNrICovO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMuY3g7XG4gICAgICAgIGxldCBkUHJlYyA9IHBhcnNlci5keW5hbWljUHJlY2VkZW5jZSh0eXBlKTtcbiAgICAgICAgaWYgKGRQcmVjKVxuICAgICAgICAgICAgdGhpcy5zY29yZSArPSBkUHJlYztcbiAgICAgICAgaWYgKGRlcHRoID09IDApIHtcbiAgICAgICAgICAgIC8vIFplcm8tZGVwdGggcmVkdWN0aW9ucyBhcmUgYSBzcGVjaWFsIGNhc2XigJR0aGV5IGFkZCBzdHVmZiB0b1xuICAgICAgICAgICAgLy8gdGhlIHN0YWNrIHdpdGhvdXQgcG9wcGluZyBhbnl0aGluZyBvZmYuXG4gICAgICAgICAgICBpZiAodHlwZSA8IHBhcnNlci5taW5SZXBlYXRUZXJtKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKHR5cGUsIHRoaXMucmVkdWNlUG9zLCB0aGlzLnJlZHVjZVBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShwYXJzZXIuZ2V0R290byh0aGlzLnN0YXRlLCB0eXBlLCB0cnVlKSwgdGhpcy5yZWR1Y2VQb3MpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgdGhlIGJhc2UgaW5kZXggaW50byBgdGhpcy5zdGFja2AsIGNvbnRlbnQgYWZ0ZXIgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBkcm9wcGVkLiBOb3RlIHRoYXQgd2l0aCBgU3RheUZsYWdgIHJlZHVjdGlvbnMgd2UgbmVlZCB0b1xuICAgICAgICAvLyBjb25zdW1lIHR3byBleHRyYSBmcmFtZXMgKHRoZSBkdW1teSBwYXJlbnQgbm9kZSBmb3IgdGhlIHNraXBwZWRcbiAgICAgICAgLy8gZXhwcmVzc2lvbiBhbmQgdGhlIHN0YXRlIHRoYXQgd2UnbGwgYmUgc3RheWluZyBpbiwgd2hpY2ggc2hvdWxkXG4gICAgICAgIC8vIGJlIG1vdmVkIHRvIGB0aGlzLnN0YXRlYCkuXG4gICAgICAgIGxldCBiYXNlID0gdGhpcy5zdGFjay5sZW5ndGggLSAoKGRlcHRoIC0gMSkgKiAzKSAtIChhY3Rpb24gJiAyNjIxNDQgLyogU3RheUZsYWcgKi8gPyA2IDogMCk7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMuc3RhY2tbYmFzZSAtIDJdO1xuICAgICAgICBsZXQgYnVmZmVyQmFzZSA9IHRoaXMuc3RhY2tbYmFzZSAtIDFdLCBjb3VudCA9IHRoaXMuYnVmZmVyQmFzZSArIHRoaXMuYnVmZmVyLmxlbmd0aCAtIGJ1ZmZlckJhc2U7XG4gICAgICAgIC8vIFN0b3JlIG5vcm1hbCB0ZXJtcyBvciBgUiAtPiBSIFJgIHJlcGVhdCByZWR1Y3Rpb25zXG4gICAgICAgIGlmICh0eXBlIDwgcGFyc2VyLm1pblJlcGVhdFRlcm0gfHwgKGFjdGlvbiAmIDEzMTA3MiAvKiBSZXBlYXRGbGFnICovKSkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IHBhcnNlci5zdGF0ZUZsYWcodGhpcy5zdGF0ZSwgMSAvKiBTa2lwcGVkICovKSA/IHRoaXMucG9zIDogdGhpcy5yZWR1Y2VQb3M7XG4gICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSh0eXBlLCBzdGFydCwgcG9zLCBjb3VudCArIDQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3Rpb24gJiAyNjIxNDQgLyogU3RheUZsYWcgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YWNrW2Jhc2VdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGJhc2VTdGF0ZUlEID0gdGhpcy5zdGFja1tiYXNlIC0gM107XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gcGFyc2VyLmdldEdvdG8oYmFzZVN0YXRlSUQsIHR5cGUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCA+IGJhc2UpXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgIH1cbiAgICAvLyBTaGlmdCBhIHZhbHVlIGludG8gdGhlIGJ1ZmZlclxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzdG9yZU5vZGUodGVybSwgc3RhcnQsIGVuZCwgc2l6ZSA9IDQsIGlzUmVkdWNlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRlcm0gPT0gMCAvKiBFcnIgKi8pIHsgLy8gVHJ5IHRvIG9taXQvbWVyZ2UgYWRqYWNlbnQgZXJyb3Igbm9kZXNcbiAgICAgICAgICAgIGxldCBjdXIgPSB0aGlzLCB0b3AgPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodG9wID09IDAgJiYgY3VyLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRvcCA9IGN1ci5idWZmZXJCYXNlIC0gY3VyLnBhcmVudC5idWZmZXJCYXNlO1xuICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9wID4gMCAmJiBjdXIuYnVmZmVyW3RvcCAtIDRdID09IDAgLyogRXJyICovICYmIGN1ci5idWZmZXJbdG9wIC0gMV0gPiAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PSBlbmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLmJ1ZmZlclt0b3AgLSAyXSA+PSBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBjdXIuYnVmZmVyW3RvcCAtIDJdID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNSZWR1Y2UgfHwgdGhpcy5wb3MgPT0gZW5kKSB7IC8vIFNpbXBsZSBjYXNlLCBqdXN0IGFwcGVuZFxuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0ZXJtLCBzdGFydCwgZW5kLCBzaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gVGhlcmUgbWF5IGJlIHNraXBwZWQgbm9kZXMgdGhhdCBoYXZlIHRvIGJlIG1vdmVkIGZvcndhcmRcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDAgJiYgdGhpcy5idWZmZXJbaW5kZXggLSA0XSAhPSAwIC8qIEVyciAqLylcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPiAwICYmIHRoaXMuYnVmZmVyW2luZGV4IC0gMl0gPiBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0aGlzIHJlY29yZCBmb3J3YXJkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4XSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gNF07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMV0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDNdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDJdID0gdGhpcy5idWZmZXJbaW5kZXggLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAzXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGluZGV4IC09IDQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaXplID4gNClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemUgLT0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleF0gPSB0ZXJtO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAxXSA9IHN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAyXSA9IGVuZDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgM10gPSBzaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFwcGx5IGEgc2hpZnQgYWN0aW9uXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNoaWZ0KGFjdGlvbiwgbmV4dCwgbmV4dEVuZCkge1xuICAgICAgICBpZiAoYWN0aW9uICYgMTMxMDcyIC8qIEdvdG9GbGFnICovKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShhY3Rpb24gJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi8sIHRoaXMucG9zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYWN0aW9uICYgMjYyMTQ0IC8qIFN0YXlGbGFnICovKSA9PSAwKSB7IC8vIFJlZ3VsYXIgc2hpZnRcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zLCBuZXh0U3RhdGUgPSBhY3Rpb24sIHsgcGFyc2VyIH0gPSB0aGlzLmN4O1xuICAgICAgICAgICAgaWYgKG5leHRFbmQgPiB0aGlzLnBvcyB8fCBuZXh0IDw9IHBhcnNlci5tYXhOb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBuZXh0RW5kO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VyLnN0YXRlRmxhZyhuZXh0U3RhdGUsIDEgLyogU2tpcHBlZCAqLykpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVkdWNlUG9zID0gbmV4dEVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKG5leHRTdGF0ZSwgc3RhcnQpO1xuICAgICAgICAgICAgaWYgKG5leHQgPD0gcGFyc2VyLm1heE5vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChuZXh0LCBzdGFydCwgbmV4dEVuZCwgNCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIFNoaWZ0LWFuZC1zdGF5LCB3aGljaCBtZWFucyB0aGlzIGlzIGEgc2tpcHBlZCB0b2tlblxuICAgICAgICAgICAgaWYgKG5leHQgPD0gdGhpcy5jeC5wYXJzZXIubWF4Tm9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKG5leHQsIHRoaXMucG9zLCBuZXh0RW5kLCA0KTtcbiAgICAgICAgICAgIHRoaXMucG9zID0gbmV4dEVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBcHBseSBhbiBhY3Rpb25cbiAgICAvLy8gQGludGVybmFsXG4gICAgYXBwbHkoYWN0aW9uLCBuZXh0LCBuZXh0RW5kKSB7XG4gICAgICAgIGlmIChhY3Rpb24gJiA2NTUzNiAvKiBSZWR1Y2VGbGFnICovKVxuICAgICAgICAgICAgdGhpcy5yZWR1Y2UoYWN0aW9uKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5zaGlmdChhY3Rpb24sIG5leHQsIG5leHRFbmQpO1xuICAgIH1cbiAgICAvLyBBZGQgYSBwcmVidWlsdCBub2RlIGludG8gdGhlIGJ1ZmZlci4gVGhpcyBtYXkgYmUgYSByZXVzZWQgbm9kZSBvclxuICAgIC8vIHRoZSByZXN1bHQgb2YgcnVubmluZyBhIG5lc3RlZCBwYXJzZXIuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHVzZU5vZGUodmFsdWUsIG5leHQpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5jeC5yZXVzZWQubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCB0aGlzLmN4LnJldXNlZFtpbmRleF0gIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY3gucmV1c2VkLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSB0aGlzLnBvcyA9IHN0YXJ0ICsgdmFsdWUubGVuZ3RoO1xuICAgICAgICB0aGlzLnB1c2hTdGF0ZShuZXh0LCBzdGFydCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2goaW5kZXgsIHN0YXJ0LCB0aGlzLnJlZHVjZVBvcywgLTEgLyogc2l6ZSA8IDAgbWVhbnMgdGhpcyBpcyBhIHJldXNlZCB2YWx1ZSAqLyk7XG4gICAgfVxuICAgIC8vIFNwbGl0IHRoZSBzdGFjay4gRHVlIHRvIHRoZSBidWZmZXIgc2hhcmluZyBhbmQgdGhlIGZhY3RcbiAgICAvLyB0aGF0IGB0aGlzLnN0YWNrYCB0ZW5kcyB0byBzdGF5IHF1aXRlIHNoYWxsb3csIHRoaXMgaXNuJ3QgdmVyeVxuICAgIC8vIGV4cGVuc2l2ZS5cbiAgICAvLy8gQGludGVybmFsXG4gICAgc3BsaXQoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzO1xuICAgICAgICBsZXQgb2ZmID0gcGFyZW50LmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIC8vIEJlY2F1c2UgdGhlIHRvcCBvZiB0aGUgYnVmZmVyIChhZnRlciB0aGlzLnBvcykgbWF5IGJlIG11dGF0ZWRcbiAgICAgICAgLy8gdG8gcmVvcmRlciByZWR1Y3Rpb25zIGFuZCBza2lwcGVkIHRva2VucywgYW5kIHNoYXJlZCBidWZmZXJzXG4gICAgICAgIC8vIHNob3VsZCBiZSBpbW11dGFibGUsIHRoaXMgY29waWVzIGFueSBvdXRzdGFuZGluZyBza2lwcGVkIHRva2Vuc1xuICAgICAgICAvLyB0byB0aGUgbmV3IGJ1ZmZlciwgYW5kIHB1dHMgdGhlIGJhc2UgcG9pbnRlciBiZWZvcmUgdGhlbS5cbiAgICAgICAgd2hpbGUgKG9mZiA+IDAgJiYgcGFyZW50LmJ1ZmZlcltvZmYgLSAyXSA+IHBhcmVudC5yZWR1Y2VQb3MpXG4gICAgICAgICAgICBvZmYgLT0gNDtcbiAgICAgICAgbGV0IGJ1ZmZlciA9IHBhcmVudC5idWZmZXIuc2xpY2Uob2ZmKSwgYmFzZSA9IHBhcmVudC5idWZmZXJCYXNlICsgb2ZmO1xuICAgICAgICAvLyBNYWtlIHN1cmUgcGFyZW50IHBvaW50cyB0byBhbiBhY3R1YWwgcGFyZW50IHdpdGggY29udGVudCwgaWYgdGhlcmUgaXMgc3VjaCBhIHBhcmVudC5cbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiBiYXNlID09IHBhcmVudC5idWZmZXJCYXNlKVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFjayh0aGlzLmN4LCB0aGlzLnN0YWNrLnNsaWNlKCksIHRoaXMuc3RhdGUsIHRoaXMucmVkdWNlUG9zLCB0aGlzLnBvcywgdGhpcy5zY29yZSwgYnVmZmVyLCBiYXNlLCBwYXJlbnQpO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gcmVjb3ZlciBmcm9tIGFuIGVycm9yIGJ5ICdkZWxldGluZycgKGlnbm9yaW5nKSBvbmUgdG9rZW4uXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlY292ZXJCeURlbGV0ZShuZXh0LCBuZXh0RW5kKSB7XG4gICAgICAgIGxldCBpc05vZGUgPSBuZXh0IDw9IHRoaXMuY3gucGFyc2VyLm1heE5vZGU7XG4gICAgICAgIGlmIChpc05vZGUpXG4gICAgICAgICAgICB0aGlzLnN0b3JlTm9kZShuZXh0LCB0aGlzLnBvcywgbmV4dEVuZCk7XG4gICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogRXJyICovLCB0aGlzLnBvcywgbmV4dEVuZCwgaXNOb2RlID8gOCA6IDQpO1xuICAgICAgICB0aGlzLnBvcyA9IHRoaXMucmVkdWNlUG9zID0gbmV4dEVuZDtcbiAgICAgICAgdGhpcy5zY29yZSAtPSAyMDAgLyogVG9rZW4gKi87XG4gICAgfVxuICAgIC8vLyBDaGVjayBpZiB0aGUgZ2l2ZW4gdGVybSB3b3VsZCBiZSBhYmxlIHRvIGJlIHNoaWZ0ZWQgKG9wdGlvbmFsbHlcbiAgICAvLy8gYWZ0ZXIgc29tZSByZWR1Y3Rpb25zKSBvbiB0aGlzIHN0YWNrLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yXG4gICAgLy8vIGV4dGVybmFsIHRva2VuaXplcnMgdGhhdCB3YW50IHRvIG1ha2Ugc3VyZSB0aGV5IG9ubHkgcHJvdmlkZSBhXG4gICAgLy8vIGdpdmVuIHRva2VuIHdoZW4gaXQgYXBwbGllcy5cbiAgICBjYW5TaGlmdCh0ZXJtKSB7XG4gICAgICAgIGZvciAobGV0IHNpbSA9IG5ldyBTaW11bGF0ZWRTdGFjayh0aGlzKTs7KSB7XG4gICAgICAgICAgICBsZXQgYWN0aW9uID0gdGhpcy5jeC5wYXJzZXIuc3RhdGVTbG90KHNpbS50b3AsIDQgLyogRGVmYXVsdFJlZHVjZSAqLykgfHwgdGhpcy5jeC5wYXJzZXIuaGFzQWN0aW9uKHNpbS50b3AsIHRlcm0pO1xuICAgICAgICAgICAgaWYgKChhY3Rpb24gJiA2NTUzNiAvKiBSZWR1Y2VGbGFnICovKSA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKGFjdGlvbiA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHNpbS5yZWR1Y2UoYWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gRmluZCB0aGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJ1bGUgdGhhdCBpcyBjdXJyZW50bHkgYmVpbmcgcGFyc2VkLlxuICAgIGdldCBydWxlU3RhcnQoKSB7XG4gICAgICAgIGZvciAobGV0IHN0YXRlID0gdGhpcy5zdGF0ZSwgYmFzZSA9IHRoaXMuc3RhY2subGVuZ3RoOzspIHtcbiAgICAgICAgICAgIGxldCBmb3JjZSA9IHRoaXMuY3gucGFyc2VyLnN0YXRlU2xvdChzdGF0ZSwgNSAvKiBGb3JjZWRSZWR1Y2UgKi8pO1xuICAgICAgICAgICAgaWYgKCEoZm9yY2UgJiA2NTUzNiAvKiBSZWR1Y2VGbGFnICovKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGJhc2UgLT0gMyAqIChmb3JjZSA+PiAxOSAvKiBSZWR1Y2VEZXB0aFNoaWZ0ICovKTtcbiAgICAgICAgICAgIGlmICgoZm9yY2UgJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi8pIDwgdGhpcy5jeC5wYXJzZXIubWluUmVwZWF0VGVybSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFja1tiYXNlICsgMV07XG4gICAgICAgICAgICBzdGF0ZSA9IHRoaXMuc3RhY2tbYmFzZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEZpbmQgdGhlIHN0YXJ0IHBvc2l0aW9uIG9mIGFuIGluc3RhbmNlIG9mIGFueSBvZiB0aGUgZ2l2ZW4gdGVybVxuICAgIC8vLyB0eXBlcywgb3IgcmV0dXJuIGBudWxsYCB3aGVuIG5vbmUgb2YgdGhlbSBhcmUgZm91bmQuXG4gICAgLy8vXG4gICAgLy8vICoqTm90ZToqKiB0aGlzIGlzIG9ubHkgcmVsaWFibGUgd2hlbiB0aGVyZSBpcyBhdCBsZWFzdCBzb21lXG4gICAgLy8vIHN0YXRlIHRoYXQgdW5hbWJpZ3VvdXNseSBtYXRjaGVzIHRoZSBnaXZlbiBydWxlIG9uIHRoZSBzdGFjay5cbiAgICAvLy8gSS5lLiBpZiB5b3UgaGF2ZSBhIGdyYW1tYXIgbGlrZSB0aGlzLCB3aGVyZSB0aGUgZGlmZmVyZW5jZVxuICAgIC8vLyBiZXR3ZWVuIGBhYCBhbmQgYGJgIGlzIG9ubHkgYXBwYXJlbnQgYXQgdGhlIHRoaXJkIHRva2VuOlxuICAgIC8vL1xuICAgIC8vLyAgICAgYSB7IGIgfCBjIH1cbiAgICAvLy8gICAgIGIgeyBcInhcIiBcInlcIiBcInhcIiB9XG4gICAgLy8vICAgICBjIHsgXCJ4XCIgXCJ5XCIgXCJ6XCIgfVxuICAgIC8vL1xuICAgIC8vLyBUaGVuIGEgcGFyc2Ugc3RhdGUgYWZ0ZXIgYFwieFwiYCB3aWxsIG5vdCByZWxpYWJseSB0ZWxsIHlvdSB0aGF0XG4gICAgLy8vIGBiYCBpcyBvbiB0aGUgc3RhY2suIFlvdSBfY2FuXyBwYXNzIGBbYiwgY11gIHRvIHJlbGlhYmx5IGNoZWNrXG4gICAgLy8vIGZvciBlaXRoZXIgb2YgdGhvc2UgdHdvIHJ1bGVzIChhc3N1bWluZyB0aGF0IGBhYCBpc24ndCBwYXJ0IG9mXG4gICAgLy8vIHNvbWUgcnVsZSB0aGF0IGluY2x1ZGVzIG90aGVyIHRoaW5ncyBzdGFydGluZyB3aXRoIGBcInhcImApLlxuICAgIC8vL1xuICAgIC8vLyBXaGVuIGBiZWZvcmVgIGlzIGdpdmVuLCB0aGlzIGtlZXBzIHNjYW5uaW5nIHVwIHRoZSBzdGFjayB1bnRpbFxuICAgIC8vLyBpdCBmaW5kcyBhIG1hdGNoIHRoYXQgc3RhcnRzIGJlZm9yZSB0aGF0IHBvc2l0aW9uLlxuICAgIHN0YXJ0T2YodHlwZXMsIGJlZm9yZSkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLnN0YXRlLCBmcmFtZSA9IHRoaXMuc3RhY2subGVuZ3RoLCB7IHBhcnNlciB9ID0gdGhpcy5jeDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGZvcmNlID0gcGFyc2VyLnN0YXRlU2xvdChzdGF0ZSwgNSAvKiBGb3JjZWRSZWR1Y2UgKi8pO1xuICAgICAgICAgICAgbGV0IGRlcHRoID0gZm9yY2UgPj4gMTkgLyogUmVkdWNlRGVwdGhTaGlmdCAqLywgdGVybSA9IGZvcmNlICYgNjU1MzUgLyogVmFsdWVNYXNrICovO1xuICAgICAgICAgICAgaWYgKHR5cGVzLmluZGV4T2YodGVybSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIGxldCBiYXNlID0gZnJhbWUgLSAoMyAqIChmb3JjZSA+PiAxOSAvKiBSZWR1Y2VEZXB0aFNoaWZ0ICovKSksIHBvcyA9IHRoaXMuc3RhY2tbYmFzZSArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChiZWZvcmUgPT0gbnVsbCB8fCBiZWZvcmUgPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJhbWUgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgZnJhbWUgLT0gMztcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IHRoaXMuc3RhY2tbZnJhbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJhbWUgLT0gMyAqIChkZXB0aCAtIDEpO1xuICAgICAgICAgICAgICAgIHN0YXRlID0gcGFyc2VyLmdldEdvdG8odGhpcy5zdGFja1tmcmFtZSAtIDNdLCB0ZXJtLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBcHBseSB1cCB0byBSZWNvdmVyLk1heE5leHQgcmVjb3ZlcnkgYWN0aW9ucyB0aGF0IGNvbmNlcHR1YWxseVxuICAgIC8vIGluc2VydHMgc29tZSBtaXNzaW5nIHRva2VuIG9yIHJ1bGUuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlY292ZXJCeUluc2VydChuZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA+PSAzMDAgLyogTWF4SW5zZXJ0U3RhY2tEZXB0aCAqLylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgbGV0IG5leHRTdGF0ZXMgPSB0aGlzLmN4LnBhcnNlci5uZXh0U3RhdGVzKHRoaXMuc3RhdGUpO1xuICAgICAgICBpZiAobmV4dFN0YXRlcy5sZW5ndGggPiA0IC8qIE1heE5leHQgKi8gfHwgdGhpcy5zdGFjay5sZW5ndGggPj0gMTIwIC8qIERhbXBlbkluc2VydFN0YWNrRGVwdGggKi8pIHtcbiAgICAgICAgICAgIGxldCBiZXN0ID0gbmV4dFN0YXRlcy5maWx0ZXIocyA9PiBzICE9IHRoaXMuc3RhdGUgJiYgdGhpcy5jeC5wYXJzZXIuaGFzQWN0aW9uKHMsIG5leHQpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDEyMCAvKiBEYW1wZW5JbnNlcnRTdGFja0RlcHRoICovKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBiZXN0Lmxlbmd0aCA8IDQgLyogTWF4TmV4dCAqLyAmJiBpIDwgbmV4dFN0YXRlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlc3QuaW5kZXhPZihuZXh0U3RhdGVzW2ldKSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0LnB1c2gobmV4dFN0YXRlc1tpXSk7XG4gICAgICAgICAgICBuZXh0U3RhdGVzID0gYmVzdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dFN0YXRlcy5sZW5ndGggJiYgcmVzdWx0Lmxlbmd0aCA8IDQgLyogTWF4TmV4dCAqLzsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobmV4dFN0YXRlc1tpXSA9PSB0aGlzLnN0YXRlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gdGhpcy5zcGxpdCgpO1xuICAgICAgICAgICAgc3RhY2suc3RvcmVOb2RlKDAgLyogRXJyICovLCBzdGFjay5wb3MsIHN0YWNrLnBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICBzdGFjay5wdXNoU3RhdGUobmV4dFN0YXRlc1tpXSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgc3RhY2suc2NvcmUgLT0gMjAwIC8qIFRva2VuICovO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEZvcmNlIGEgcmVkdWNlLCBpZiBwb3NzaWJsZS4gUmV0dXJuIGZhbHNlIGlmIHRoYXQgY2FuJ3RcbiAgICAvLyBiZSBkb25lLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBmb3JjZVJlZHVjZSgpIHtcbiAgICAgICAgbGV0IHJlZHVjZSA9IHRoaXMuY3gucGFyc2VyLnN0YXRlU2xvdCh0aGlzLnN0YXRlLCA1IC8qIEZvcmNlZFJlZHVjZSAqLyk7XG4gICAgICAgIGlmICgocmVkdWNlICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLykgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLmN4LnBhcnNlci52YWxpZEFjdGlvbih0aGlzLnN0YXRlLCByZWR1Y2UpKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIEVyciAqLywgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucmVkdWNlUG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuc2NvcmUgLT0gMTAwIC8qIFJlZHVjZSAqLztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZHVjZShyZWR1Y2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZvcmNlQWxsKCkge1xuICAgICAgICB3aGlsZSAoIXRoaXMuY3gucGFyc2VyLnN0YXRlRmxhZyh0aGlzLnN0YXRlLCAyIC8qIEFjY2VwdGluZyAqLykgJiYgdGhpcy5mb3JjZVJlZHVjZSgpKSB7IH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vLyBDaGVjayB3aGV0aGVyIHRoaXMgc3RhdGUgaGFzIG5vIGZ1cnRoZXIgYWN0aW9ucyAoYXNzdW1lZCB0byBiZSBhIGRpcmVjdCBkZXNjZW5kYW50IG9mIHRoZVxuICAgIC8vLyB0b3Agc3RhdGUsIHNpbmNlIGFueSBvdGhlciBzdGF0ZXMgbXVzdCBiZSBhYmxlIHRvIGNvbnRpbnVlXG4gICAgLy8vIHNvbWVob3cpLiBAaW50ZXJuYWxcbiAgICBnZXQgZGVhZEVuZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoICE9IDMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gdGhpcy5jeDtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5kYXRhW3BhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgMSAvKiBBY3Rpb25zICovKV0gPT0gNjU1MzUgLyogRW5kICovICYmXG4gICAgICAgICAgICAhcGFyc2VyLnN0YXRlU2xvdCh0aGlzLnN0YXRlLCA0IC8qIERlZmF1bHRSZWR1Y2UgKi8pO1xuICAgIH1cbiAgICAvLy8gUmVzdGFydCB0aGUgc3RhY2sgKHB1dCBpdCBiYWNrIGluIGl0cyBzdGFydCBzdGF0ZSkuIE9ubHkgc2FmZVxuICAgIC8vLyB3aGVuIHRoaXMuc3RhY2subGVuZ3RoID09IDMgKHN0YXRlIGlzIGRpcmVjdGx5IGJlbG93IHRoZSB0b3BcbiAgICAvLy8gc3RhdGUpLiBAaW50ZXJuYWxcbiAgICByZXN0YXJ0KCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGFja1swXTtcbiAgICAgICAgdGhpcy5zdGFjay5sZW5ndGggPSAwO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2FtZVN0YXRlKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9IG90aGVyLnN0YXRlIHx8IHRoaXMuc3RhY2subGVuZ3RoICE9IG90aGVyLnN0YWNrLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YWNrLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2tbaV0gIT0gb3RoZXIuc3RhY2tbaV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8vIEdldCB0aGUgcGFyc2VyIHVzZWQgYnkgdGhpcyBzdGFjay5cbiAgICBnZXQgcGFyc2VyKCkgeyByZXR1cm4gdGhpcy5jeC5wYXJzZXI7IH1cbiAgICAvLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gZGlhbGVjdCAoYnkgbnVtZXJpYyBJRCwgYXMgZXhwb3J0ZWQgZnJvbVxuICAgIC8vLyB0aGUgdGVybXMgZmlsZSkgaXMgZW5hYmxlZC5cbiAgICBkaWFsZWN0RW5hYmxlZChkaWFsZWN0SUQpIHsgcmV0dXJuIHRoaXMuY3gucGFyc2VyLmRpYWxlY3QuZmxhZ3NbZGlhbGVjdElEXTsgfVxufVxudmFyIFJlY292ZXI7XG4oZnVuY3Rpb24gKFJlY292ZXIpIHtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJUb2tlblwiXSA9IDIwMF0gPSBcIlRva2VuXCI7XG4gICAgUmVjb3ZlcltSZWNvdmVyW1wiUmVkdWNlXCJdID0gMTAwXSA9IFwiUmVkdWNlXCI7XG4gICAgUmVjb3ZlcltSZWNvdmVyW1wiTWF4TmV4dFwiXSA9IDRdID0gXCJNYXhOZXh0XCI7XG4gICAgUmVjb3ZlcltSZWNvdmVyW1wiTWF4SW5zZXJ0U3RhY2tEZXB0aFwiXSA9IDMwMF0gPSBcIk1heEluc2VydFN0YWNrRGVwdGhcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJEYW1wZW5JbnNlcnRTdGFja0RlcHRoXCJdID0gMTIwXSA9IFwiRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aFwiO1xufSkoUmVjb3ZlciB8fCAoUmVjb3ZlciA9IHt9KSk7XG4vLyBVc2VkIHRvIGNoZWFwbHkgcnVuIHNvbWUgcmVkdWN0aW9ucyB0byBzY2FuIGFoZWFkIHdpdGhvdXQgbXV0YXRpbmdcbi8vIGFuIGVudGlyZSBzdGFja1xuY2xhc3MgU2ltdWxhdGVkU3RhY2sge1xuICAgIGNvbnN0cnVjdG9yKHN0YWNrKSB7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgdGhpcy50b3AgPSBzdGFjay5zdGF0ZTtcbiAgICAgICAgdGhpcy5yZXN0ID0gc3RhY2suc3RhY2s7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gdGhpcy5yZXN0Lmxlbmd0aDtcbiAgICB9XG4gICAgcmVkdWNlKGFjdGlvbikge1xuICAgICAgICBsZXQgdGVybSA9IGFjdGlvbiAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLywgZGVwdGggPSBhY3Rpb24gPj4gMTkgLyogUmVkdWNlRGVwdGhTaGlmdCAqLztcbiAgICAgICAgaWYgKGRlcHRoID09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3QgPT0gdGhpcy5zdGFjay5zdGFjaylcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3QgPSB0aGlzLnJlc3Quc2xpY2UoKTtcbiAgICAgICAgICAgIHRoaXMucmVzdC5wdXNoKHRoaXMudG9wLCAwLCAwKTtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9mZnNldCAtPSAoZGVwdGggLSAxKSAqIDM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGdvdG8gPSB0aGlzLnN0YWNrLmN4LnBhcnNlci5nZXRHb3RvKHRoaXMucmVzdFt0aGlzLm9mZnNldCAtIDNdLCB0ZXJtLCB0cnVlKTtcbiAgICAgICAgdGhpcy50b3AgPSBnb3RvO1xuICAgIH1cbn1cbi8vIFRoaXMgaXMgZ2l2ZW4gdG8gYFRyZWUuYnVpbGRgIHRvIGJ1aWxkIGEgYnVmZmVyLCBhbmQgZW5jYXBzdWxhdGVzXG4vLyB0aGUgcGFyZW50LXN0YWNrLXdhbGtpbmcgbmVjZXNzYXJ5IHRvIHJlYWQgdGhlIG5vZGVzLlxuY2xhc3MgU3RhY2tCdWZmZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHN0YWNrLCBwb3MsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBzdGFjay5idWZmZXI7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IDApXG4gICAgICAgICAgICB0aGlzLm1heWJlTmV4dCgpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKHN0YWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2tCdWZmZXJDdXJzb3Ioc3RhY2ssIHN0YWNrLmJ1ZmZlckJhc2UgKyBzdGFjay5idWZmZXIubGVuZ3RoLCBzdGFjay5idWZmZXIubGVuZ3RoKTtcbiAgICB9XG4gICAgbWF5YmVOZXh0KCkge1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMuc3RhY2sucGFyZW50O1xuICAgICAgICBpZiAobmV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5zdGFjay5idWZmZXJCYXNlIC0gbmV4dC5idWZmZXJCYXNlO1xuICAgICAgICAgICAgdGhpcy5zdGFjayA9IG5leHQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5leHQuYnVmZmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSA0XTsgfVxuICAgIGdldCBzdGFydCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAzXTsgfVxuICAgIGdldCBlbmQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMl07IH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAxXTsgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHRoaXMuaW5kZXggLT0gNDtcbiAgICAgICAgdGhpcy5wb3MgLT0gNDtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT0gMClcbiAgICAgICAgICAgIHRoaXMubWF5YmVOZXh0KCk7XG4gICAgfVxuICAgIGZvcmsoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2tCdWZmZXJDdXJzb3IodGhpcy5zdGFjaywgdGhpcy5wb3MsIHRoaXMuaW5kZXgpO1xuICAgIH1cbn1cblxuLy8vIFRva2VuaXplcnMgd3JpdGUgdGhlIHRva2VucyB0aGV5IHJlYWQgaW50byBpbnN0YW5jZXMgb2YgdGhpcyBjbGFzcy5cbmNsYXNzIFRva2VuIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8vIFRoZSBzdGFydCBvZiB0aGUgdG9rZW4uIFRoaXMgaXMgc2V0IGJ5IHRoZSBwYXJzZXIsIGFuZCBzaG91bGQgbm90XG4gICAgICAgIC8vLyBiZSBtdXRhdGVkIGJ5IHRoZSB0b2tlbml6ZXIuXG4gICAgICAgIHRoaXMuc3RhcnQgPSAtMTtcbiAgICAgICAgLy8vIFRoaXMgc3RhcnRzIGF0IC0xLCBhbmQgc2hvdWxkIGJlIHVwZGF0ZWQgdG8gYSB0ZXJtIGlkIHdoZW4gYVxuICAgICAgICAvLy8gbWF0Y2hpbmcgdG9rZW4gaXMgZm91bmQuXG4gICAgICAgIHRoaXMudmFsdWUgPSAtMTtcbiAgICAgICAgLy8vIFdoZW4gc2V0dGluZyBgLnZhbHVlYCwgeW91IHNob3VsZCBhbHNvIHNldCBgLmVuZGAgdG8gdGhlIGVuZFxuICAgICAgICAvLy8gcG9zaXRpb24gb2YgdGhlIHRva2VuLiAoWW91J2xsIHVzdWFsbHkgd2FudCB0byB1c2UgdGhlIGBhY2NlcHRgXG4gICAgICAgIC8vLyBtZXRob2QuKVxuICAgICAgICB0aGlzLmVuZCA9IC0xO1xuICAgIH1cbiAgICAvLy8gQWNjZXB0IGEgdG9rZW4sIHNldHRpbmcgYHZhbHVlYCBhbmQgYGVuZGAgdG8gdGhlIGdpdmVuIHZhbHVlcy5cbiAgICBhY2NlcHQodmFsdWUsIGVuZCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgIH1cbn1cbi8vLyBAaW50ZXJuYWxcbmNsYXNzIFRva2VuR3JvdXAge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGlkKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICB9XG4gICAgdG9rZW4oaW5wdXQsIHRva2VuLCBzdGFjaykgeyByZWFkVG9rZW4odGhpcy5kYXRhLCBpbnB1dCwgdG9rZW4sIHN0YWNrLCB0aGlzLmlkKTsgfVxufVxuVG9rZW5Hcm91cC5wcm90b3R5cGUuY29udGV4dHVhbCA9IFRva2VuR3JvdXAucHJvdG90eXBlLmZhbGxiYWNrID0gVG9rZW5Hcm91cC5wcm90b3R5cGUuZXh0ZW5kID0gZmFsc2U7XG4vLy8gRXhwb3J0cyB0aGF0IGFyZSB1c2VkIGZvciBgQGV4dGVybmFsIHRva2Vuc2AgaW4gdGhlIGdyYW1tYXIgc2hvdWxkXG4vLy8gZXhwb3J0IGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG5jbGFzcyBFeHRlcm5hbFRva2VuaXplciB7XG4gICAgLy8vIENyZWF0ZSBhIHRva2VuaXplci4gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIHRoZSBmdW5jdGlvbiB0aGF0LFxuICAgIC8vLyBnaXZlbiBhbiBpbnB1dCBzdHJlYW0gYW5kIGEgdG9rZW4gb2JqZWN0LFxuICAgIC8vLyBbZmlsbHNdKCNsZXplci5Ub2tlbi5hY2NlcHQpIHRoZSB0b2tlbiBvYmplY3QgaWYgaXQgcmVjb2duaXplcyBhXG4gICAgLy8vIHRva2VuLiBgdG9rZW4uc3RhcnRgIHNob3VsZCBiZSB1c2VkIGFzIHRoZSBzdGFydCBwb3NpdGlvbiB0b1xuICAgIC8vLyBzY2FuIGZyb20uXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRva2VuLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLmNvbnRleHR1YWwgPSAhIW9wdGlvbnMuY29udGV4dHVhbDtcbiAgICAgICAgdGhpcy5mYWxsYmFjayA9ICEhb3B0aW9ucy5mYWxsYmFjaztcbiAgICAgICAgdGhpcy5leHRlbmQgPSAhIW9wdGlvbnMuZXh0ZW5kO1xuICAgIH1cbn1cbi8vIFRva2VuaXplciBkYXRhIGlzIHN0b3JlZCBhIGJpZyB1aW50MTYgYXJyYXkgY29udGFpbmluZywgZm9yIGVhY2hcbi8vIHN0YXRlOlxuLy9cbi8vICAtIEEgZ3JvdXAgYml0bWFzaywgaW5kaWNhdGluZyB3aGF0IHRva2VuIGdyb3VwcyBhcmUgcmVhY2hhYmxlIGZyb21cbi8vICAgIHRoaXMgc3RhdGUsIHNvIHRoYXQgcGF0aHMgdGhhdCBjYW4gb25seSBsZWFkIHRvIHRva2VucyBub3QgaW5cbi8vICAgIGFueSBvZiB0aGUgY3VycmVudCBncm91cHMgY2FuIGJlIGN1dCBvZmYgZWFybHkuXG4vL1xuLy8gIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBlbmQgb2YgdGhlIHN0YXRlJ3Mgc2VxdWVuY2Ugb2YgYWNjZXB0aW5nXG4vLyAgICB0b2tlbnNcbi8vXG4vLyAgLSBUaGUgbnVtYmVyIG9mIG91dGdvaW5nIGVkZ2VzIGZvciB0aGUgc3RhdGVcbi8vXG4vLyAgLSBUaGUgYWNjZXB0aW5nIHRva2VucywgYXMgKHRva2VuIGlkLCBncm91cCBtYXNrKSBwYWlyc1xuLy9cbi8vICAtIFRoZSBvdXRnb2luZyBlZGdlcywgYXMgKHN0YXJ0IGNoYXJhY3RlciwgZW5kIGNoYXJhY3Rlciwgc3RhdGVcbi8vICAgIGluZGV4KSB0cmlwbGVzLCB3aXRoIGVuZCBjaGFyYWN0ZXIgYmVpbmcgZXhjbHVzaXZlXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiBpbnRlcnByZXRzIHRoYXQgZGF0YSwgcnVubmluZyB0aHJvdWdoIGEgc3RyZWFtIGFzXG4vLyBsb25nIGFzIG5ldyBzdGF0ZXMgd2l0aCB0aGUgYSBtYXRjaGluZyBncm91cCBtYXNrIGNhbiBiZSByZWFjaGVkLFxuLy8gYW5kIHVwZGF0aW5nIGB0b2tlbmAgd2hlbiBpdCBtYXRjaGVzIGEgdG9rZW4uXG5mdW5jdGlvbiByZWFkVG9rZW4oZGF0YSwgaW5wdXQsIHRva2VuLCBzdGFjaywgZ3JvdXApIHtcbiAgICBsZXQgc3RhdGUgPSAwLCBncm91cE1hc2sgPSAxIDw8IGdyb3VwLCBkaWFsZWN0ID0gc3RhY2suY3gucGFyc2VyLmRpYWxlY3Q7XG4gICAgc2NhbjogZm9yIChsZXQgcG9zID0gdG9rZW4uc3RhcnQ7Oykge1xuICAgICAgICBpZiAoKGdyb3VwTWFzayAmIGRhdGFbc3RhdGVdKSA9PSAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBhY2NFbmQgPSBkYXRhW3N0YXRlICsgMV07XG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhpcyBzdGF0ZSBjYW4gbGVhZCB0byBhIHRva2VuIGluIHRoZSBjdXJyZW50IGdyb3VwXG4gICAgICAgIC8vIEFjY2VwdCB0b2tlbnMgaW4gdGhpcyBzdGF0ZSwgcG9zc2libHkgb3ZlcndyaXRpbmdcbiAgICAgICAgLy8gbG93ZXItcHJlY2VkZW5jZSAvIHNob3J0ZXIgdG9rZW5zXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGF0ZSArIDM7IGkgPCBhY2NFbmQ7IGkgKz0gMilcbiAgICAgICAgICAgIGlmICgoZGF0YVtpICsgMV0gJiBncm91cE1hc2spID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCB0ZXJtID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoZGlhbGVjdC5hbGxvd3ModGVybSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHRva2VuLnZhbHVlID09IC0xIHx8IHRva2VuLnZhbHVlID09IHRlcm0gfHwgc3RhY2suY3gucGFyc2VyLm92ZXJyaWRlcyh0ZXJtLCB0b2tlbi52YWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuLmFjY2VwdCh0ZXJtLCBwb3MpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0ID0gaW5wdXQuZ2V0KHBvcysrKTtcbiAgICAgICAgLy8gRG8gYSBiaW5hcnkgc2VhcmNoIG9uIHRoZSBzdGF0ZSdzIGVkZ2VzXG4gICAgICAgIGZvciAobGV0IGxvdyA9IDAsIGhpZ2ggPSBkYXRhW3N0YXRlICsgMl07IGxvdyA8IGhpZ2g7KSB7XG4gICAgICAgICAgICBsZXQgbWlkID0gKGxvdyArIGhpZ2gpID4+IDE7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBhY2NFbmQgKyBtaWQgKyAobWlkIDw8IDEpO1xuICAgICAgICAgICAgbGV0IGZyb20gPSBkYXRhW2luZGV4XSwgdG8gPSBkYXRhW2luZGV4ICsgMV07XG4gICAgICAgICAgICBpZiAobmV4dCA8IGZyb20pXG4gICAgICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPj0gdG8pXG4gICAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gZGF0YVtpbmRleCArIDJdO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlIHNjYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuXG4vLyBTZWUgbGV6ZXItZ2VuZXJhdG9yL3NyYy9lbmNvZGUudHMgZm9yIGNvbW1lbnRzIGFib3V0IHRoZSBlbmNvZGluZ1xuLy8gdXNlZCBoZXJlXG5mdW5jdGlvbiBkZWNvZGVBcnJheShpbnB1dCwgVHlwZSA9IFVpbnQxNkFycmF5KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgbGV0IGFycmF5ID0gbnVsbDtcbiAgICBmb3IgKGxldCBwb3MgPSAwLCBvdXQgPSAwOyBwb3MgPCBpbnB1dC5sZW5ndGg7KSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdChwb3MrKyksIHN0b3AgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChuZXh0ID09IDEyNiAvKiBCaWdWYWxDb2RlICovKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSA2NTUzNSAvKiBCaWdWYWwgKi87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCA+PSA5MiAvKiBHYXAyICovKVxuICAgICAgICAgICAgICAgIG5leHQtLTtcbiAgICAgICAgICAgIGlmIChuZXh0ID49IDM0IC8qIEdhcDEgKi8pXG4gICAgICAgICAgICAgICAgbmV4dC0tO1xuICAgICAgICAgICAgbGV0IGRpZ2l0ID0gbmV4dCAtIDMyIC8qIFN0YXJ0ICovO1xuICAgICAgICAgICAgaWYgKGRpZ2l0ID49IDQ2IC8qIEJhc2UgKi8pIHtcbiAgICAgICAgICAgICAgICBkaWdpdCAtPSA0NiAvKiBCYXNlICovO1xuICAgICAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgKz0gZGlnaXQ7XG4gICAgICAgICAgICBpZiAoc3RvcClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHZhbHVlICo9IDQ2IC8qIEJhc2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFycmF5KVxuICAgICAgICAgICAgYXJyYXlbb3V0KytdID0gdmFsdWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGFycmF5ID0gbmV3IFR5cGUodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbi8vIEZJWE1FIGZpbmQgc29tZSB3YXkgdG8gcmVkdWNlIHJlY292ZXJ5IHdvcmsgZG9uZSB3aGVuIHRoZSBpbnB1dFxuLy8gZG9lc24ndCBtYXRjaCB0aGUgZ3JhbW1hciBhdCBhbGwuXG4vLyBFbnZpcm9ubWVudCB2YXJpYWJsZSB1c2VkIHRvIGNvbnRyb2wgY29uc29sZSBvdXRwdXRcbmNvbnN0IHZlcmJvc2UgPSB0eXBlb2YgcHJvY2VzcyAhPSBcInVuZGVmaW5lZFwiICYmIC9cXGJwYXJzZVxcYi8udGVzdChwcm9jZXNzLmVudi5MT0cpO1xubGV0IHN0YWNrSURzID0gbnVsbDtcbmZ1bmN0aW9uIGN1dEF0KHRyZWUsIHBvcywgc2lkZSkge1xuICAgIGxldCBjdXJzb3IgPSB0cmVlLmN1cnNvcihwb3MpO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKCEoc2lkZSA8IDAgPyBjdXJzb3IuY2hpbGRCZWZvcmUocG9zKSA6IGN1cnNvci5jaGlsZEFmdGVyKHBvcykpKVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA8IDAgPyBjdXJzb3IudG8gPD0gcG9zIDogY3Vyc29yLmZyb20gPj0gcG9zKSAmJiAhY3Vyc29yLnR5cGUuaXNFcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZGUgPCAwID8gY3Vyc29yLnRvIC0gMSA6IGN1cnNvci5mcm9tICsgMTtcbiAgICAgICAgICAgICAgICBpZiAoc2lkZSA8IDAgPyBjdXJzb3IucHJldlNpYmxpbmcoKSA6IGN1cnNvci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnNvci5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZGUgPCAwID8gMCA6IHRyZWUubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIEZyYWdtZW50Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudHMpIHtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMuZnJhZ21lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnNhZmVGcm9tID0gLTE7XG4gICAgICAgIHRoaXMuc2FmZVRvID0gLTE7XG4gICAgICAgIHRoaXMudHJlZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGFydCA9IFtdO1xuICAgICAgICB0aGlzLmluZGV4ID0gW107XG4gICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgfVxuICAgIG5leHRGcmFnbWVudCgpIHtcbiAgICAgICAgbGV0IGZyID0gdGhpcy5mcmFnbWVudCA9IHRoaXMuaSA9PSB0aGlzLmZyYWdtZW50cy5sZW5ndGggPyBudWxsIDogdGhpcy5mcmFnbWVudHNbdGhpcy5pKytdO1xuICAgICAgICBpZiAoZnIpIHtcbiAgICAgICAgICAgIHRoaXMuc2FmZUZyb20gPSBmci5vcGVuU3RhcnQgPyBjdXRBdChmci50cmVlLCBmci5mcm9tICsgZnIub2Zmc2V0LCAxKSAtIGZyLm9mZnNldCA6IGZyLmZyb207XG4gICAgICAgICAgICB0aGlzLnNhZmVUbyA9IGZyLm9wZW5FbmQgPyBjdXRBdChmci50cmVlLCBmci50byArIGZyLm9mZnNldCwgLTEpIC0gZnIub2Zmc2V0IDogZnIudG87XG4gICAgICAgICAgICB3aGlsZSAodGhpcy50cmVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJlZXMucHVzaChmci50cmVlKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQucHVzaCgtZnIub2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXgucHVzaCgwKTtcbiAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gdGhpcy5zYWZlRnJvbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gMWU5O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGBwb3NgIG11c3QgYmUgPj0gYW55IHByZXZpb3VzbHkgZ2l2ZW4gYHBvc2AgZm9yIHRoaXMgY3Vyc29yXG4gICAgbm9kZUF0KHBvcykge1xuICAgICAgICBpZiAocG9zIDwgdGhpcy5uZXh0U3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgd2hpbGUgKHRoaXMuZnJhZ21lbnQgJiYgdGhpcy5zYWZlVG8gPD0gcG9zKVxuICAgICAgICAgICAgdGhpcy5uZXh0RnJhZ21lbnQoKTtcbiAgICAgICAgaWYgKCF0aGlzLmZyYWdtZW50KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gdGhpcy50cmVlcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKGxhc3QgPCAwKSB7IC8vIEVuZCBvZiB0cmVlXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLnRyZWVzW2xhc3RdLCBpbmRleCA9IHRoaXMuaW5kZXhbbGFzdF07XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gdG9wLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnBvcCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5leHQgPSB0b3AuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zdGFydFtsYXN0XSArIHRvcC5wb3NpdGlvbnNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0ID09IHBvcyAmJiBzdGFydCArIG5leHQubGVuZ3RoIDw9IHRoaXMuc2FmZVRvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0ID09IHBvcyAmJiBzdGFydCA+PSB0aGlzLnNhZmVGcm9tID8gbmV4dCA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4W2xhc3RdKys7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSBzdGFydCArIG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleFtsYXN0XSsrO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCArIG5leHQubGVuZ3RoID49IHBvcykgeyAvLyBFbnRlciB0aGlzIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnB1c2goc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnB1c2goMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgQ2FjaGVkVG9rZW4gZXh0ZW5kcyBUb2tlbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZXh0ZW5kZWQgPSAtMTtcbiAgICAgICAgdGhpcy5tYXNrID0gMDtcbiAgICB9XG4gICAgY2xlYXIoc3RhcnQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5leHRlbmRlZCA9IC0xO1xuICAgIH1cbn1cbmNvbnN0IGR1bW15VG9rZW4gPSBuZXcgVG9rZW47XG5jbGFzcyBUb2tlbkNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy5tYWluVG9rZW4gPSBkdW1teVRva2VuO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBwYXJzZXIudG9rZW5pemVycy5tYXAoXyA9PiBuZXcgQ2FjaGVkVG9rZW4pO1xuICAgIH1cbiAgICBnZXRBY3Rpb25zKHN0YWNrLCBpbnB1dCkge1xuICAgICAgICBsZXQgYWN0aW9uSW5kZXggPSAwO1xuICAgICAgICBsZXQgbWFpbiA9IG51bGw7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gc3RhY2suY3gsIHsgdG9rZW5pemVycyB9ID0gcGFyc2VyO1xuICAgICAgICBsZXQgbWFzayA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhY2suc3RhdGUsIDMgLyogVG9rZW5pemVyTWFzayAqLyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5pemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCgoMSA8PCBpKSAmIG1hc2spID09IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgdG9rZW5pemVyID0gdG9rZW5pemVyc1tpXSwgdG9rZW4gPSB0aGlzLnRva2Vuc1tpXTtcbiAgICAgICAgICAgIGlmIChtYWluICYmICF0b2tlbml6ZXIuZmFsbGJhY2spXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAodG9rZW5pemVyLmNvbnRleHR1YWwgfHwgdG9rZW4uc3RhcnQgIT0gc3RhY2sucG9zIHx8IHRva2VuLm1hc2sgIT0gbWFzaykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FjaGVkVG9rZW4odG9rZW4sIHRva2VuaXplciwgc3RhY2ssIGlucHV0KTtcbiAgICAgICAgICAgICAgICB0b2tlbi5tYXNrID0gbWFzaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSAhPSAwIC8qIEVyciAqLykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gYWN0aW9uSW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLmV4dGVuZGVkID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCB0b2tlbi5leHRlbmRlZCwgdG9rZW4uZW5kLCBhY3Rpb25JbmRleCk7XG4gICAgICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLnZhbHVlLCB0b2tlbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuaXplci5leHRlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uSW5kZXggPiBzdGFydEluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLmFjdGlvbnMubGVuZ3RoID4gYWN0aW9uSW5kZXgpXG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMucG9wKCk7XG4gICAgICAgIGlmICghbWFpbikge1xuICAgICAgICAgICAgbWFpbiA9IGR1bW15VG9rZW47XG4gICAgICAgICAgICBtYWluLnN0YXJ0ID0gc3RhY2sucG9zO1xuICAgICAgICAgICAgaWYgKHN0YWNrLnBvcyA9PSBpbnB1dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbWFpbi5hY2NlcHQoc3RhY2suY3gucGFyc2VyLmVvZlRlcm0sIHN0YWNrLnBvcyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWFpbi5hY2NlcHQoMCAvKiBFcnIgKi8sIHN0YWNrLnBvcyArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFpblRva2VuID0gbWFpbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9ucztcbiAgICB9XG4gICAgdXBkYXRlQ2FjaGVkVG9rZW4odG9rZW4sIHRva2VuaXplciwgc3RhY2ssIGlucHV0KSB7XG4gICAgICAgIHRva2VuLmNsZWFyKHN0YWNrLnBvcyk7XG4gICAgICAgIHRva2VuaXplci50b2tlbihpbnB1dCwgdG9rZW4sIHN0YWNrKTtcbiAgICAgICAgaWYgKHRva2VuLnZhbHVlID4gLTEpIHtcbiAgICAgICAgICAgIGxldCB7IHBhcnNlciB9ID0gc3RhY2suY3g7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlci5zcGVjaWFsaXplZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnNwZWNpYWxpemVkW2ldID09IHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZXIuc3BlY2lhbGl6ZXJzW2ldKGlucHV0LnJlYWQodG9rZW4uc3RhcnQsIHRva2VuLmVuZCksIHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA+PSAwICYmIHN0YWNrLmN4LnBhcnNlci5kaWFsZWN0LmFsbG93cyhyZXN1bHQgPj4gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocmVzdWx0ICYgMSkgPT0gMCAvKiBTcGVjaWFsaXplICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLnZhbHVlID0gcmVzdWx0ID4+IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4uZXh0ZW5kZWQgPSByZXN1bHQgPj4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YWNrLnBvcyA9PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRva2VuLmFjY2VwdChzdGFjay5jeC5wYXJzZXIuZW9mVGVybSwgc3RhY2sucG9zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRva2VuLmFjY2VwdCgwIC8qIEVyciAqLywgc3RhY2sucG9zICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHV0QWN0aW9uKGFjdGlvbiwgdG9rZW4sIGVuZCwgaW5kZXgpIHtcbiAgICAgICAgLy8gRG9uJ3QgYWRkIGR1cGxpY2F0ZSBhY3Rpb25zXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGlvbnNbaV0gPT0gYWN0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gYWN0aW9uO1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gZW5kO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLCBlbmQsIGluZGV4KSB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSBzdGFjaywgeyBwYXJzZXIgfSA9IHN0YWNrLmN4LCB7IGRhdGEgfSA9IHBhcnNlcjtcbiAgICAgICAgZm9yIChsZXQgc2V0ID0gMDsgc2V0IDwgMjsgc2V0KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBwYXJzZXIuc3RhdGVTbG90KHN0YXRlLCBzZXQgPyAyIC8qIFNraXAgKi8gOiAxIC8qIEFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT0gNjU1MzUgLyogRW5kICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2kgKyAxXSA9PSAxIC8qIE5leHQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBwYWlyKGRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSAwICYmIGRhdGFbaSArIDFdID09IDIgLyogT3RoZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnB1dEFjdGlvbihwYWlyKGRhdGEsIGkgKyAxKSwgdG9rZW4sIGVuZCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT0gdG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5wdXRBY3Rpb24ocGFpcihkYXRhLCBpICsgMSksIHRva2VuLCBlbmQsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufVxudmFyIFJlYztcbihmdW5jdGlvbiAoUmVjKSB7XG4gICAgUmVjW1JlY1tcIkRpc3RhbmNlXCJdID0gNV0gPSBcIkRpc3RhbmNlXCI7XG4gICAgUmVjW1JlY1tcIk1heFJlbWFpbmluZ1BlclN0ZXBcIl0gPSAzXSA9IFwiTWF4UmVtYWluaW5nUGVyU3RlcFwiO1xuICAgIFJlY1tSZWNbXCJNaW5CdWZmZXJMZW5ndGhQcnVuZVwiXSA9IDIwMF0gPSBcIk1pbkJ1ZmZlckxlbmd0aFBydW5lXCI7XG4gICAgUmVjW1JlY1tcIkZvcmNlUmVkdWNlTGltaXRcIl0gPSAxMF0gPSBcIkZvcmNlUmVkdWNlTGltaXRcIjtcbn0pKFJlYyB8fCAoUmVjID0ge30pKTtcbi8vLyBBIHBhcnNlIGNvbnRleHQgY2FuIGJlIHVzZWQgZm9yIHN0ZXAtYnktc3RlcCBwYXJzaW5nLiBBZnRlclxuLy8vIGNyZWF0aW5nIGl0LCB5b3UgcmVwZWF0ZWRseSBjYWxsIGAuYWR2YW5jZSgpYCB1bnRpbCBpdCByZXR1cm5zIGFcbi8vLyB0cmVlIHRvIGluZGljYXRlIGl0IGhhcyByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHBhcnNlLlxuY2xhc3MgUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgaW5wdXQsIHN0YXJ0UG9zLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuc3RhcnRQb3MgPSBzdGFydFBvcztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgLy8gVGhlIHBvc2l0aW9uIHRvIHdoaWNoIHRoZSBwYXJzZSBoYXMgYWR2YW5jZWQuXG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5yZWNvdmVyaW5nID0gMDtcbiAgICAgICAgdGhpcy5uZXh0U3RhY2tJRCA9IDB4MjY1NDtcbiAgICAgICAgdGhpcy5uZXN0ZWQgPSBudWxsO1xuICAgICAgICB0aGlzLm5lc3RFbmQgPSAwO1xuICAgICAgICB0aGlzLm5lc3RXcmFwID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXVzZWQgPSBbXTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBuZXcgVG9rZW5DYWNoZShwYXJzZXIpO1xuICAgICAgICB0aGlzLnRvcFRlcm0gPSBwYXJzZXIudG9wWzFdO1xuICAgICAgICB0aGlzLnN0YWNrcyA9IFtTdGFjay5zdGFydCh0aGlzLCBwYXJzZXIudG9wWzBdLCB0aGlzLnN0YXJ0UG9zKV07XG4gICAgICAgIGxldCBmcmFnbWVudHMgPSBjb250ZXh0ID09PSBudWxsIHx8IGNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRleHQuZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cyAmJiBmcmFnbWVudHMubGVuZ3RoID8gbmV3IEZyYWdtZW50Q3Vyc29yKGZyYWdtZW50cykgOiBudWxsO1xuICAgIH1cbiAgICAvLyBNb3ZlIHRoZSBwYXJzZXIgZm9yd2FyZC4gVGhpcyB3aWxsIHByb2Nlc3MgYWxsIHBhcnNlIHN0YWNrcyBhdFxuICAgIC8vIGB0aGlzLnBvc2AgYW5kIHRyeSB0byBhZHZhbmNlIHRoZW0gdG8gYSBmdXJ0aGVyIHBvc2l0aW9uLiBJZiBub1xuICAgIC8vIHN0YWNrIGZvciBzdWNoIGEgcG9zaXRpb24gaXMgZm91bmQsIGl0J2xsIHN0YXJ0IGVycm9yLXJlY292ZXJ5LlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGUgcGFyc2UgaXMgZmluaXNoZWQsIHRoaXMgd2lsbCByZXR1cm4gYSBzeW50YXggdHJlZS4gV2hlblxuICAgIC8vIG5vdCwgaXQgcmV0dXJucyBgbnVsbGAuXG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubmVzdGVkKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5uZXN0ZWQuYWR2YW5jZSgpO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLm5lc3RlZC5wb3M7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5pc2hOZXN0ZWQodGhpcy5zdGFja3NbMF0sIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXN0ZWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YWNrcyA9IHRoaXMuc3RhY2tzLCBwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgLy8gVGhpcyB3aWxsIGhvbGQgc3RhY2tzIGJleW9uZCBgcG9zYC5cbiAgICAgICAgbGV0IG5ld1N0YWNrcyA9IHRoaXMuc3RhY2tzID0gW107XG4gICAgICAgIGxldCBzdG9wcGVkLCBzdG9wcGVkVG9rZW5zO1xuICAgICAgICBsZXQgbWF5YmVOZXN0O1xuICAgICAgICAvLyBLZWVwIGFkdmFuY2luZyBhbnkgc3RhY2tzIGF0IGBwb3NgIHVudGlsIHRoZXkgZWl0aGVyIG1vdmVcbiAgICAgICAgLy8gZm9yd2FyZCBvciBjYW4ndCBiZSBhZHZhbmNlZC4gR2F0aGVyIHN0YWNrcyB0aGF0IGNhbid0IGJlXG4gICAgICAgIC8vIGFkdmFuY2VkIGZ1cnRoZXIgaW4gYHN0b3BwZWRgLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gc3RhY2tzW2ldLCBuZXN0O1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChzdGFjay5wb3MgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnB1c2goc3RhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXN0ID0gdGhpcy5jaGVja05lc3Qoc3RhY2spKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF5YmVOZXN0IHx8IG1heWJlTmVzdC5zdGFjay5zY29yZSA8IHN0YWNrLnNjb3JlKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVOZXN0ID0gbmVzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5hZHZhbmNlU3RhY2soc3RhY2ssIG5ld1N0YWNrcywgc3RhY2tzKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcHBlZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcHBlZFRva2VucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWQucHVzaChzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b2sgPSB0aGlzLnRva2Vucy5tYWluVG9rZW47XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWRUb2tlbnMucHVzaCh0b2sudmFsdWUsIHRvay5lbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWF5YmVOZXN0KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0TmVzdGVkKG1heWJlTmVzdCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5ld1N0YWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmaW5pc2hlZCA9IHN0b3BwZWQgJiYgZmluZEZpbmlzaGVkKHN0b3BwZWQpO1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrVG9UcmVlKGZpbmlzaGVkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlci5zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSAmJiBzdG9wcGVkKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlN0dWNrIHdpdGggdG9rZW4gXCIgKyB0aGlzLnBhcnNlci5nZXROYW1lKHRoaXMudG9rZW5zLm1haW5Ub2tlbi52YWx1ZSkpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIk5vIHBhcnNlIGF0IFwiICsgcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5yZWNvdmVyaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcmluZyA9IDUgLyogRGlzdGFuY2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcmluZyAmJiBzdG9wcGVkKSB7XG4gICAgICAgICAgICBsZXQgZmluaXNoZWQgPSB0aGlzLnJ1blJlY292ZXJ5KHN0b3BwZWQsIHN0b3BwZWRUb2tlbnMsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tUb1RyZWUoZmluaXNoZWQuZm9yY2VBbGwoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcmluZykge1xuICAgICAgICAgICAgbGV0IG1heFJlbWFpbmluZyA9IHRoaXMucmVjb3ZlcmluZyA9PSAxID8gMSA6IHRoaXMucmVjb3ZlcmluZyAqIDMgLyogTWF4UmVtYWluaW5nUGVyU3RlcCAqLztcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3MubGVuZ3RoID4gbWF4UmVtYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV3U3RhY2tzLmxlbmd0aCA+IG1heFJlbWFpbmluZylcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrcy5zb21lKHMgPT4gcy5yZWR1Y2VQb3MgPiBwb3MpKVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcmluZy0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld1N0YWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBQcnVuZSBzdGFja3MgdGhhdCBhcmUgaW4gdGhlIHNhbWUgc3RhdGUsIG9yIHRoYXQgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBydW5uaW5nIHdpdGhvdXQgc3BsaXR0aW5nIGZvciBhIHdoaWxlLCB0byBhdm9pZCBnZXR0aW5nIHN0dWNrXG4gICAgICAgICAgICAvLyB3aXRoIG11bHRpcGxlIHN1Y2Nlc3NmdWwgc3RhY2tzIHJ1bm5pbmcgZW5kbGVzc2x5IG9uLlxuICAgICAgICAgICAgb3V0ZXI6IGZvciAobGV0IGkgPSAwOyBpIDwgbmV3U3RhY2tzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IG5ld1N0YWNrc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBuZXdTdGFja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG90aGVyID0gbmV3U3RhY2tzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2suc2FtZVN0YXRlKG90aGVyKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2suYnVmZmVyLmxlbmd0aCA+IDIwMCAvKiBNaW5CdWZmZXJMZW5ndGhQcnVuZSAqLyAmJiBvdGhlci5idWZmZXIubGVuZ3RoID4gMjAwIC8qIE1pbkJ1ZmZlckxlbmd0aFBydW5lICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKChzdGFjay5zY29yZSAtIG90aGVyLnNjb3JlKSB8fCAoc3RhY2suYnVmZmVyLmxlbmd0aCAtIG90aGVyLmJ1ZmZlci5sZW5ndGgpKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3Muc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3Muc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgPSBuZXdTdGFja3NbMF0ucG9zO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG5ld1N0YWNrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3NbaV0ucG9zIDwgdGhpcy5wb3MpXG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBuZXdTdGFja3NbaV0ucG9zO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhbiB1cGRhdGVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIHN0YWNrLCBvciBudWxsIGlmIHRoZVxuICAgIC8vIHN0YWNrIGNhbid0IGFkdmFuY2Ugbm9ybWFsbHkuIFdoZW4gYHNwbGl0YCBhbmQgYHN0YWNrc2AgYXJlXG4gICAgLy8gZ2l2ZW4sIHN0YWNrcyBzcGxpdCBvZmYgYnkgYW1iaWd1b3VzIG9wZXJhdGlvbnMgd2lsbCBiZSBwdXNoZWQgdG9cbiAgICAvLyBgc3BsaXRgLCBvciBhZGRlZCB0byBgc3RhY2tzYCBpZiB0aGV5IG1vdmUgYHBvc2AgZm9yd2FyZC5cbiAgICBhZHZhbmNlU3RhY2soc3RhY2ssIHN0YWNrcywgc3BsaXQpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gc3RhY2sucG9zLCB7IGlucHV0LCBwYXJzZXIgfSA9IHRoaXM7XG4gICAgICAgIGxldCBiYXNlID0gdmVyYm9zZSA/IHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAtPiBcIiA6IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLmZyYWdtZW50cykge1xuICAgICAgICAgICAgZm9yIChsZXQgY2FjaGVkID0gdGhpcy5mcmFnbWVudHMubm9kZUF0KHN0YXJ0KTsgY2FjaGVkOykge1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMucGFyc2VyLm5vZGVTZXQudHlwZXNbY2FjaGVkLnR5cGUuaWRdID09IGNhY2hlZC50eXBlID8gcGFyc2VyLmdldEdvdG8oc3RhY2suc3RhdGUsIGNhY2hlZC50eXBlLmlkKSA6IC0xO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCA+IC0xICYmIGNhY2hlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sudXNlTm9kZShjYWNoZWQsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSByZXVzZSBvZiAke3BhcnNlci5nZXROYW1lKGNhY2hlZC50eXBlLmlkKX0pYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIShjYWNoZWQgaW5zdGFuY2VvZiBUcmVlKSB8fCBjYWNoZWQuY2hpbGRyZW4ubGVuZ3RoID09IDAgfHwgY2FjaGVkLnBvc2l0aW9uc1swXSA+IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IGNhY2hlZC5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIgaW5zdGFuY2VvZiBUcmVlKVxuICAgICAgICAgICAgICAgICAgICBjYWNoZWQgPSBpbm5lcjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBkZWZhdWx0UmVkdWNlID0gcGFyc2VyLnN0YXRlU2xvdChzdGFjay5zdGF0ZSwgNCAvKiBEZWZhdWx0UmVkdWNlICovKTtcbiAgICAgICAgaWYgKGRlZmF1bHRSZWR1Y2UgPiAwKSB7XG4gICAgICAgICAgICBzdGFjay5yZWR1Y2UoZGVmYXVsdFJlZHVjZSk7XG4gICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSBhbHdheXMtcmVkdWNlICR7cGFyc2VyLmdldE5hbWUoZGVmYXVsdFJlZHVjZSAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLyl9KWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFjdGlvbnMgPSB0aGlzLnRva2Vucy5nZXRBY3Rpb25zKHN0YWNrLCBpbnB1dCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgYWN0aW9uID0gYWN0aW9uc1tpKytdLCB0ZXJtID0gYWN0aW9uc1tpKytdLCBlbmQgPSBhY3Rpb25zW2krK107XG4gICAgICAgICAgICBsZXQgbGFzdCA9IGkgPT0gYWN0aW9ucy5sZW5ndGggfHwgIXNwbGl0O1xuICAgICAgICAgICAgbGV0IGxvY2FsU3RhY2sgPSBsYXN0ID8gc3RhY2sgOiBzdGFjay5zcGxpdCgpO1xuICAgICAgICAgICAgbG9jYWxTdGFjay5hcHBseShhY3Rpb24sIHRlcm0sIGVuZCk7XG4gICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKGxvY2FsU3RhY2spICsgYCAodmlhICR7KGFjdGlvbiAmIDY1NTM2IC8qIFJlZHVjZUZsYWcgKi8pID09IDAgPyBcInNoaWZ0XCJcbiAgICAgICAgICAgICAgICAgICAgOiBgcmVkdWNlIG9mICR7cGFyc2VyLmdldE5hbWUoYWN0aW9uICYgNjU1MzUgLyogVmFsdWVNYXNrICovKX1gfSBmb3IgJHtwYXJzZXIuZ2V0TmFtZSh0ZXJtKX0gQCAke3N0YXJ0fSR7bG9jYWxTdGFjayA9PSBzdGFjayA/IFwiXCIgOiBcIiwgc3BsaXRcIn0pYCk7XG4gICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGxvY2FsU3RhY2sucG9zID4gc3RhcnQpXG4gICAgICAgICAgICAgICAgc3RhY2tzLnB1c2gobG9jYWxTdGFjayk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc3BsaXQucHVzaChsb2NhbFN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEFkdmFuY2UgYSBnaXZlbiBzdGFjayBmb3J3YXJkIGFzIGZhciBhcyBpdCB3aWxsIGdvLiBSZXR1cm5zIHRoZVxuICAgIC8vIChwb3NzaWJseSB1cGRhdGVkKSBzdGFjayBpZiBpdCBnb3Qgc3R1Y2ssIG9yIG51bGwgaWYgaXQgbW92ZWRcbiAgICAvLyBmb3J3YXJkIGFuZCB3YXMgZ2l2ZW4gdG8gYHB1c2hTdGFja0RlZHVwYC5cbiAgICBhZHZhbmNlRnVsbHkoc3RhY2ssIG5ld1N0YWNrcykge1xuICAgICAgICBsZXQgcG9zID0gc3RhY2sucG9zO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbmVzdCA9IHRoaXMuY2hlY2tOZXN0KHN0YWNrKTtcbiAgICAgICAgICAgIGlmIChuZXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXN0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFkdmFuY2VTdGFjayhzdGFjaywgbnVsbCwgbnVsbCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHN0YWNrLnBvcyA+IHBvcykge1xuICAgICAgICAgICAgICAgIHB1c2hTdGFja0RlZHVwKHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJ1blJlY292ZXJ5KHN0YWNrcywgdG9rZW5zLCBuZXdTdGFja3MpIHtcbiAgICAgICAgbGV0IGZpbmlzaGVkID0gbnVsbCwgcmVzdGFydGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBtYXliZU5lc3Q7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhY2sgPSBzdGFja3NbaV0sIHRva2VuID0gdG9rZW5zW2kgPDwgMV0sIHRva2VuRW5kID0gdG9rZW5zWyhpIDw8IDEpICsgMV07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHZlcmJvc2UgPyB0aGlzLnN0YWNrSUQoc3RhY2spICsgXCIgLT4gXCIgOiBcIlwiO1xuICAgICAgICAgICAgaWYgKHN0YWNrLmRlYWRFbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdGFydGVkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YWNrLnJlc3RhcnQoKTtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAocmVzdGFydGVkKVwiKTtcbiAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYWR2YW5jZUZ1bGx5KHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lICE9PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVOZXN0ID0gZG9uZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZvcmNlID0gc3RhY2suc3BsaXQoKSwgZm9yY2VCYXNlID0gYmFzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBmb3JjZS5mb3JjZVJlZHVjZSgpICYmIGogPCAxMCAvKiBGb3JjZVJlZHVjZUxpbWl0ICovOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZm9yY2VCYXNlICsgdGhpcy5zdGFja0lEKGZvcmNlKSArIFwiICh2aWEgZm9yY2UtcmVkdWNlKVwiKTtcbiAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYWR2YW5jZUZ1bGx5KGZvcmNlLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lICE9PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVOZXN0ID0gZG9uZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBmb3JjZUJhc2UgPSB0aGlzLnN0YWNrSUQoZm9yY2UpICsgXCIgLT4gXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpbnNlcnQgb2Ygc3RhY2sucmVjb3ZlckJ5SW5zZXJ0KHRva2VuKSkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKGluc2VydCkgKyBcIiAodmlhIHJlY292ZXItaW5zZXJ0KVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VGdWxseShpbnNlcnQsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pbnB1dC5sZW5ndGggPiBzdGFjay5wb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5FbmQgPT0gc3RhY2sucG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuRW5kKys7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gMCAvKiBFcnIgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YWNrLnJlY292ZXJCeURlbGV0ZSh0b2tlbiwgdG9rZW5FbmQpO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSByZWNvdmVyLWRlbGV0ZSAke3RoaXMucGFyc2VyLmdldE5hbWUodG9rZW4pfSlgKTtcbiAgICAgICAgICAgICAgICBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFmaW5pc2hlZCB8fCBmaW5pc2hlZC5zY29yZSA8IHN0YWNrLnNjb3JlKSB7XG4gICAgICAgICAgICAgICAgZmluaXNoZWQgPSBzdGFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmluaXNoZWQpXG4gICAgICAgICAgICByZXR1cm4gZmluaXNoZWQ7XG4gICAgICAgIGlmIChtYXliZU5lc3QpXG4gICAgICAgICAgICBmb3IgKGxldCBzIG9mIHRoaXMuc3RhY2tzKVxuICAgICAgICAgICAgICAgIGlmIChzLnNjb3JlID4gbWF5YmVOZXN0LnN0YWNrLnNjb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heWJlTmVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICBpZiAobWF5YmVOZXN0KVxuICAgICAgICAgICAgdGhpcy5zdGFydE5lc3RlZChtYXliZU5lc3QpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZm9yY2VGaW5pc2goKSB7XG4gICAgICAgIGxldCBzdGFjayA9IHRoaXMuc3RhY2tzWzBdLnNwbGl0KCk7XG4gICAgICAgIGlmICh0aGlzLm5lc3RlZClcbiAgICAgICAgICAgIHRoaXMuZmluaXNoTmVzdGVkKHN0YWNrLCB0aGlzLm5lc3RlZC5mb3JjZUZpbmlzaCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tUb1RyZWUoc3RhY2suZm9yY2VBbGwoKSk7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgdGhlIHN0YWNrJ3MgYnVmZmVyIHRvIGEgc3ludGF4IHRyZWUuXG4gICAgc3RhY2tUb1RyZWUoc3RhY2ssIHBvcyA9IHN0YWNrLnBvcykge1xuICAgICAgICByZXR1cm4gVHJlZS5idWlsZCh7IGJ1ZmZlcjogU3RhY2tCdWZmZXJDdXJzb3IuY3JlYXRlKHN0YWNrKSxcbiAgICAgICAgICAgIG5vZGVTZXQ6IHRoaXMucGFyc2VyLm5vZGVTZXQsXG4gICAgICAgICAgICB0b3BJRDogdGhpcy50b3BUZXJtLFxuICAgICAgICAgICAgbWF4QnVmZmVyTGVuZ3RoOiB0aGlzLnBhcnNlci5idWZmZXJMZW5ndGgsXG4gICAgICAgICAgICByZXVzZWQ6IHRoaXMucmV1c2VkLFxuICAgICAgICAgICAgc3RhcnQ6IHRoaXMuc3RhcnRQb3MsXG4gICAgICAgICAgICBsZW5ndGg6IHBvcyAtIHRoaXMuc3RhcnRQb3MsXG4gICAgICAgICAgICBtaW5SZXBlYXRUeXBlOiB0aGlzLnBhcnNlci5taW5SZXBlYXRUZXJtIH0pO1xuICAgIH1cbiAgICBjaGVja05lc3Qoc3RhY2spIHtcbiAgICAgICAgbGV0IGluZm8gPSB0aGlzLnBhcnNlci5maW5kTmVzdGVkKHN0YWNrLnN0YXRlKTtcbiAgICAgICAgaWYgKCFpbmZvKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBzcGVjID0gaW5mby52YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzcGVjID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHNwZWMgPSBzcGVjKHRoaXMuaW5wdXQsIHN0YWNrKTtcbiAgICAgICAgcmV0dXJuIHNwZWMgPyB7IHN0YWNrLCBpbmZvLCBzcGVjIH0gOiBudWxsO1xuICAgIH1cbiAgICBzdGFydE5lc3RlZChuZXN0KSB7XG4gICAgICAgIGxldCB7IHN0YWNrLCBpbmZvLCBzcGVjIH0gPSBuZXN0O1xuICAgICAgICB0aGlzLnN0YWNrcyA9IFtzdGFja107XG4gICAgICAgIHRoaXMubmVzdEVuZCA9IHRoaXMuc2NhbkZvck5lc3RFbmQoc3RhY2ssIGluZm8uZW5kLCBzcGVjLmZpbHRlckVuZCk7XG4gICAgICAgIHRoaXMubmVzdFdyYXAgPSB0eXBlb2Ygc3BlYy53cmFwVHlwZSA9PSBcIm51bWJlclwiID8gdGhpcy5wYXJzZXIubm9kZVNldC50eXBlc1tzcGVjLndyYXBUeXBlXSA6IHNwZWMud3JhcFR5cGUgfHwgbnVsbDtcbiAgICAgICAgaWYgKHNwZWMuc3RhcnRQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5uZXN0ZWQgPSBzcGVjLnN0YXJ0UGFyc2UodGhpcy5pbnB1dC5jbGlwKHRoaXMubmVzdEVuZCksIHN0YWNrLnBvcywgdGhpcy5jb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoTmVzdGVkKHN0YWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzY2FuRm9yTmVzdEVuZChzdGFjaywgZW5kVG9rZW4sIGZpbHRlcikge1xuICAgICAgICBmb3IgKGxldCBwb3MgPSBzdGFjay5wb3M7IHBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoOyBwb3MrKykge1xuICAgICAgICAgICAgZHVtbXlUb2tlbi5zdGFydCA9IHBvcztcbiAgICAgICAgICAgIGR1bW15VG9rZW4udmFsdWUgPSAtMTtcbiAgICAgICAgICAgIGVuZFRva2VuLnRva2VuKHRoaXMuaW5wdXQsIGR1bW15VG9rZW4sIHN0YWNrKTtcbiAgICAgICAgICAgIGlmIChkdW1teVRva2VuLnZhbHVlID4gLTEgJiYgKCFmaWx0ZXIgfHwgZmlsdGVyKHRoaXMuaW5wdXQucmVhZChwb3MsIGR1bW15VG9rZW4uZW5kKSkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXQubGVuZ3RoO1xuICAgIH1cbiAgICBmaW5pc2hOZXN0ZWQoc3RhY2ssIHRyZWUpIHtcbiAgICAgICAgaWYgKHRoaXMubmVzdFdyYXApXG4gICAgICAgICAgICB0cmVlID0gbmV3IFRyZWUodGhpcy5uZXN0V3JhcCwgdHJlZSA/IFt0cmVlXSA6IFtdLCB0cmVlID8gWzBdIDogW10sIHRoaXMubmVzdEVuZCAtIHN0YWNrLnBvcyk7XG4gICAgICAgIGVsc2UgaWYgKCF0cmVlKVxuICAgICAgICAgICAgdHJlZSA9IG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIFtdLCBbXSwgdGhpcy5uZXN0RW5kIC0gc3RhY2sucG9zKTtcbiAgICAgICAgbGV0IGluZm8gPSB0aGlzLnBhcnNlci5maW5kTmVzdGVkKHN0YWNrLnN0YXRlKTtcbiAgICAgICAgc3RhY2sudXNlTm9kZSh0cmVlLCB0aGlzLnBhcnNlci5nZXRHb3RvKHN0YWNrLnN0YXRlLCBpbmZvLnBsYWNlaG9sZGVyLCB0cnVlKSk7XG4gICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSB1bm5lc3QpYCk7XG4gICAgfVxuICAgIHN0YWNrSUQoc3RhY2spIHtcbiAgICAgICAgbGV0IGlkID0gKHN0YWNrSURzIHx8IChzdGFja0lEcyA9IG5ldyBXZWFrTWFwKSkuZ2V0KHN0YWNrKTtcbiAgICAgICAgaWYgKCFpZClcbiAgICAgICAgICAgIHN0YWNrSURzLnNldChzdGFjaywgaWQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCh0aGlzLm5leHRTdGFja0lEKyspKTtcbiAgICAgICAgcmV0dXJuIGlkICsgc3RhY2s7XG4gICAgfVxufVxuZnVuY3Rpb24gcHVzaFN0YWNrRGVkdXAoc3RhY2ssIG5ld1N0YWNrcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3U3RhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBvdGhlciA9IG5ld1N0YWNrc1tpXTtcbiAgICAgICAgaWYgKG90aGVyLnBvcyA9PSBzdGFjay5wb3MgJiYgb3RoZXIuc2FtZVN0YXRlKHN0YWNrKSkge1xuICAgICAgICAgICAgaWYgKG5ld1N0YWNrc1tpXS5zY29yZSA8IHN0YWNrLnNjb3JlKVxuICAgICAgICAgICAgICAgIG5ld1N0YWNrc1tpXSA9IHN0YWNrO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5ld1N0YWNrcy5wdXNoKHN0YWNrKTtcbn1cbmNsYXNzIERpYWxlY3Qge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgZmxhZ3MsIGRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9XG4gICAgYWxsb3dzKHRlcm0pIHsgcmV0dXJuICF0aGlzLmRpc2FibGVkIHx8IHRoaXMuZGlzYWJsZWRbdGVybV0gPT0gMDsgfVxufVxuLy8vIEEgcGFyc2VyIGhvbGRzIHRoZSBwYXJzZSB0YWJsZXMgZm9yIGEgZ2l2ZW4gZ3JhbW1hciwgYXMgZ2VuZXJhdGVkXG4vLy8gYnkgYGxlemVyLWdlbmVyYXRvcmAuXG5jbGFzcyBQYXJzZXIge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy5idWZmZXJMZW5ndGggPSBEZWZhdWx0QnVmZmVyTGVuZ3RoO1xuICAgICAgICAvLy8gQGludGVybmFsXG4gICAgICAgIHRoaXMuc3RyaWN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubmV4dFN0YXRlQ2FjaGUgPSBbXTtcbiAgICAgICAgdGhpcy5jYWNoZWREaWFsZWN0ID0gbnVsbDtcbiAgICAgICAgaWYgKHNwZWMudmVyc2lvbiAhPSAxMyAvKiBWZXJzaW9uICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFBhcnNlciB2ZXJzaW9uICgke3NwZWMudmVyc2lvbn0pIGRvZXNuJ3QgbWF0Y2ggcnVudGltZSB2ZXJzaW9uICgkezEzIC8qIFZlcnNpb24gKi99KWApO1xuICAgICAgICBsZXQgdG9rZW5BcnJheSA9IGRlY29kZUFycmF5KHNwZWMudG9rZW5EYXRhKTtcbiAgICAgICAgbGV0IG5vZGVOYW1lcyA9IHNwZWMubm9kZU5hbWVzLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgdGhpcy5taW5SZXBlYXRUZXJtID0gbm9kZU5hbWVzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGVjLnJlcGVhdE5vZGVDb3VudDsgaSsrKVxuICAgICAgICAgICAgbm9kZU5hbWVzLnB1c2goXCJcIik7XG4gICAgICAgIGxldCBub2RlUHJvcHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlTmFtZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBub2RlUHJvcHMucHVzaChbXSk7XG4gICAgICAgIGZ1bmN0aW9uIHNldFByb3Aobm9kZUlELCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgbm9kZVByb3BzW25vZGVJRF0ucHVzaChbcHJvcCwgcHJvcC5kZXNlcmlhbGl6ZShTdHJpbmcodmFsdWUpKV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzcGVjLm5vZGVQcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHByb3BTcGVjIG9mIHNwZWMubm9kZVByb3BzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb3AgPSBwcm9wU3BlY1swXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHByb3BTcGVjLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBwcm9wU3BlY1tpKytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKG5leHQsIHByb3AsIHByb3BTcGVjW2krK10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gcHJvcFNwZWNbaSArIC1uZXh0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAtbmV4dDsgaiA+IDA7IGotLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKHByb3BTcGVjW2krK10sIHByb3AsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgdGhpcy5zcGVjaWFsaXplZCA9IG5ldyBVaW50MTZBcnJheShzcGVjLnNwZWNpYWxpemVkID8gc3BlYy5zcGVjaWFsaXplZC5sZW5ndGggOiAwKTtcbiAgICAgICAgdGhpcy5zcGVjaWFsaXplcnMgPSBbXTtcbiAgICAgICAgaWYgKHNwZWMuc3BlY2lhbGl6ZWQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwZWMuc3BlY2lhbGl6ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWNpYWxpemVkW2ldID0gc3BlYy5zcGVjaWFsaXplZFtpXS50ZXJtO1xuICAgICAgICAgICAgICAgIHRoaXMuc3BlY2lhbGl6ZXJzW2ldID0gc3BlYy5zcGVjaWFsaXplZFtpXS5nZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGVzID0gZGVjb2RlQXJyYXkoc3BlYy5zdGF0ZXMsIFVpbnQzMkFycmF5KTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGVjb2RlQXJyYXkoc3BlYy5zdGF0ZURhdGEpO1xuICAgICAgICB0aGlzLmdvdG8gPSBkZWNvZGVBcnJheShzcGVjLmdvdG8pO1xuICAgICAgICBsZXQgdG9wVGVybXMgPSBPYmplY3Qua2V5cyhzcGVjLnRvcFJ1bGVzKS5tYXAociA9PiBzcGVjLnRvcFJ1bGVzW3JdWzFdKTtcbiAgICAgICAgdGhpcy5ub2RlU2V0ID0gbmV3IE5vZGVTZXQobm9kZU5hbWVzLm1hcCgobmFtZSwgaSkgPT4gTm9kZVR5cGUuZGVmaW5lKHtcbiAgICAgICAgICAgIG5hbWU6IGkgPj0gdGhpcy5taW5SZXBlYXRUZXJtID8gdW5kZWZpbmVkIDogbmFtZSxcbiAgICAgICAgICAgIGlkOiBpLFxuICAgICAgICAgICAgcHJvcHM6IG5vZGVQcm9wc1tpXSxcbiAgICAgICAgICAgIHRvcDogdG9wVGVybXMuaW5kZXhPZihpKSA+IC0xLFxuICAgICAgICAgICAgZXJyb3I6IGkgPT0gMCxcbiAgICAgICAgICAgIHNraXBwZWQ6IHNwZWMuc2tpcHBlZE5vZGVzICYmIHNwZWMuc2tpcHBlZE5vZGVzLmluZGV4T2YoaSkgPiAtMVxuICAgICAgICB9KSkpO1xuICAgICAgICB0aGlzLm1heFRlcm0gPSBzcGVjLm1heFRlcm07XG4gICAgICAgIHRoaXMudG9rZW5pemVycyA9IHNwZWMudG9rZW5pemVycy5tYXAodmFsdWUgPT4gdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgPyBuZXcgVG9rZW5Hcm91cCh0b2tlbkFycmF5LCB2YWx1ZSkgOiB2YWx1ZSk7XG4gICAgICAgIHRoaXMudG9wUnVsZXMgPSBzcGVjLnRvcFJ1bGVzO1xuICAgICAgICB0aGlzLm5lc3RlZCA9IChzcGVjLm5lc3RlZCB8fCBbXSkubWFwKChbbmFtZSwgdmFsdWUsIGVuZFRva2VuLCBwbGFjZWhvbGRlcl0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWUsIHZhbHVlLCBlbmQ6IG5ldyBUb2tlbkdyb3VwKGRlY29kZUFycmF5KGVuZFRva2VuKSwgMCksIHBsYWNlaG9sZGVyIH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRpYWxlY3RzID0gc3BlYy5kaWFsZWN0cyB8fCB7fTtcbiAgICAgICAgdGhpcy5keW5hbWljUHJlY2VkZW5jZXMgPSBzcGVjLmR5bmFtaWNQcmVjZWRlbmNlcyB8fCBudWxsO1xuICAgICAgICB0aGlzLnRva2VuUHJlY1RhYmxlID0gc3BlYy50b2tlblByZWM7XG4gICAgICAgIHRoaXMudGVybU5hbWVzID0gc3BlYy50ZXJtTmFtZXMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5tYXhOb2RlID0gdGhpcy5ub2RlU2V0LnR5cGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5zdGF0ZXMubGVuZ3RoIC8gNiAvKiBTaXplICovOyBpIDwgbDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5uZXh0U3RhdGVDYWNoZVtpXSA9IG51bGw7XG4gICAgICAgIHRoaXMuZGlhbGVjdCA9IHRoaXMucGFyc2VEaWFsZWN0KCk7XG4gICAgICAgIHRoaXMudG9wID0gdGhpcy50b3BSdWxlc1tPYmplY3Qua2V5cyh0aGlzLnRvcFJ1bGVzKVswXV07XG4gICAgfVxuICAgIC8vLyBQYXJzZSBhIGdpdmVuIHN0cmluZyBvciBzdHJlYW0uXG4gICAgcGFyc2UoaW5wdXQsIHN0YXJ0UG9zID0gMCwgY29udGV4dCA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGlucHV0ID0gc3RyaW5nSW5wdXQoaW5wdXQpO1xuICAgICAgICBsZXQgY3ggPSBuZXcgUGFyc2UodGhpcywgaW5wdXQsIHN0YXJ0UG9zLCBjb250ZXh0KTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGRvbmUgPSBjeC5hZHZhbmNlKCk7XG4gICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gU3RhcnQgYW4gaW5jcmVtZW50YWwgcGFyc2UuXG4gICAgc3RhcnRQYXJzZShpbnB1dCwgc3RhcnRQb3MgPSAwLCBjb250ZXh0ID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgaW5wdXQgPSBzdHJpbmdJbnB1dChpbnB1dCk7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2UodGhpcywgaW5wdXQsIHN0YXJ0UG9zLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLy8vIEdldCBhIGdvdG8gdGFibGUgZW50cnkgQGludGVybmFsXG4gICAgZ2V0R290byhzdGF0ZSwgdGVybSwgbG9vc2UgPSBmYWxzZSkge1xuICAgICAgICBsZXQgdGFibGUgPSB0aGlzLmdvdG87XG4gICAgICAgIGlmICh0ZXJtID49IHRhYmxlWzBdKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSB0YWJsZVt0ZXJtICsgMV07Oykge1xuICAgICAgICAgICAgbGV0IGdyb3VwVGFnID0gdGFibGVbcG9zKytdLCBsYXN0ID0gZ3JvdXBUYWcgJiAxO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRhYmxlW3BvcysrXTtcbiAgICAgICAgICAgIGlmIChsYXN0ICYmIGxvb3NlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICBmb3IgKGxldCBlbmQgPSBwb3MgKyAoZ3JvdXBUYWcgPj4gMSk7IHBvcyA8IGVuZDsgcG9zKyspXG4gICAgICAgICAgICAgICAgaWYgKHRhYmxlW3Bvc10gPT0gc3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIENoZWNrIGlmIHRoaXMgc3RhdGUgaGFzIGFuIGFjdGlvbiBmb3IgYSBnaXZlbiB0ZXJtaW5hbCBAaW50ZXJuYWxcbiAgICBoYXNBY3Rpb24oc3RhdGUsIHRlcm1pbmFsKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICBmb3IgKGxldCBzZXQgPSAwOyBzZXQgPCAyOyBzZXQrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCBzZXQgPyAyIC8qIFNraXAgKi8gOiAxIC8qIEFjdGlvbnMgKi8pLCBuZXh0OzsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKChuZXh0ID0gZGF0YVtpXSkgPT0gNjU1MzUgLyogRW5kICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2kgKyAxXSA9PSAxIC8qIE5leHQgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gZGF0YVtpID0gcGFpcihkYXRhLCBpICsgMildO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkYXRhW2kgKyAxXSA9PSAyIC8qIE90aGVyICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhaXIoZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT0gdGVybWluYWwgfHwgbmV4dCA9PSAwIC8qIEVyciAqLylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhaXIoZGF0YSwgaSArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc3RhdGVTbG90KHN0YXRlLCBzbG90KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlc1soc3RhdGUgKiA2IC8qIFNpemUgKi8pICsgc2xvdF07XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzdGF0ZUZsYWcoc3RhdGUsIGZsYWcpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnN0YXRlU2xvdChzdGF0ZSwgMCAvKiBGbGFncyAqLykgJiBmbGFnKSA+IDA7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBmaW5kTmVzdGVkKHN0YXRlKSB7XG4gICAgICAgIGxldCBmbGFncyA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCAwIC8qIEZsYWdzICovKTtcbiAgICAgICAgcmV0dXJuIGZsYWdzICYgNCAvKiBTdGFydE5lc3QgKi8gPyB0aGlzLm5lc3RlZFtmbGFncyA+PiAxMCAvKiBOZXN0U2hpZnQgKi9dIDogbnVsbDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHZhbGlkQWN0aW9uKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgICAgaWYgKGFjdGlvbiA9PSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgNCAvKiBEZWZhdWx0UmVkdWNlICovKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDEgLyogQWN0aW9ucyAqLyk7OyBpICs9IDMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaV0gPT0gNjU1MzUgLyogRW5kICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpICsgMV0gPT0gMSAvKiBOZXh0ICovKVxuICAgICAgICAgICAgICAgICAgICBpID0gcGFpcih0aGlzLmRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gcGFpcih0aGlzLmRhdGEsIGkgKyAxKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBzdGF0ZXMgdGhhdCBjYW4gZm9sbG93IHRoaXMgb25lIHRocm91Z2ggc2hpZnQgYWN0aW9ucyBvclxuICAgIC8vLyBnb3RvIGp1bXBzLiBAaW50ZXJuYWxcbiAgICBuZXh0U3RhdGVzKHN0YXRlKSB7XG4gICAgICAgIGxldCBjYWNoZWQgPSB0aGlzLm5leHRTdGF0ZUNhY2hlW3N0YXRlXTtcbiAgICAgICAgaWYgKGNhY2hlZClcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCAxIC8qIEFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09IDY1NTM1IC8qIEVuZCAqLykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaSArIDFdID09IDEgLyogTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIodGhpcy5kYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGhpcy5kYXRhW2kgKyAyXSAmICg2NTUzNiAvKiBSZWR1Y2VGbGFnICovID4+IDE2KSkgPT0gMCAmJiByZXN1bHQuaW5kZXhPZih0aGlzLmRhdGFbaSArIDFdKSA8IDApXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5kYXRhW2kgKyAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRhYmxlID0gdGhpcy5nb3RvLCBtYXggPSB0YWJsZVswXTtcbiAgICAgICAgZm9yIChsZXQgdGVybSA9IDA7IHRlcm0gPCBtYXg7IHRlcm0rKykge1xuICAgICAgICAgICAgZm9yIChsZXQgcG9zID0gdGFibGVbdGVybSArIDFdOzspIHtcbiAgICAgICAgICAgICAgICBsZXQgZ3JvdXBUYWcgPSB0YWJsZVtwb3MrK10sIHRhcmdldCA9IHRhYmxlW3BvcysrXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlbmQgPSBwb3MgKyAoZ3JvdXBUYWcgPj4gMSk7IHBvcyA8IGVuZDsgcG9zKyspXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWJsZVtwb3NdID09IHN0YXRlICYmIHJlc3VsdC5pbmRleE9mKHRhcmdldCkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBUYWcgJiAxKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0U3RhdGVDYWNoZVtzdGF0ZV0gPSByZXN1bHQ7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBvdmVycmlkZXModG9rZW4sIHByZXYpIHtcbiAgICAgICAgbGV0IGlQcmV2ID0gZmluZE9mZnNldCh0aGlzLmRhdGEsIHRoaXMudG9rZW5QcmVjVGFibGUsIHByZXYpO1xuICAgICAgICByZXR1cm4gaVByZXYgPCAwIHx8IGZpbmRPZmZzZXQodGhpcy5kYXRhLCB0aGlzLnRva2VuUHJlY1RhYmxlLCB0b2tlbikgPCBpUHJldjtcbiAgICB9XG4gICAgLy8vIENvbmZpZ3VyZSB0aGUgcGFyc2VyLiBSZXR1cm5zIGEgbmV3IHBhcnNlciBpbnN0YW5jZSB0aGF0IGhhcyB0aGVcbiAgICAvLy8gZ2l2ZW4gc2V0dGluZ3MgbW9kaWZpZWQuIFNldHRpbmdzIG5vdCBwcm92aWRlZCBpbiBgY29uZmlnYCBhcmVcbiAgICAvLy8ga2VwdCBmcm9tIHRoZSBvcmlnaW5hbCBwYXJzZXIuXG4gICAgY29uZmlndXJlKGNvbmZpZykge1xuICAgICAgICAvLyBIaWRlb3VzIHJlZmxlY3Rpb24tYmFzZWQga2x1ZGdlIHRvIG1ha2UgaXQgZWFzeSB0byBjcmVhdGUgYVxuICAgICAgICAvLyBzbGlnaHRseSBtb2RpZmllZCBjb3B5IG9mIGEgcGFyc2VyLlxuICAgICAgICBsZXQgY29weSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShQYXJzZXIucHJvdG90eXBlKSwgdGhpcyk7XG4gICAgICAgIGlmIChjb25maWcucHJvcHMpXG4gICAgICAgICAgICBjb3B5Lm5vZGVTZXQgPSB0aGlzLm5vZGVTZXQuZXh0ZW5kKC4uLmNvbmZpZy5wcm9wcyk7XG4gICAgICAgIGlmIChjb25maWcudG9wKSB7XG4gICAgICAgICAgICBsZXQgaW5mbyA9IHRoaXMudG9wUnVsZXNbY29uZmlnLnRvcF07XG4gICAgICAgICAgICBpZiAoIWluZm8pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgdG9wIHJ1bGUgbmFtZSAke2NvbmZpZy50b3B9YCk7XG4gICAgICAgICAgICBjb3B5LnRvcCA9IGluZm87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy50b2tlbml6ZXJzKVxuICAgICAgICAgICAgY29weS50b2tlbml6ZXJzID0gdGhpcy50b2tlbml6ZXJzLm1hcCh0ID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBjb25maWcudG9rZW5pemVycy5maW5kKHIgPT4gci5mcm9tID09IHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZCA/IGZvdW5kLnRvIDogdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoY29uZmlnLmRpYWxlY3QpXG4gICAgICAgICAgICBjb3B5LmRpYWxlY3QgPSB0aGlzLnBhcnNlRGlhbGVjdChjb25maWcuZGlhbGVjdCk7XG4gICAgICAgIGlmIChjb25maWcubmVzdGVkKVxuICAgICAgICAgICAgY29weS5uZXN0ZWQgPSB0aGlzLm5lc3RlZC5tYXAob2JqID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcubmVzdGVkLCBvYmoubmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogb2JqLm5hbWUsIHZhbHVlOiBjb25maWcubmVzdGVkW29iai5uYW1lXSwgZW5kOiBvYmouZW5kLCBwbGFjZWhvbGRlcjogb2JqLnBsYWNlaG9sZGVyIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbmZpZy5zdHJpY3QgIT0gbnVsbClcbiAgICAgICAgICAgIGNvcHkuc3RyaWN0ID0gY29uZmlnLnN0cmljdDtcbiAgICAgICAgaWYgKGNvbmZpZy5idWZmZXJMZW5ndGggIT0gbnVsbClcbiAgICAgICAgICAgIGNvcHkuYnVmZmVyTGVuZ3RoID0gY29uZmlnLmJ1ZmZlckxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIC8vLyBSZXR1cm5zIHRoZSBuYW1lIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIHRlcm0uIFRoaXMgd2lsbCBvbmx5XG4gICAgLy8vIHdvcmsgZm9yIGFsbCB0ZXJtcyB3aGVuIHRoZSBwYXJzZXIgd2FzIGdlbmVyYXRlZCB3aXRoIHRoZVxuICAgIC8vLyBgLS1uYW1lc2Agb3B0aW9uLiBCeSBkZWZhdWx0LCBvbmx5IHRoZSBuYW1lcyBvZiB0YWdnZWQgdGVybXMgYXJlXG4gICAgLy8vIHN0b3JlZC5cbiAgICBnZXROYW1lKHRlcm0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVybU5hbWVzID8gdGhpcy50ZXJtTmFtZXNbdGVybV0gOiBTdHJpbmcodGVybSA8PSB0aGlzLm1heE5vZGUgJiYgdGhpcy5ub2RlU2V0LnR5cGVzW3Rlcm1dLm5hbWUgfHwgdGVybSk7XG4gICAgfVxuICAgIC8vLyBUaGUgZW9mIHRlcm0gaWQgaXMgYWx3YXlzIGFsbG9jYXRlZCBkaXJlY3RseSBhZnRlciB0aGUgbm9kZVxuICAgIC8vLyB0eXBlcy4gQGludGVybmFsXG4gICAgZ2V0IGVvZlRlcm0oKSB7IHJldHVybiB0aGlzLm1heE5vZGUgKyAxOyB9XG4gICAgLy8vIFRlbGxzIHlvdSB3aGV0aGVyIHRoaXMgZ3JhbW1hciBoYXMgYW55IG5lc3RlZCBncmFtbWFycy5cbiAgICBnZXQgaGFzTmVzdGVkKCkgeyByZXR1cm4gdGhpcy5uZXN0ZWQubGVuZ3RoID4gMDsgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBkeW5hbWljUHJlY2VkZW5jZSh0ZXJtKSB7XG4gICAgICAgIGxldCBwcmVjID0gdGhpcy5keW5hbWljUHJlY2VkZW5jZXM7XG4gICAgICAgIHJldHVybiBwcmVjID09IG51bGwgPyAwIDogcHJlY1t0ZXJtXSB8fCAwO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgcGFyc2VEaWFsZWN0KGRpYWxlY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FjaGVkRGlhbGVjdCAmJiB0aGlzLmNhY2hlZERpYWxlY3Quc291cmNlID09IGRpYWxlY3QpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWREaWFsZWN0O1xuICAgICAgICBsZXQgdmFsdWVzID0gT2JqZWN0LmtleXModGhpcy5kaWFsZWN0cyksIGZsYWdzID0gdmFsdWVzLm1hcCgoKSA9PiBmYWxzZSk7XG4gICAgICAgIGlmIChkaWFsZWN0KVxuICAgICAgICAgICAgZm9yIChsZXQgcGFydCBvZiBkaWFsZWN0LnNwbGl0KFwiIFwiKSkge1xuICAgICAgICAgICAgICAgIGxldCBpZCA9IHZhbHVlcy5pbmRleE9mKHBhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChpZCA+PSAwKVxuICAgICAgICAgICAgICAgICAgICBmbGFnc1tpZF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgZGlzYWJsZWQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghZmxhZ3NbaV0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gdGhpcy5kaWFsZWN0c1t2YWx1ZXNbaV1dLCBpZDsgKGlkID0gdGhpcy5kYXRhW2orK10pICE9IDY1NTM1IC8qIEVuZCAqLzspXG4gICAgICAgICAgICAgICAgICAgIChkaXNhYmxlZCB8fCAoZGlzYWJsZWQgPSBuZXcgVWludDhBcnJheSh0aGlzLm1heFRlcm0gKyAxKSkpW2lkXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlZERpYWxlY3QgPSBuZXcgRGlhbGVjdChkaWFsZWN0LCBmbGFncywgZGlzYWJsZWQpO1xuICAgIH1cbiAgICAvLy8gKHVzZWQgYnkgdGhlIG91dHB1dCBvZiB0aGUgcGFyc2VyIGdlbmVyYXRvcikgQGludGVybmFsXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZXIoc3BlYyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFpcihkYXRhLCBvZmYpIHsgcmV0dXJuIGRhdGFbb2ZmXSB8IChkYXRhW29mZiArIDFdIDw8IDE2KTsgfVxuZnVuY3Rpb24gZmluZE9mZnNldChkYXRhLCBzdGFydCwgdGVybSkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydCwgbmV4dDsgKG5leHQgPSBkYXRhW2ldKSAhPSA2NTUzNSAvKiBFbmQgKi87IGkrKylcbiAgICAgICAgaWYgKG5leHQgPT0gdGVybSlcbiAgICAgICAgICAgIHJldHVybiBpIC0gc3RhcnQ7XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gZmluZEZpbmlzaGVkKHN0YWNrcykge1xuICAgIGxldCBiZXN0ID0gbnVsbDtcbiAgICBmb3IgKGxldCBzdGFjayBvZiBzdGFja3MpIHtcbiAgICAgICAgaWYgKHN0YWNrLnBvcyA9PSBzdGFjay5jeC5pbnB1dC5sZW5ndGggJiZcbiAgICAgICAgICAgIHN0YWNrLmN4LnBhcnNlci5zdGF0ZUZsYWcoc3RhY2suc3RhdGUsIDIgLyogQWNjZXB0aW5nICovKSAmJlxuICAgICAgICAgICAgKCFiZXN0IHx8IGJlc3Quc2NvcmUgPCBzdGFjay5zY29yZSkpXG4gICAgICAgICAgICBiZXN0ID0gc3RhY2s7XG4gICAgfVxuICAgIHJldHVybiBiZXN0O1xufVxuXG5leHBvcnQgeyBFeHRlcm5hbFRva2VuaXplciwgUGFyc2VyLCBTdGFjaywgVG9rZW4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIiwiZXhwb3J0IHZhciBCaW5PcDtcbihmdW5jdGlvbiAoQmluT3ApIHtcbiAgICBCaW5PcFtcIlBsdXNcIl0gPSBcIitcIjtcbiAgICBCaW5PcFtcIk1pbnVzXCJdID0gXCItXCI7XG4gICAgQmluT3BbXCJNdWxcIl0gPSBcIipcIjtcbiAgICBCaW5PcFtcIkRpdlwiXSA9IFwiLy9cIjtcbiAgICBCaW5PcFtcIk1vZFwiXSA9IFwiJVwiO1xuICAgIEJpbk9wW1wiRXFcIl0gPSBcIj09XCI7XG4gICAgQmluT3BbXCJOZXFcIl0gPSBcIiE9XCI7XG4gICAgQmluT3BbXCJTZXFcIl0gPSBcIjw9XCI7XG4gICAgQmluT3BbXCJMZXFcIl0gPSBcIj49XCI7XG4gICAgQmluT3BbXCJTbWxcIl0gPSBcIjxcIjtcbiAgICBCaW5PcFtcIkxyZ1wiXSA9IFwiPlwiO1xuICAgIEJpbk9wW1wiSXNcIl0gPSBcImlzXCI7XG59KShCaW5PcCB8fCAoQmluT3AgPSB7fSkpO1xuZXhwb3J0IHZhciBVbmlPcDtcbihmdW5jdGlvbiAoVW5pT3ApIHtcbiAgICBVbmlPcFtcIk1pbnVzXCJdID0gXCItXCI7XG4gICAgVW5pT3BbXCJOb3RcIl0gPSBcIm5vdFwiO1xufSkoVW5pT3AgfHwgKFVuaU9wID0ge30pKTtcbiIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbmltcG9ydCB7IEJpbk9wLCBVbmlPcCB9IGZyb20gJy4vYXN0JztcbmltcG9ydCB7IHBhcnNlIH0gZnJvbSBcIi4vcGFyc2VyXCI7XG5pbXBvcnQgeyB0eXBlQ2hlY2tQcm9ncmFtIH0gZnJvbSBcIi4vdHlwZWNoZWNrXCI7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRW1wdHlMb2NhbEVudigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YXJzOiBuZXcgTWFwKCksXG4gICAgICAgIGlzRnVuYzogZmFsc2UsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbXB0eUdsb2JhbEVudigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YXJzOiBuZXcgTWFwKCksXG4gICAgICAgIGZ1bmNzOiBuZXcgTWFwKCksXG4gICAgICAgIGNsYXNzSW5kZXhlczogbmV3IE1hcCgpLFxuICAgICAgICBjbGFzc0luaXRzOiBuZXcgTWFwKCksXG4gICAgICAgIGxvb3BEZXB0aDogMFxuICAgIH07XG59XG4vLyBzZXQgdXAgZ2xvYmFsIHZhcmlhYmxlcyBhbmQgZ2xvYmFsIGZ1bmN0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIHNldEdsb2JhbEluZm8ocHJvZ3JhbSkge1xuICAgIHZhciBnbG9iYWxFbnYgPSBjcmVhdGVFbXB0eUdsb2JhbEVudigpO1xuICAgIC8vIHNldCB2YXJpYWJsZXNcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBwcm9ncmFtLnZhckluaXRzLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgZ2xvYmFsRW52LnZhcnMuc2V0KHByb2dyYW0udmFySW5pdHNbaWR4XS5uYW1lLCBwcm9ncmFtLnZhckluaXRzW2lkeF0pO1xuICAgIH1cbiAgICAvLyBzZXQgZnVuY3N0aW9uc1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHByb2dyYW0uZnVuY0RlZnMubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICBnbG9iYWxFbnYuZnVuY3Muc2V0KHByb2dyYW0uZnVuY0RlZnNbaWR4XS5uYW1lLCBwcm9ncmFtLmZ1bmNEZWZzW2lkeF0pO1xuICAgIH1cbiAgICAvLyBzZXQgY2xhc3MgZmllbGQgaW5kZXhlcyBhbmQgaW5pdCB2YWx1ZVxuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHByb2dyYW0uY2xhc3NEZWZzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgdmFyIGNsYXNzSW5kZXhlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIGNsYXNzSW5pdHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBjbGFzc0RlZiA9IHByb2dyYW0uY2xhc3NEZWZzW2lkeF07XG4gICAgICAgIGlmIChjbGFzc0RlZi50YWcgIT09IFwiY2xhc3NcIikge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJzaG91bGQgYmUgYSBjbGFzc1wiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmllbGRzID0gY2xhc3NEZWYuZmllbGRzO1xuICAgICAgICBmb3IgKHZhciBpZHgyID0gMDsgaWR4MiA8IGZpZWxkcy5sZW5ndGg7IGlkeDIrKykge1xuICAgICAgICAgICAgY2xhc3NJbmRleGVzLnNldChmaWVsZHNbaWR4Ml0ubmFtZSwgaWR4Mik7XG4gICAgICAgICAgICBjbGFzc0luaXRzLnNldChmaWVsZHNbaWR4Ml0ubmFtZSwgZmllbGRzW2lkeDJdLmluaXRMaXRlcmFsKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xhc3NOYW1lID0gY2xhc3NEZWYubmFtZTtcbiAgICAgICAgZ2xvYmFsRW52LmNsYXNzSW5kZXhlcy5zZXQoY2xhc3NOYW1lLCBjbGFzc0luZGV4ZXMpO1xuICAgICAgICBnbG9iYWxFbnYuY2xhc3NJbml0cy5zZXQoY2xhc3NOYW1lLCBjbGFzc0luaXRzKTtcbiAgICB9XG4gICAgcmV0dXJuIGdsb2JhbEVudjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb21waWxlKHNvdXJjZSkge1xuICAgIC8vIHBhcnNlIHByb2dyYW0gYW5kIGdldCBlYWNoIGVsZW1lbnRzXG4gICAgdmFyIHByb2dyYW0gPSB0eXBlQ2hlY2tQcm9ncmFtKHBhcnNlKHNvdXJjZSkpO1xuICAgIHZhciBhc3QgPSBwcm9ncmFtLnN0bXRzO1xuICAgIHZhciBnbG9iYWxFbnYgPSBzZXRHbG9iYWxJbmZvKHByb2dyYW0pO1xuICAgIC8vIGdlbmVyYXRlIGZ1bmN0aW9uIGRlZmluaXRpb25zXG4gICAgdmFyIGZ1bmNzID0gcHJvZ3JhbS5mdW5jRGVmcy5tYXAoZnVuY3Rpb24gKGZ1bmNEZWYpIHtcbiAgICAgICAgcmV0dXJuIGNvZGVHZW5GdW5jRGVmKGZ1bmNEZWYsIGdsb2JhbEVudik7XG4gICAgfSkuam9pbignXFxuJyk7XG4gICAgLy8gZ2VuZXJhdGUgZ2xvYmFsIHZhcmlhYmxlcyAoaW5jbHVkaW5nIHRoZSBoZWFwKVxuICAgIHZhciBnbG9iYWxWYXJzID0gY29kZUdlbkdsb2JhbFZhcihwcm9ncmFtLnZhckluaXRzKS5qb2luKCdcXG4nKTtcbiAgICAvLyBnZW5lcmF0ZSBjbGFzcyBkZWZpbml0aW9uc1xuICAgIHZhciBjbGFzc2VzID0gcHJvZ3JhbS5jbGFzc0RlZnMubWFwKGZ1bmN0aW9uIChjbGFzc0RlZikge1xuICAgICAgICByZXR1cm4gY29kZUdlbkNsYXNzRGVmKGNsYXNzRGVmLCBnbG9iYWxFbnYpOyAvLyBub3Qgc3VyZSB3aHkgaXRzIHJldHVybiBpcyBzdHJpbmdwW11cbiAgICB9KS5qb2luKFwiXFxuXCIpO1xuICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBsb2NhbCBlbnZpcm9ubWVudFxuICAgIHZhciBsb2NhbEVudiA9IGNyZWF0ZUVtcHR5TG9jYWxFbnYoKTtcbiAgICAvLyBnZW5lcmF0ZSB0aGUgY29kZSBmb3IgdGhlIG1haW4gYm9keVxuICAgIHZhciBjb21tYW5kcyA9IGNvZGVHZW5NYWluQm9keShhc3QsIGdsb2JhbEVudiwgbG9jYWxFbnYpO1xuICAgIC8vIGNvbnNvbGUubG9nKGNvbW1hbmRzKTtcbiAgICAvLyBzZXQgdXAgZmluYWwgZnVuY3Rpb24gcmV0dXJuIHR5cGVcbiAgICB2YXIgbGFzdEV4cHIgPSBhc3RbYXN0Lmxlbmd0aCAtIDFdO1xuICAgIHZhciByZXR1cm5UeXBlID0gXCJcIjtcbiAgICB2YXIgcmV0dXJuRXhwciA9IFwiXCI7XG4gICAgLy8gY29uc29sZS5sb2coYGFzdC5sZW5ndGg6ICR7YXN0Lmxlbmd0aH0sIGxhc3RFeHByOiAke2xhc3RFeHByLnRhZ31gKTtcbiAgICBpZiAoYXN0Lmxlbmd0aCA+IDAgJiYgbGFzdEV4cHIudGFnID09PSBcImV4cHJcIikge1xuICAgICAgICByZXR1cm5UeXBlID0gXCIocmVzdWx0IGkzMilcIjtcbiAgICAgICAgcmV0dXJuRXhwciA9IFwiXFxuKGxvY2FsLmdldCAkbGFzdClcIjsgLy8gU2luY2Ugd2UgdXNlIGEgZnVuY3Rpb24gYXQgdGhlIGVuZCwgd2UgbmVlZCB0byBwdXQgdGhlIHJldHVybiB2YWx1ZSBpbiB0aGUgc3RhY2suXG4gICAgfVxuICAgIC8vIFRoZSBsYXN0IHZhbHVlIGlzIG5vdCBuZWVkZWQgaWYgdGhlIGxhc3Qgc3RhdGVtZW50IGlzIG5vdCBhbiBleHByZXNzaW9uLlxuICAgIHJldHVybiB7XG4gICAgICAgIHdhc21Tb3VyY2U6IGdsb2JhbFZhcnMgKyBcIlxcblwiICsgY2xhc3NlcyArIFwiXFxuXCIgKyBmdW5jcyArIFwiXFxuKGZ1bmMgKGV4cG9ydCBcXFwiZXhwb3J0ZWRfZnVuY1xcXCIpIFwiICsgcmV0dXJuVHlwZSArIGNvbW1hbmRzLmpvaW4oJ1xcbicpICsgcmV0dXJuRXhwciArIFwiKVwiXG4gICAgfTtcbn1cbi8vIGdlbmVyYXRlIGNvZGVzIGZvciBzdGF0ZW1lbnRzXG5mdW5jdGlvbiBjb2RlR2VuKHN0bXQsIGdsb2JhbEVudiwgbG9jYWxFbnYpIHtcbiAgICBzd2l0Y2ggKHN0bXQudGFnKSB7XG4gICAgICAgIGNhc2UgXCJhc3NpZ25cIjpcbiAgICAgICAgICAgIHZhciB2YWxTdG10cyA9IGNvZGVHZW5FeHByKHN0bXQudmFsdWUsIGdsb2JhbEVudiwgbG9jYWxFbnYpOyAvLyByaHNcbiAgICAgICAgICAgIHZhciBsZWZ0RXhwciA9IGNvZGVHZW5FeHByKHN0bXQubmFtZSwgZ2xvYmFsRW52LCBsb2NhbEVudik7IC8vIGxoc1xuICAgICAgICAgICAgLy8gZ2VuZXJhdGUgdGhlIFwic3RvcmVcIiBhc3NpZ24gY29kZVxuICAgICAgICAgICAgaWYgKHN0bXQubmFtZS50YWcgPT0gXCJnZXRmaWVsZFwiKSB7XG4gICAgICAgICAgICAgICAgbGVmdEV4cHIgPSBsZWZ0RXhwci5zbGljZSgwLCAtMSk7IC8vIHN0cmlwIGBpMzIubG9hZGAgc2luY2UgaXQncyBsaHNcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdEV4cHIuY29uY2F0KFt2YWxTdG10cyArIFwiXFxuaTMyLnN0b3JlXCJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyBnZW5lcmF0ZSB0aGUgXCJzZXRcIiBhc3NpZ24gY29kZVxuICAgICAgICAgICAgICAgIGlmIChsb2NhbEVudi5pc0Z1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsRW52LnZhcnMuaGFzKHN0bXQudmFyaWFibGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsU3RtdHMuY29uY2F0KFtcIihsb2NhbC5zZXQgJFwiICsgc3RtdC5uYW1lICsgXCIpXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW5ub3QgYXNzaWduIGEgdmFsdWUgdG8gYSBnbG9iYWwgdmFyaWFibGUgaW4gdGhlIGZ1bmN0aW9uIGVudmlyb25tZW50LlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZ2xvYmFsIHZhcmlhYmxlIFwiICsgc3RtdC52YXJpYWJsZSArIFwiIGNhbm5vdCBiZSBhc3NpZ25lZCBpbiBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWxTdG10cy5jb25jYXQoW1wiKGdsb2JhbC5zZXQgJFwiICsgc3RtdC52YXJpYWJsZSArIFwiKVwiXSk7IC8vIGdsb2JhbCBlbnZpcm9ubWVudFxuICAgICAgICBjYXNlIFwiZXhwclwiOlxuICAgICAgICAgICAgdmFyIGV4cHJTdG10cyA9IGNvZGVHZW5FeHByKHN0bXQuZXhwciwgZ2xvYmFsRW52LCBsb2NhbEVudik7XG4gICAgICAgICAgICByZXR1cm4gZXhwclN0bXRzLmNvbmNhdChbXCIobG9jYWwuc2V0ICRsYXN0KVwiXSk7XG4gICAgICAgIC8vIFdpdGhvdXQgdGhlIHJldHVybiBjb21tYW5kLCB0aGUgZnVuY3Rpb24gd291bGQgcmV0dXJuIHRoZSB2YWx1ZXMgaW4gdGhlIHN0YWNrLlxuICAgICAgICAvLyBIb3dldmVyLCB3ZSB3b3VsZCBuZWVkIHRvIG1ha2Ugc3VyZSB0aGUgI3N0YWNrIGVsZW1lbnRzID09ICNyZXR1cm4gdmFsdWVzXG4gICAgICAgIGNhc2UgXCJyZXR1cm5cIjpcbiAgICAgICAgICAgIHZhciByZXR1cm5TdG10cyA9IGNvZGVHZW5FeHByKHN0bXQuZXhwciwgZ2xvYmFsRW52LCBsb2NhbEVudik7XG4gICAgICAgICAgICByZXR1cm5TdG10cy5wdXNoKFwiKHJldHVybilcIik7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuU3RtdHM7XG4gICAgICAgIGNhc2UgXCJwYXNzXCI6XG4gICAgICAgICAgICByZXR1cm4gW1wibm9wXCJdOyAvLyBubyBvcGVyYXRpb25cbiAgICAgICAgY2FzZSBcIndoaWxlXCI6XG4gICAgICAgICAgICB2YXIgd2hpbGVTdG10cyA9IGNvZGVHZW5XaGlsZShzdG10LCBnbG9iYWxFbnYsIGxvY2FsRW52KTtcbiAgICAgICAgICAgIHJldHVybiB3aGlsZVN0bXRzLmNvbmNhdCgpO1xuICAgICAgICBjYXNlIFwiaWZcIjpcbiAgICAgICAgICAgIHZhciBpZlN0bXRzID0gY29kZUdlbklmKHN0bXQsIGdsb2JhbEVudiwgbG9jYWxFbnYpO1xuICAgICAgICAgICAgcmV0dXJuIGlmU3RtdHMuY29uY2F0KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29kZUdlbk1haW5Cb2R5KHN0bXRzLCBnbG9iYWxFbnYsIGxvY2FsRW52KSB7XG4gICAgLy8gZGVjbGFyZSBhbGwgbG9jYWwgdmFyaWFibGVzIGFjY29yZGluZyB0byB0aGUgc291cmNlXG4gICAgdmFyIHNjcmF0Y2hWYXIgPSBcIihsb2NhbCAkbGFzdCBpMzIpXCI7IC8vIGFzIGZ1bmN0aW9uIG91dHB1dFxuICAgIC8vIHB1dCAkbGFzdCBvbiB0aGUgc3RhY2ssIGFuZCBpdCB3aWwgY29uc3VtZSB0aGUgdG9wIHZhbHVlIG9uIHRoZSBzdGFjayBldmVudHVhbGx5XG4gICAgdmFyIGxvY2FsRGVmaW5lcyA9IFtzY3JhdGNoVmFyXTtcbiAgICB2YXIgY29tbWFuZEdyb3VwcyA9IHN0bXRzLm1hcChmdW5jdGlvbiAoc3RtdCkgeyByZXR1cm4gY29kZUdlbihzdG10LCBnbG9iYWxFbnYsIGxvY2FsRW52KTsgfSk7XG4gICAgcmV0dXJuIGxvY2FsRGVmaW5lcy5jb25jYXQoW10uY29uY2F0LmFwcGx5KFtdLCBjb21tYW5kR3JvdXBzKSk7XG59XG5mdW5jdGlvbiBjb2RlR2VuRXhwcihleHByLCBnbG9iYWxFbnYsIGxvY2FsRW52KSB7XG4gICAgc3dpdGNoIChleHByLnRhZykge1xuICAgICAgICBjYXNlIFwiaWRcIjpcbiAgICAgICAgICAgIHJldHVybiBbY29kZUdlbklkKGV4cHIsIGdsb2JhbEVudiwgbG9jYWxFbnYpXTtcbiAgICAgICAgY2FzZSBcImJpbm9wXCI6XG4gICAgICAgICAgICB2YXIgbGVmdFN0bXRzID0gY29kZUdlbkV4cHIoZXhwci5sZWZ0LCBnbG9iYWxFbnYsIGxvY2FsRW52KTtcbiAgICAgICAgICAgIHZhciByaWdodFN0bXRzID0gY29kZUdlbkV4cHIoZXhwci5yaWdodCwgZ2xvYmFsRW52LCBsb2NhbEVudik7XG4gICAgICAgICAgICB2YXIgb3BTdG10ID0gY29kZUdlbkJpbk9wKGV4cHIub3ApO1xuICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXlzKGxlZnRTdG10cywgcmlnaHRTdG10cywgW29wU3RtdF0pO1xuICAgICAgICBjYXNlIFwidW5pb3BcIjpcbiAgICAgICAgICAgIHZhciB1bmlvcFJpZ2h0ID0gY29kZUdlbkV4cHIoZXhwci5leHByLCBnbG9iYWxFbnYsIGxvY2FsRW52KTtcbiAgICAgICAgICAgIHJldHVybiBjb2RlR2VuVW5pb25PcChleHByLm9wLCB1bmlvcFJpZ2h0KTtcbiAgICAgICAgY2FzZSBcImxpdGVyYWxcIjpcbiAgICAgICAgICAgIHJldHVybiBbY29kZUdlbkxpdGVyYWwoZXhwci5saXRlcmFsKV07XG4gICAgICAgIGNhc2UgXCJjYWxsXCI6XG4gICAgICAgICAgICByZXR1cm4gY29kZUdlbkNhbGwoZXhwciwgZ2xvYmFsRW52LCBsb2NhbEVudik7XG4gICAgICAgIGNhc2UgXCJtZXRob2RcIjpcbiAgICAgICAgICAgIHZhciBhcmdJbnN0cnMgPSBleHByLmFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBjb2RlR2VuRXhwcihhLCBnbG9iYWxFbnYsIGxvY2FsRW52KTsgfSk7XG4gICAgICAgICAgICB2YXIgZmxhdHRlbkFyZ3NfMSA9IFtdOyAvLyBmbGF0IHRoZSBsaXN0IG9mIGxpc3RzXG4gICAgICAgICAgICBhcmdJbnN0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXJnKSB7IHJldHVybiBmbGF0dGVuQXJnc18xLnB1c2goYXJnLmpvaW4oXCJcXG5cIikpOyB9KTtcbiAgICAgICAgICAgIGlmIChleHByLm9iai5hID09IFwiaW50XCIgfHwgZXhwci5vYmouYSA9PSBcImJvb2xcIiB8fCBleHByLm9iai5hID09IFwiTm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGlzIHNob3VsZCBiZSBhIGNsYXNzLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBjYWxsIG9iamVjdCBpcyB0aGUgZmlyc3QgYXJndW1lbnQgc2VsZi5cbiAgICAgICAgICAgIHZhciBjYWxsT2JqZWN0ID0gY29kZUdlbkV4cHIoZXhwci5vYmosIGdsb2JhbEVudiwgbG9jYWxFbnYpLmpvaW4oXCJcXG5cIik7XG4gICAgICAgICAgICByZXR1cm4gW2NhbGxPYmplY3QsIGZsYXR0ZW5BcmdzXzEuam9pbihcIlxcblwiKSwgXCJcXG4oY2FsbCAkJFwiICsgZXhwci5vYmouYS5jbGFzcyArIFwiJFwiICsgZXhwci5uYW1lICsgXCIpXCJdO1xuICAgICAgICBjYXNlIFwiZ2V0ZmllbGRcIjpcbiAgICAgICAgICAgIHJldHVybiBjb2RlR2VuRmllbGQoZXhwciwgZ2xvYmFsRW52LCBsb2NhbEVudik7XG4gICAgfVxufVxuZnVuY3Rpb24gY29kZUdlbkJpbk9wKG9wKSB7XG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgICBjYXNlIEJpbk9wLlBsdXM6XG4gICAgICAgICAgICByZXR1cm4gXCIoaTMyLmFkZClcIjtcbiAgICAgICAgY2FzZSBCaW5PcC5NaW51czpcbiAgICAgICAgICAgIHJldHVybiBcIihpMzIuc3ViKVwiO1xuICAgICAgICBjYXNlIEJpbk9wLk11bDpcbiAgICAgICAgICAgIHJldHVybiBcIihpMzIubXVsKVwiO1xuICAgICAgICBjYXNlIEJpbk9wLkRpdjpcbiAgICAgICAgICAgIHJldHVybiBcIihpMzIuZGl2X3MpXCI7XG4gICAgICAgIGNhc2UgQmluT3AuTW9kOlxuICAgICAgICAgICAgcmV0dXJuIFwiKGkzMi5yZW1fcylcIjtcbiAgICAgICAgY2FzZSBCaW5PcC5FcTpcbiAgICAgICAgICAgIHJldHVybiBcIihpMzIuZXEpXCI7XG4gICAgICAgIGNhc2UgQmluT3AuTmVxOlxuICAgICAgICAgICAgcmV0dXJuIFwiKGkzMi5uZSlcIjtcbiAgICAgICAgY2FzZSBCaW5PcC5TZXE6XG4gICAgICAgICAgICByZXR1cm4gXCIoaTMyLmxlX3MpXCI7XG4gICAgICAgIGNhc2UgQmluT3AuTGVxOlxuICAgICAgICAgICAgcmV0dXJuIFwiKGkzMi5nZV9zKVwiO1xuICAgICAgICBjYXNlIEJpbk9wLlNtbDpcbiAgICAgICAgICAgIHJldHVybiBcIihpMzIubHRfcylcIjtcbiAgICAgICAgY2FzZSBCaW5PcC5Mcmc6XG4gICAgICAgICAgICByZXR1cm4gXCIoaTMyLmd0X3MpXCI7XG4gICAgICAgIGNhc2UgQmluT3AuSXM6XG4gICAgICAgICAgICAvLyB4IGlzIHkgXG4gICAgICAgICAgICAvLyBlLmcuIHkgaXMgYSBjbGFzcyBhbmQgeCBpcyBhbiBvYmplY3Qgb2YgdGhhdCBjbGFzc1xuICAgICAgICAgICAgLy8gY3VycmVudGx5LCB0aGUgb25seSBjbGFzcyBpcyBOb25lLCBzbyB3ZSBjYW4gdXNlIGVxXG4gICAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoXCJDT01QSUxFIEVSUk9SOiBpcyBvcGVyYXRvciBub3QgaW1wbGVtZW50ZWRcIilcbiAgICAgICAgICAgIC8vIEZvciBvdGhlciBjbGFzc2VzLCB3ZSBzaG91bGQgY29tcGFyZSB0aGUgZmllbGQgcmVjdXJzaXZlbHkuXG4gICAgICAgICAgICAvLyBJbiBDaG9jb3B5LCBcImlzXCIgaXMgdXNlZCB0byBjb21wYXJlIHRoZSBmaWVsZHMgaW4gdHdvIGNsYXNzIG9iamVjdHMsIGFuZCBcIj09XCIgY2Fubm90IGJlIHVzZWQgd2l0aCBjbGFzc2VzLiBcbiAgICAgICAgICAgIHJldHVybiBcIihpMzIuZXEpXCI7XG4gICAgfVxufVxuZnVuY3Rpb24gY29kZUdlblVuaW9uT3Aob3AsIHJpZ2h0KSB7XG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgICBjYXNlIFVuaU9wLk1pbnVzOlxuICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXlzKFtcIihpMzIuY29uc3QgMClcIl0sIHJpZ2h0LCBbXCIoaTMyLnN1YikgXCJdKTsgLy8gLXggPSAwIC0geFxuICAgICAgICBjYXNlIFVuaU9wLk5vdDpcbiAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5cyhyaWdodCwgW1wiKGkzMi5lcXopXCJdKTsgLy8gaXMgeCAhPSAwLCByZXR1cm4gMTsgZWxzZSwgcmV0dXJuIDBcbiAgICB9XG59XG5mdW5jdGlvbiBjb2RlR2VuSWYoc3RtdCwgZ2xvYmFsRW52LCBsb2NhbEVudikge1xuICAgIGlmIChzdG10LnRhZyAhPT0gJ2lmJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDT01QSUxFIEVSUk9SOiB0aGUgaW5wdXQgdG8gY29kZUdlbklmIHNob3VsZCBoYXZlIHRhZyBpZlwiKTtcbiAgICB9XG4gICAgdmFyIGlmQ29uZCA9IGNvZGVHZW5FeHByKHN0bXQuaWZPcC5jb25kLCBnbG9iYWxFbnYsIGxvY2FsRW52KS5qb2luKCdcXG4nKTtcbiAgICB2YXIgaWZCb2R5ID0gY29kZUdlbkJvZHkoc3RtdC5pZk9wLnN0bXRzLCBnbG9iYWxFbnYsIGxvY2FsRW52KS5qb2luKCdcXG4nKTtcbiAgICB2YXIgZWxpZkNvbmQgPSBcIihpMzIuY29uc3QgMClcIjtcbiAgICB2YXIgZWxpZkJvZHkgPSBcIm5vcFwiO1xuICAgIHZhciBlbHNlQm9keSA9IFwibm9wXCI7XG4gICAgLy8gaGFzIGVsc2UgaWZcbiAgICBpZiAoc3RtdC5lbGlmT3AuY29uZCAhPT0gbnVsbCkge1xuICAgICAgICBlbGlmQ29uZCA9IGNvZGVHZW5FeHByKHN0bXQuZWxpZk9wLmNvbmQsIGdsb2JhbEVudiwgbG9jYWxFbnYpLmpvaW4oJ1xcbicpO1xuICAgICAgICBlbGlmQm9keSA9IGNvZGVHZW5Cb2R5KHN0bXQuZWxpZk9wLnN0bXRzLCBnbG9iYWxFbnYsIGxvY2FsRW52KS5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgaWYgKHN0bXQuZWxzZU9wLnN0bXRzICE9PSBudWxsKSB7XG4gICAgICAgIGVsc2VCb2R5ID0gY29kZUdlbkJvZHkoc3RtdC5lbHNlT3Auc3RtdHMsIGdsb2JhbEVudiwgbG9jYWxFbnYpLmpvaW4oJ1xcbicpO1xuICAgIH1cbiAgICByZXR1cm4gW2lmQ29uZCArIFwiXFxuKGlmXFxuKHRoZW5cXG5cIiArIGlmQm9keSArIFwiXFxuKVxcbihlbHNlXFxuXCIgKyBlbGlmQ29uZCArIFwiXFxuKGlmXFxuKHRoZW5cXG5cIiArIGVsaWZCb2R5ICsgXCJcXG4pXFxuKGVsc2VcXG5cIiArIGVsc2VCb2R5ICsgXCJcXG4pKSkpXCJdO1xufVxuLy8gZ2VuZXJhdGUgdGhlIGNvZGVzIGZvciBzdGF0ZW1lbnRzXG5mdW5jdGlvbiBjb2RlR2VuQm9keShzdG10cywgZ2xvYmFsRW52LCBsb2NhbEVudikge1xuICAgIHZhciBib2R5ID0gc3RtdHMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHZhciBiID0gY29kZUdlbihzLCBnbG9iYWxFbnYsIGxvY2FsRW52KTtcbiAgICAgICAgcmV0dXJuIGIuam9pbignXFxuJyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJvZHk7XG59XG5mdW5jdGlvbiBjb2RlR2VuV2hpbGUoc3RtdCwgZ2xvYmFsRW52LCBsb2NhbEVudikge1xuICAgIGlmIChzdG10LnRhZyAhPT0gXCJ3aGlsZVwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNPTVBJTEUgRVJST1I6IGNvZGVHZW5XaGlsZSB0YWtlcyBvbmx5IHdoaWxlIHN0YXRlbWVudCBhcyBpbnB1dFwiKTtcbiAgICB9XG4gICAgLy8gdGhyb3cgbmV3IEVycm9yKFwiQ09NUElMRSBFUlJPUjogd2hpbGUgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkIHlldFwiKTtcbiAgICB2YXIgbG9vcElkID0gKGdsb2JhbEVudi5sb29wRGVwdGgrKyk7XG4gICAgLy8gY29tbWFuZCBib2R5XG4gICAgdmFyIGJvZHkgPSBjb2RlR2VuQm9keShzdG10LnN0bXRzLCBnbG9iYWxFbnYsIGxvY2FsRW52KTtcbiAgICAvLyBjb25kaXRpb24gXG4gICAgdmFyIGNvbmQgPSBjb2RlR2VuRXhwcihzdG10LmNvbmQsIGdsb2JhbEVudiwgbG9jYWxFbnYpO1xuICAgIGdsb2JhbEVudi5sb29wRGVwdGgtLTtcbiAgICByZXR1cm4gW1wiKGxvb3AgXFxuXCIgKyBib2R5LmpvaW4oJ1xcbicpICsgXCJcXG5cIiArIGNvbmQuam9pbignXFxuJykgKyBcIlxcbmJyX2lmIFwiICsgbG9vcElkICsgXCIpXCJdO1xufVxuZnVuY3Rpb24gY29kZUdlbkZpZWxkKGV4cHIsIGdsb2JhbEVudiwgbG9jYWxFbnYpIHtcbiAgICBpZiAoZXhwci50YWcgIT09ICdnZXRmaWVsZCcpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJDT01QSUxFUiBFUlJPUjogVGhlIGlucHV0IGV4cHJlc3Npb24gdG8gY29kZUdlbkNhbGwgc2hvdWxkIGJlIGdldGZpZWxkLlwiKTtcbiAgICB9XG4gICAgaWYgKGV4cHIub2JqLmEgPT09IFwiaW50XCIgfHwgZXhwci5vYmouYSA9PT0gXCJib29sXCIgfHwgZXhwci5vYmouYSA9PT0gXCJOb25lXCIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJDT01QSUxFUiBFUlJPUjogVGhlIG9iamVjdCBzaG91bGQgYmUgYSBjbGFzcy5cIik7XG4gICAgfVxuICAgIC8vIElmIGl0IGlzIGFuIGluc3RhbmNlLCBpdCBzaG91bGQgcmV0dXJuIGl0cyBhZGRyZXNzLCBleC4gKGdsb2JhbC5nZXQgJHIxKS5cbiAgICB2YXIgb2JqQWRkciA9IGNvZGVHZW5FeHByKGV4cHIub2JqLCBnbG9iYWxFbnYsIGxvY2FsRW52KTtcbiAgICB2YXIgY2hlY2tWYWxpZEFkZHJlc3MgPSBfX3NwcmVhZEFycmF5cyhvYmpBZGRyLCBbXCIoaTMyLmNvbnN0IC00KSBcXG4oaTMyLmFkZClcIiwgXCIoaTMyLmxvYWQpXCIsIFwibG9jYWwuc2V0ICRsYXN0XCJdKTtcbiAgICB2YXIgY2xhc3NJbmRleGVzID0gZ2xvYmFsRW52LmNsYXNzSW5kZXhlcy5nZXQoZXhwci5vYmouYS5jbGFzcyk7XG4gICAgdmFyIGluZGV4T2ZGaWVsZCA9IGNsYXNzSW5kZXhlcy5nZXQoZXhwci5uYW1lKTtcbiAgICByZXR1cm4gX19zcHJlYWRBcnJheXMoW2NoZWNrVmFsaWRBZGRyZXNzLmpvaW4oXCJcXG5cIildLCBvYmpBZGRyLCBbXCIoaTMyLmNvbnN0IFwiICsgaW5kZXhPZkZpZWxkICogNCArIFwiKSBcXG4oaTMyLmFkZClcIiwgXCIoaTMyLmxvYWQpXCJdKTtcbn1cbmZ1bmN0aW9uIGNvZGVHZW5DYWxsKGV4cHIsIGdsb2JhbEVudiwgbG9jYWxFbnYpIHtcbiAgICBpZiAoZXhwci50YWcgIT09IFwiY2FsbFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNPTVBJTEVSIEVSUk9SOiBUaGUgaW5wdXQgZXhwcmVzc2lvbiB0byBjb2RlR2VuQ2FsbCBzaG91bGQgYmUgY2FsbC5cIik7XG4gICAgfVxuICAgIC8vIGFkZHJlc3MgdGhlIGNhc2Ugb2YgYW4gaW5pdCBjYWxsLCBleC4gcjEgPSBSYXQoKS5cbiAgICBpZiAoZ2xvYmFsRW52LmNsYXNzSW5pdHMuaGFzKGV4cHIubmFtZSkpIHtcbiAgICAgICAgLy8gdmFyaWFibGUgaW5pdGlhbGl6YXRpb25zXG4gICAgICAgIHZhciBpbml0VmFsc18xID0gW107XG4gICAgICAgIHZhciBjbGFzc0luaXRzXzEgPSBnbG9iYWxFbnYuY2xhc3NJbml0cy5nZXQoZXhwci5uYW1lKTsgLy8gZ2V0IHRoZSBpbml0aWFsaXppbmcgdmFsdWVzIG9mIGEgY2xhc3NcbiAgICAgICAgdmFyIGNsYXNzSW5kZXhlcyA9IGdsb2JhbEVudi5jbGFzc0luZGV4ZXMuZ2V0KGV4cHIubmFtZSk7IC8vIGdldCB0aGUgZmllbGQgaW5kZXhlcyBvZiBhIGNsYXNzXG4gICAgICAgIGNsYXNzSW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCwgZmllbGQpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpbmRleCAqIDQ7XG4gICAgICAgICAgICBpbml0VmFsc18xID0gX19zcHJlYWRBcnJheXMoaW5pdFZhbHNfMSwgW1xuICAgICAgICAgICAgICAgIFwiKGdsb2JhbC5nZXQgJGhlYXApXCIsXG4gICAgICAgICAgICAgICAgXCIoaTMyLmNvbnN0IFwiICsgb2Zmc2V0ICsgXCIpXCIsXG4gICAgICAgICAgICAgICAgXCIoaTMyLmFkZClcIixcbiAgICAgICAgICAgICAgICBjb2RlR2VuTGl0ZXJhbChjbGFzc0luaXRzXzEuZ2V0KGZpZWxkKSksXG4gICAgICAgICAgICAgICAgXCIoaTMyLnN0b3JlKVwiXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdlIGhhdmUgdG8gbW9kaWZ5IHRoZSBhZGRyZXNzIG9mIHRoZSBoZWFwLCBzbyB0aGUgbmV4dCBjbGFzcyBjYW4gdXNlIGl0LlxuICAgICAgICBpbml0VmFsc18xID0gX19zcHJlYWRBcnJheXMoaW5pdFZhbHNfMSwgW1xuICAgICAgICAgICAgXCIoZ2xvYmFsLmdldCAkaGVhcClcIixcbiAgICAgICAgICAgIFwiKGdsb2JhbC5nZXQgJGhlYXApXCIsXG4gICAgICAgICAgICBcIihpMzIuY29uc3QgXCIgKyBjbGFzc0luZGV4ZXMuc2l6ZSAqIDQgKyBcIilcIixcbiAgICAgICAgICAgIFwiKGkzMi5hZGQpXCIsXG4gICAgICAgICAgICBcIihnbG9iYWwuc2V0ICRoZWFwKVwiLFxuICAgICAgICBdKTtcbiAgICAgICAgdmFyIGluaXRGdW5jTmFtZSA9IFwiJCRcIiArIGV4cHIubmFtZSArIFwiJF9faW5pdF9fKVwiO1xuICAgICAgICBpZiAoZ2xvYmFsRW52LmZ1bmNzLmhhcyhpbml0RnVuY05hbWUpKSB7XG4gICAgICAgICAgICBpbml0VmFsc18xLnB1c2goXCIoY2FsbCAkJFwiICsgZXhwci5uYW1lICsgXCIkX19pbml0X18pXCIpOyAvLyBleGVjdXRlIHRoZSBfX2luaXRfXyBvcGVyYXRpb25zXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluaXRWYWxzXzE7XG4gICAgfVxuICAgIHZhciBjb2RlcyA9IFtdO1xuICAgIC8vIGNvbGxlY3QgYXJndW1lbnRzXG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgZXhwci5hcmdzLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgdmFyIGFyZyA9IGV4cHIuYXJnc1tpZHhdO1xuICAgICAgICBjb2RlcyA9IF9fc3ByZWFkQXJyYXlzKGNvZGVzLCBjb2RlR2VuRXhwcihhcmcsIGdsb2JhbEVudiwgbG9jYWxFbnYpKTtcbiAgICB9XG4gICAgLy8gY2FsbCB0aGUgZnVuY3Rpb25cbiAgICBpZiAoZXhwci5uYW1lID09PSAncHJpbnQnKSB7XG4gICAgICAgIGlmIChleHByLmFyZ3NbMF0uYSAhPT0gXCJpbnRcIiAmJiBleHByLmFyZ3NbMF0uYSAhPT0gXCJib29sXCIgJiYgZXhwci5hcmdzWzBdLmEgIT09IFwiTm9uZVwiKSB7XG4gICAgICAgICAgICBjb2Rlcy5wdXNoKFwiKGNhbGwgJHByaW50X251bSlcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGV4cHIuYXJnc1swXS5hKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImludFwiOlxuICAgICAgICAgICAgICAgICAgICBjb2Rlcy5wdXNoKFwiKGNhbGwgJHByaW50X251bSlcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJib29sXCI6XG4gICAgICAgICAgICAgICAgICAgIGNvZGVzLnB1c2goXCIoY2FsbCAkcHJpbnRfYm9vbClcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJOb25lXCI6XG4gICAgICAgICAgICAgICAgICAgIGNvZGVzLnB1c2goXCIoY2FsbCAkcHJpbnRfbm9uZSlcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjb2RlIGNhbiBzdGlsbCBjb21waWxlIGlmIGl0J3MgYSBjbGFzcywgYW5kIGFuIGVycm9yIHdpbGwgb2NjdXIgYXQgcnVudGltZS5cbiAgICAgICAgICAgICAgICAgICAgY29kZXMucHVzaChcIihjYWxsICRwcmludF9udW0pXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb2Rlcy5wdXNoKFwiKGNhbGwgJFwiICsgZXhwci5uYW1lICsgXCIpXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZXM7XG59XG5mdW5jdGlvbiBjb2RlR2VuR2xvYmFsVmFyKHZhckluaXRzKSB7XG4gICAgdmFyIHZhckluaXRXYXNtID0gdmFySW5pdHMubWFwKGZ1bmN0aW9uICh2YXJJbml0KSB7XG4gICAgICAgIHJldHVybiBcIihnbG9iYWwgJFwiICsgdmFySW5pdC5uYW1lICsgXCIgKG11dCBpMzIpIFwiICsgY29kZUdlbkxpdGVyYWwodmFySW5pdC5pbml0TGl0ZXJhbCkgKyBcIilcIjtcbiAgICB9KTtcbiAgICB2YXJJbml0V2FzbS5wdXNoKFwiKGdsb2JhbCAkaGVhcCAobXV0IGkzMikgKGkzMi5jb25zdCA0KSlcXG5cIik7IC8vIGluaXRpYWxpemUgdGhlIGhlYXAgZm9yIGNsYXNzZXNcbiAgICByZXR1cm4gdmFySW5pdFdhc207XG59XG4vKlxuZGVmIGdldF9maWVsZF9hKHNlbGYgOiBSYXQpOlxuICByZXR1cm4gc2VsZi5hXG4qL1xuZnVuY3Rpb24gY29kZUdlbkNsYXNzRGVmKGNsYXNzRGVmLCBnbG9iYWxFbnYpIHtcbiAgICBpZiAoY2xhc3NEZWYudGFnICE9PSBcImNsYXNzXCIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJjYW4gb25seSBnZW5lcmF0ZSBjb2RlcyBmb3IgY2xhc3Nlc1wiKTtcbiAgICB9XG4gICAgdmFyIGNsYXNzV2FzbSA9IFtdO1xuICAgIC8vIGFkZCBhbGwgdGhlIGZpZWxkcyBmdW5jdGlvbnMgKHNpbXBseSByZXR1cm4gdGhlIHZhbHVlKVxuICAgIGNsYXNzRGVmLmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIC8vIFRvIHJldHVybiBzZWxmLmEsIHdlIG5lZWQgdGhlIGFkZHJlc3Mgb2Ygc2VsZiwgYW5kIHRoZSBpbmRleCBvZiBhLlxuICAgICAgICB2YXIgcGFyYW1zID0gW3tcbiAgICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgICAgIHRhZzogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IGNsYXNzRGVmLm5hbWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5hbWU6IFwic2VsZlwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IGNsYXNzRGVmLmFcbiAgICAgICAgICAgIH1dOyAvLyBleC4gc2VsZiA6IFJhdFxuICAgICAgICB2YXIgdmFySW5pdHMgPSBbXTsgLy8gbm8gdmFyaWFibGUgaW5pdGlhbGl6YXRpb25zXG4gICAgICAgIHZhciBnZXRmaWVsZE9iaiA9IHtcbiAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICB0YWc6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgY2xhc3M6IGNsYXNzRGVmLm5hbWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0YWc6IFwiaWRcIixcbiAgICAgICAgICAgIG5hbWU6IFwic2VsZlwiXG4gICAgICAgIH07IC8vIGV4LiByMVxuICAgICAgICB2YXIgZ2V0ZmllbGRFeHByID0geyBhOiBmLmEsIHRhZzogXCJnZXRmaWVsZFwiLCBvYmo6IGdldGZpZWxkT2JqLCBuYW1lOiBmLm5hbWUgfTtcbiAgICAgICAgdmFyIHN0bXRzID0gW3sgYTogXCJOb25lXCIsIHRhZzogXCJyZXR1cm5cIiwgZXhwcjogZ2V0ZmllbGRFeHByIH1dO1xuICAgICAgICB2YXIgZnVuY0RlZiA9IHtcbiAgICAgICAgICAgIG5hbWU6IFwiJFwiICsgY2xhc3NEZWYubmFtZSArIFwiJGdldF9maWVsZF9cIiArIGYubmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgcmV0VHlwZTogZi5hLFxuICAgICAgICAgICAgdmFySW5pdHM6IHZhckluaXRzLFxuICAgICAgICAgICAgc3RtdHM6IHN0bXRzXG4gICAgICAgIH07XG4gICAgICAgIGNvZGVHZW5GdW5jRGVmKGZ1bmNEZWYsIGdsb2JhbEVudikuZm9yRWFjaChmdW5jdGlvbiAoZnVuY1dhc20pIHtcbiAgICAgICAgICAgIGNsYXNzV2FzbS5wdXNoKGZ1bmNXYXNtKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gYWRkIGFsbCB0aGUgbWV0aG9kIGZ1bmN0aW9uc1xuICAgIGNsYXNzRGVmLm1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgICAgICB2YXIgZnVuY0RlZiA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBtKSwgeyBuYW1lOiBcIiRcIiArIGNsYXNzRGVmLm5hbWUgKyBcIiRcIiArIG0ubmFtZSB9KTsgLy8gQW5vdGhlciBcIiRcIiB3b3VsZCBiZSBhZGRlZCBsYXRlci5cbiAgICAgICAgLy8gYWRkIGEgcmV0dXJuIHN0YXRlbWVudCB0byB0aGUgaW5pdCBmdW5jdGlvblxuICAgICAgICBpZiAobS5uYW1lID09IFwiX19pbml0X19cIikge1xuICAgICAgICAgICAgZnVuY0RlZi5zdG10cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBhOiBcIk5vbmVcIixcbiAgICAgICAgICAgICAgICB0YWc6IFwicmV0dXJuXCIsXG4gICAgICAgICAgICAgICAgZXhwcjoge1xuICAgICAgICAgICAgICAgICAgICBhOiB7IHRhZzogXCJvYmplY3RcIiwgY2xhc3M6IGNsYXNzRGVmLm5hbWUgfSxcbiAgICAgICAgICAgICAgICAgICAgdGFnOiBcImlkXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwic2VsZlwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgcmVtb3ZlIFwic2VsZlwiIGluIHRoZSBwYXJzZXIgYW5kIGFkZCBpdCBiYWNrIGhlcmUuXG4gICAgICAgIGZ1bmNEZWYucGFyYW1zID0gX19zcHJlYWRBcnJheXMoW3tcbiAgICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgICAgIHRhZzogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IGNsYXNzRGVmLm5hbWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5hbWU6IFwic2VsZlwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IGNsYXNzRGVmLmFcbiAgICAgICAgICAgIH1dLCBmdW5jRGVmLnBhcmFtcyk7XG4gICAgICAgIC8vIGZ1bmNEZWYucGFyYW1zLnB1c2goeyBcbiAgICAgICAgLy8gICBhOiB7IFxuICAgICAgICAvLyAgICAgdGFnOiBcIm9iamVjdFwiLCBcbiAgICAgICAgLy8gICAgIGNsYXNzOiBjbGFzc0RlZi5uYW1lIFxuICAgICAgICAvLyAgIH0sIFxuICAgICAgICAvLyAgIG5hbWU6IFwic2VsZlwiLCBcbiAgICAgICAgLy8gICB0eXBlOiBjbGFzc0RlZi5hIFxuICAgICAgICAvLyB9KTtcbiAgICAgICAgY29kZUdlbkZ1bmNEZWYoZnVuY0RlZiwgZ2xvYmFsRW52KS5mb3JFYWNoKGZ1bmN0aW9uIChmdW5jV2FzbSkge1xuICAgICAgICAgICAgY2xhc3NXYXNtLnB1c2goZnVuY1dhc20pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2xhc3NXYXNtLmpvaW4oXCJcXG5cIik7XG59XG5mdW5jdGlvbiBjb2RlR2VuRnVuY0RlZihmdW5jRGVmLCBnbG9iYWxFbnYpIHtcbiAgICAvLyBwcmVwYXJlIHRoZSBsb2NhbCBlbnZpcm9ubWVudFxuICAgIHZhciBsb2NhbEVudiA9IGNyZWF0ZUVtcHR5TG9jYWxFbnYoKTtcbiAgICBsb2NhbEVudi5pc0Z1bmMgPSB0cnVlO1xuICAgIGZ1bmNEZWYucGFyYW1zLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICBsb2NhbEVudi52YXJzLnNldChwLm5hbWUsIHRydWUpO1xuICAgIH0pO1xuICAgIGZ1bmNEZWYudmFySW5pdHMubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGxvY2FsRW52LnZhcnMuc2V0KHYubmFtZSwgdHJ1ZSk7XG4gICAgfSk7XG4gICAgLy8gcGFyYW1zXG4gICAgdmFyIHBhcmFtcyA9IGZ1bmNEZWYucGFyYW1zLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gXCIocGFyYW0gJFwiICsgcC5uYW1lICsgXCIgaTMyKVwiO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgICAvLyBpbml0IGxvY2FsIHZhcmlhYmxlc1xuICAgIHZhciBsb2NhbFZhckluaXQgPSBmdW5jRGVmLnZhckluaXRzLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gXCIobG9jYWwgJFwiICsgdi5uYW1lICsgXCIgaTMyKVxcbihsb2NhbC5zZXQgJFwiICsgdi5uYW1lICsgXCIgXCIgKyBjb2RlR2VuTGl0ZXJhbCh2LmluaXRMaXRlcmFsKSArIFwiKVwiO1xuICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgIC8vIGdlbmVyYXRlIGJvZHkgc3RhdGVtZW50c1xuICAgIHZhciBib2R5ID0gY29kZUdlbkJvZHkoZnVuY0RlZi5zdG10cywgZ2xvYmFsRW52LCBsb2NhbEVudik7XG4gICAgLy8gcmV0dXJuIHRnZSBmdW5jdGlvbiBkZWZpbml0aW9uIGluIFdBU01cbiAgICAvLyByZXR1cm4gW2BcXG4oZnVuYyAkJHtmdW5jRGVmLm5hbWV9ICR7cGFyYW1zfSAocmVzdWx0IGkzMikgJHtsb2NhbFZhckluaXR9XFxuJHtib2R5LmpvaW4oJ1xcbicpfSlgXVxuICAgIC8vIHJldHVybiBbYChmdW5jICQke2Z1bmNEZWYubmFtZX0gJHtwYXJhbXN9IChyZXN1bHQgaTMyKVxcbihsb2NhbCAkbGFzdCBpMzIpXFxuJHtsb2NhbFZhckluaXR9XFxuJHtib2R5LmpvaW4oJ1xcbicpfVxcbihpMzIuY29uc3QgMCkpYF1cbiAgICByZXR1cm4gW1wiKGZ1bmMgJFwiICsgZnVuY0RlZi5uYW1lICsgXCIgXCIgKyBwYXJhbXMgKyBcIiAocmVzdWx0IGkzMilcXG4obG9jYWwgJGxhc3QgaTMyKVwiICsgbG9jYWxWYXJJbml0ICsgXCJcXG5cIiArIGJvZHkuam9pbignXFxuJykgKyBcIlxcbihpMzIuY29uc3QgMCkpXFxuXCJdO1xufVxuZnVuY3Rpb24gY29kZUdlbkxpdGVyYWwobGl0ZXJhbCkge1xuICAgIHN3aXRjaCAobGl0ZXJhbC50YWcpIHtcbiAgICAgICAgY2FzZSBcIm51bVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiKGkzMi5jb25zdCBcIiArIGxpdGVyYWwudmFsdWUgKyBcIilcIjtcbiAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICAgIGlmIChsaXRlcmFsLnZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIihpMzIuY29uc3QgMSlcIjtcbiAgICAgICAgICAgIHJldHVybiBcIihpMzIuY29uc3QgMClcIjtcbiAgICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgICAgIHJldHVybiBcIihpMzIuY29uc3QgMClcIjtcbiAgICB9XG59XG4vLyBzaG91bGQgdXNlIGxvY2FsIGVudmlyb25tZW50IGluc3RlYWQgb2YgZ2xvYmFsIGVudmlyb25tZW50XG5mdW5jdGlvbiBjb2RlR2VuSWQoaWQsIEdsb2NhbEVudiwgbG9jYWxFbnYpIHtcbiAgICBpZiAoaWQudGFnICE9PSAnaWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNPTVBJTEUgRVJST1I6IGlucHV0IHRvIGNvZGVHZW4gSWQgc2hvdWxkIGJlIGFuIGlkIGV4cHJcIik7XG4gICAgfVxuICAgIC8vIFRoZSB0eXBlIGNoZWNrZXIgaGFzIGFscmVhZHkgbWFrZSBzdXJlIHRoZSB2YXJpYWJsZSBpcyBkZWZpbmVkLlxuICAgIGlmIChsb2NhbEVudi52YXJzLmhhcyhpZC5uYW1lKSkge1xuICAgICAgICByZXR1cm4gXCIobG9jYWwuZ2V0ICRcIiArIGlkLm5hbWUgKyBcIilcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiKGdsb2JhbC5nZXQgJFwiICsgaWQubmFtZSArIFwiKVwiO1xufVxuIiwiaW1wb3J0IHsgcGFyc2VyIH0gZnJvbSBcImxlemVyLXB5dGhvblwiO1xuaW1wb3J0IHsgQmluT3AsIFVuaU9wIH0gZnJvbSAnLi9hc3QnO1xuZXhwb3J0IGZ1bmN0aW9uIHRyYXZlcnNlQXJncyhjLCBzKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBjLmZpcnN0Q2hpbGQoKTtcbiAgICB3aGlsZSAoYy5uZXh0U2libGluZygpKSB7XG4gICAgICAgIGlmIChjLnR5cGUubmFtZSA9PT0gJyknKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBhcmdzLnB1c2godHJhdmVyc2VFeHByKGMsIHMpKTtcbiAgICAgICAgYy5uZXh0U2libGluZygpO1xuICAgIH1cbiAgICBjLnBhcmVudCgpO1xuICAgIHJldHVybiBhcmdzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRyYXZlcnNlRXhwcihjLCBzKSB7XG4gICAgc3dpdGNoIChjLnR5cGUubmFtZSkge1xuICAgICAgICBjYXNlIFwiTnVtYmVyXCI6IC8vIGVnLiAnMSdcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGFnOiBcImxpdGVyYWxcIixcbiAgICAgICAgICAgICAgICBsaXRlcmFsOiB7XG4gICAgICAgICAgICAgICAgICAgIHRhZzogXCJudW1cIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IE51bWJlcihzLnN1YnN0cmluZyhjLmZyb20sIGMudG8pKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ0Jvb2xlYW4nOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0YWc6IFwibGl0ZXJhbFwiLFxuICAgICAgICAgICAgICAgIGxpdGVyYWw6IHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiBcImJvb2xcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHMuc3Vic3RyaW5nKGMuZnJvbSwgYy50bykgPT09IFwiVHJ1ZVwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcIk5vbmVcIjpcbiAgICAgICAgICAgIHJldHVybiB7IHRhZzogXCJsaXRlcmFsXCIsIGxpdGVyYWw6IHsgdGFnOiBcIm5vbmVcIiB9IH07XG4gICAgICAgIGNhc2UgXCJWYXJpYWJsZU5hbWVcIjogLy8gZS5nLiAneCdcbiAgICAgICAgICAgIHJldHVybiB7IHRhZzogXCJpZFwiLCBuYW1lOiBzLnN1YnN0cmluZyhjLmZyb20sIGMudG8pIH07XG4gICAgICAgIGNhc2UgXCJzZWxmXCI6IC8vIG5vdCBzdXJlIGlmIHRoaXMgc2hvdWxkIGJlIGhhbmRsZWQgbGlrZSB0aGlzXG4gICAgICAgICAgICByZXR1cm4geyB0YWc6IFwiaWRcIiwgbmFtZTogXCJzZWxmXCIgfTtcbiAgICAgICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6IC8vIGUuZy4gbWF4KHgsIHkpLCBhYnMoeCksIGYoKVxuICAgICAgICAgICAgYy5maXJzdENoaWxkKCk7IC8vIFwiTWVtYmVyRXhwcmVzc2lvblwiIG9yIFwiVmFyaWFibGVOYW1lXCJcbiAgICAgICAgICAgIGlmIChjLm5hbWUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgICAgICAgYy5sYXN0Q2hpbGQoKTsgLy8gXCJQcm9wZXJ0eU5hbWVcIlxuICAgICAgICAgICAgICAgIHZhciBwTmFtZV8xID0gcy5zdWJzdHJpbmcoYy5mcm9tLCBjLnRvKTtcbiAgICAgICAgICAgICAgICBjLnBhcmVudCgpOyAvLyBnZXQgYmFjayB0byBcIk1lbWJlckV4cHJlc3Npb25cIlxuICAgICAgICAgICAgICAgIHZhciBvYmpfMSA9IHRyYXZlcnNlRXhwcihjLCBzKTtcbiAgICAgICAgICAgICAgICBpZiAob2JqXzEudGFnICE9PSBcImdldGZpZWxkXCIpIHsgLy8gVmlzaXRpbmcgTWVtYmVyRXhwcmVzc2lvbiBzaG91bGQgYWx3YXlzIGdldHMgYSBnZXRmaWVsZCByZXR1cm4uXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIG9iamVjdCBoYXMgYW4gaW5jb3JyZWN0IHRhZy5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGMubmV4dFNpYmxpbmcoKTsgLy8gXCJBcmdMaXN0XCJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IHRyYXZlcnNlQXJncyhjLCBzKTtcbiAgICAgICAgICAgICAgICBjLnBhcmVudCgpO1xuICAgICAgICAgICAgICAgIC8vIFdlIHJldHVybiBvYmoub2JqIGJlY2F1c2UgdGhlIG9iaiBpcyBhY3R1YWxseSBub3QgYSBnZXRmaWVsZC5cbiAgICAgICAgICAgICAgICByZXR1cm4geyB0YWc6IFwibWV0aG9kXCIsIG9iajogb2JqXzEub2JqLCBhcmdzOiBhcmdzLCBuYW1lOiBwTmFtZV8xIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBcIlZhcmlhYmxlTmFtZVwiXG4gICAgICAgICAgICAgICAgdmFyIGNhbGxOYW1lID0gcy5zdWJzdHJpbmcoYy5mcm9tLCBjLnRvKTtcbiAgICAgICAgICAgICAgICBjLm5leHRTaWJsaW5nKCk7IC8vIFwiQXJnTGlzdFwiXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSB0cmF2ZXJzZUFyZ3MoYywgcyk7XG4gICAgICAgICAgICAgICAgYy5wYXJlbnQoKTsgLy8gYmFjayB0byBcIkNhbGxFeHByZXNzaW9uXCJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0YWc6IFwiY2FsbFwiLCBuYW1lOiBjYWxsTmFtZSwgYXJnczogYXJncyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIFwiVW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICAvLyBXQVJOSU5HOiBUaGlzIHVuaWFyeSBleHByZXNzaW9uIG9ubHkgZGVhbHMgd2l0aCB1bmlhcnkgb3BlcmF0b3IgZGlyZWN0bHkgZm9sbG93ZWQgYnkgYSBudW1iZXIgXG4gICAgICAgICAgICAvLyBlLmcuIC14LCAtICgxICsgMilcbiAgICAgICAgICAgIGMuZmlyc3RDaGlsZCgpOyAvLyBnbyBpbnRvIHRoZSB1bmFyeSBleHByZXNzb2luXG4gICAgICAgICAgICB2YXIgdW5pT3AgPSBzdHIydW5pb3Aocy5zdWJzdHJpbmcoYy5mcm9tLCBjLnRvKSk7XG4gICAgICAgICAgICAvLyBwb3AgdW5pYXJ5IGV4cHJlc3Npb25cbiAgICAgICAgICAgIHZhciBudW0gPSBOdW1iZXIocy5zdWJzdHJpbmcoYy5mcm9tLCBjLnRvKSk7XG4gICAgICAgICAgICBjLm5leHRTaWJsaW5nKCk7XG4gICAgICAgICAgICB2YXIgdW5pb25FeHByID0gdHJhdmVyc2VFeHByKGMsIHMpO1xuICAgICAgICAgICAgYy5wYXJlbnQoKTtcbiAgICAgICAgICAgIHJldHVybiB7IHRhZzogXCJ1bmlvcFwiLCBvcDogdW5pT3AsIGV4cHI6IHVuaW9uRXhwciB9O1xuICAgICAgICBjYXNlIFwiQmluYXJ5RXhwcmVzc2lvblwiOiAvLyBlLmcuIDEgKyAyXG4gICAgICAgICAgICBjLmZpcnN0Q2hpbGQoKTsgLy8gZ28gaW50byBiaW5hcnkgZXhwcmVzc2lvblxuICAgICAgICAgICAgdmFyIGxlZnQgPSB0cmF2ZXJzZUV4cHIoYywgcyk7XG4gICAgICAgICAgICBjLm5leHRTaWJsaW5nKCk7XG4gICAgICAgICAgICB2YXIgb3AgPSBzdHIyYmlub3Aocy5zdWJzdHJpbmcoYy5mcm9tLCBjLnRvKSk7XG4gICAgICAgICAgICBjLm5leHRTaWJsaW5nKCk7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSB0cmF2ZXJzZUV4cHIoYywgcyk7XG4gICAgICAgICAgICBjLnBhcmVudCgpOyAvLyBwb3AgdGhlIGJpbmFyeVxuICAgICAgICAgICAgcmV0dXJuIHsgdGFnOiBcImJpbm9wXCIsIG9wOiBvcCwgbGVmdDogbGVmdCwgcmlnaHQ6IHJpZ2h0IH07XG4gICAgICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6IC8vIGV4LiByMi5uXG4gICAgICAgICAgICBjLmZpcnN0Q2hpbGQoKTsgLy8gXCJDYWxsRXhwcmVzc2lvblwiIG9yIFwiVmFyaWFibGVOYW1lXCJcbiAgICAgICAgICAgIHZhciBvYmogPSB0cmF2ZXJzZUV4cHIoYywgcyk7XG4gICAgICAgICAgICBjLm5leHRTaWJsaW5nKCk7IC8vIFwiLlwiXG4gICAgICAgICAgICBjLm5leHRTaWJsaW5nKCk7IC8vIFwiUHJvcGVydHlOYW1lXCJcbiAgICAgICAgICAgIHZhciBwTmFtZSA9IHMuc3Vic3RyaW5nKGMuZnJvbSwgYy50byk7XG4gICAgICAgICAgICBjLnBhcmVudCgpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdGFnOiBcImdldGZpZWxkXCIsIG9iajogb2JqLCBuYW1lOiBwTmFtZSB9O1xuICAgICAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIGMuZmlyc3RDaGlsZCgpOyAvLyB2aXNpdCBcIihcIlxuICAgICAgICAgICAgYy5uZXh0U2libGluZygpOyAvLyB2aXNpdCB0aGUgaW5uZXIgZXhwcmVzc2lvblxuICAgICAgICAgICAgdmFyIGV4cHIgPSB0cmF2ZXJzZUV4cHIoYywgcyk7XG4gICAgICAgICAgICBjLnBhcmVudDtcbiAgICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS5sb2coc3RyaW5naWZ5VHJlZShjLCBzLCAyKSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQQVJTRSBFUlJPUjogQ291bGQgbm90IHBhcnNlIGV4cHIgYXQgXCIgKyBjLmZyb20gKyBcIiBcIiArIGMudG8gKyBcIjogXCIgKyBzLnN1YnN0cmluZyhjLmZyb20sIGMudG8pKTtcbiAgICB9XG59XG4vKlxuICogQSBmdW5jdGlvbiB0byBwYXJzZSBvbmUgc3RhdGVtZW50XG4gKiBAaW5wdXQgYzogYSB0cmVlY29yc29yXG4gKiBAaW5wdXQgczogdGhlIG9yaWdpbmFsIGlucHV0IHN0cmluZ1xuICogQGlucHV0IGVudjogZW52aXJvbm1lbnQgdmFyaWFibGVzIChpZiB3ZSBhcmUgZ29pbmcgdG8gdHJhdmVyc2UgYSBmdW5jLClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYXZlcnNlU3RtdChjLCBzKSB7XG4gICAgc3dpdGNoIChjLm5vZGUudHlwZS5uYW1lKSB7XG4gICAgICAgIGNhc2UgXCJBc3NpZ25TdGF0ZW1lbnRcIjogLy8gYSA9IDEsIGIgPSAyIG9yIHZhciBJbml0XG4gICAgICAgICAgICBjLmZpcnN0Q2hpbGQoKTsgLy8gXCJWYXJpYWJsZU5hbWVcIiBvciBcIk1lbWJlckV4cHJlc3Npb25cIlxuICAgICAgICAgICAgLy8gZ2V0IGxocyBleHByZXNzaW9uXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHRyYXZlcnNlRXhwcihjLCBzKTtcbiAgICAgICAgICAgIHZhciB2YXJpYWJsZSA9IHMuc3Vic3RyaW5nKGMuZnJvbSwgYy50byk7XG4gICAgICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlLnNwbGl0KFwiLlwiKVswXTsgLy8gVGhpcyBvbmx5IHRlbGxzIHRoZSBpbml0aWFsIHZhcmlhYmxlID0+IHNlbGYueSBhcyBzZWxmXG4gICAgICAgICAgICBjLm5leHRTaWJsaW5nKCk7IC8vIFwiQXNzaWduT3BcIlxuICAgICAgICAgICAgYy5uZXh0U2libGluZygpOyAvLyByaHMgZXhwcmVzc2lvblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdHJhdmVyc2VFeHByKGMsIHMpO1xuICAgICAgICAgICAgYy5wYXJlbnQoKTtcbiAgICAgICAgICAgIHJldHVybiB7IHRhZzogXCJhc3NpZ25cIiwgbmFtZTogbmFtZSwgdmFyaWFibGU6IHZhcmlhYmxlLCB2YWx1ZTogdmFsdWUgfTtcbiAgICAgICAgY2FzZSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIjpcbiAgICAgICAgICAgIGMuZmlyc3RDaGlsZCgpO1xuICAgICAgICAgICAgdmFyIGV4cHIgPSB0cmF2ZXJzZUV4cHIoYywgcyk7XG4gICAgICAgICAgICBjLnBhcmVudCgpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdGFnOiBcImV4cHJcIiwgZXhwcjogZXhwciB9O1xuICAgICAgICBjYXNlIFwiUmV0dXJuU3RhdGVtZW50XCI6XG4gICAgICAgICAgICBjLmZpcnN0Q2hpbGQoKTtcbiAgICAgICAgICAgIGMubmV4dFNpYmxpbmcoKTtcbiAgICAgICAgICAgIHZhciByZXRFeHByID0geyB0YWc6IFwibGl0ZXJhbFwiLCBsaXRlcmFsOiB7IHRhZzogXCJub25lXCIgfSB9O1xuICAgICAgICAgICAgaWYgKGMudHlwZS5uYW1lICE9PSAn4pqgJykgeyAvLyByZXR1cm4gTm9uZVxuICAgICAgICAgICAgICAgIHJldEV4cHIgPSB0cmF2ZXJzZUV4cHIoYywgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjLnBhcmVudCgpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdGFnOiBcInJldHVyblwiLCBleHByOiByZXRFeHByIH07XG4gICAgICAgIGNhc2UgXCJQYXNzU3RhdGVtZW50XCI6XG4gICAgICAgICAgICByZXR1cm4geyB0YWc6IFwicGFzc1wiIH07XG4gICAgICAgIGNhc2UgXCJJZlN0YXRlbWVudFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRyYXZlcnNlSWYoYywgcyk7XG4gICAgICAgIGNhc2UgXCJXaGlsZVN0YXRlbWVudFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRyYXZlcnNlV2hpbGUoYywgcyk7XG4gICAgICAgIGNhc2UgXCJDbGFzc0RlZmluaXRpb25cIjpcbiAgICAgICAgICAgIHJldHVybiB0cmF2ZXJzZUNsYXNzRGVmKGMsIHMpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHBhcnNlIHN0bXQgYXQgXCIgKyBjLm5vZGUuZnJvbSArIFwiIFwiICsgYy5ub2RlLnRvICsgXCI6IFwiICsgcy5zdWJzdHJpbmcoYy5mcm9tLCBjLnRvKSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHRyYXZlcnNlUHJvZ3JhbShjLCBzKSB7XG4gICAgdmFyIHZhckluaXRzID0gW107XG4gICAgdmFyIGNsYXNzRGVmcyA9IFtdO1xuICAgIHZhciBmdW5jRGVmcyA9IFtdOyAvLyBubyBGdW5jRGVmIGZvciBQQTNcbiAgICB2YXIgc3RtdHMgPSBbXTsgLy8gY2xhc3MgZGVmaW5pdGlvbnMgYXJlIGluY2x1ZGVkIGhlcmVcbiAgICBzd2l0Y2ggKGMubm9kZS50eXBlLm5hbWUpIHtcbiAgICAgICAgY2FzZSBcIlNjcmlwdFwiOlxuICAgICAgICAgICAgYy5maXJzdENoaWxkKCk7XG4gICAgICAgICAgICAvLyBwYXJzZSBjbGFzcyBkZWZpbml0aW9ucyBhbmQgdmFyaWFibGUgaW5pdGlhbGl6YXRpb25zXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFySW5pdChjKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXJJbml0cy5wdXNoKHRyYXZlcnNlVmFySW5pdChjLCBzKSk7IC8vIHBhcnNlIHZhcmlhYmxlIGluaXRpYWxpemF0aW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY0RlZihjKSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jRGVmcy5wdXNoKHRyYXZlcnNlRnVuY0RlZihjLCBzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQ2xhc3NEZWYoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NEZWZzLnB1c2godHJhdmVyc2VDbGFzc0RlZihjLCBzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChjLm5leHRTaWJsaW5nKCkpO1xuICAgICAgICAgICAgaWYgKGlzVmFySW5pdChjKSB8fCBpc0Z1bmNEZWYoYykgfHwgaXNDbGFzc0RlZihjKSkgeyAvLyBubyBuZXh0IHNpYmxpbmcgJiYgbm8gc3RtdHNcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YXJJbml0czogdmFySW5pdHMsIGNsYXNzRGVmczogY2xhc3NEZWZzLCBmdW5jRGVmczogZnVuY0RlZnMsIHN0bXRzOiBzdG10cyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcGFyc2Ugc3RhdGVtZW50c1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhckluaXQoYykgfHwgaXNGdW5jRGVmKGMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBBUlNFIEVSUk9SOiB2YXIgaW5pdCBhbmQgZnVuYyBkZWYgc2hvdWxkIGdvIGJlZm9yZSBzdGF0ZW1lbnRzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdG10cy5wdXNoKHRyYXZlcnNlU3RtdChjLCBzKSk7XG4gICAgICAgICAgICB9IHdoaWxlIChjLm5leHRTaWJsaW5nKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFySW5pdHM6IHZhckluaXRzLCBjbGFzc0RlZnM6IGNsYXNzRGVmcywgZnVuY0RlZnM6IGZ1bmNEZWZzLCBzdG10czogc3RtdHMgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBwYXJzZSBwcm9ncmFtIGF0IFwiICsgYy5ub2RlLmZyb20gKyBcIiBcIiArIGMubm9kZS50byk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHNvdXJjZSkge1xuICAgIHZhciB0ID0gcGFyc2VyLnBhcnNlKHNvdXJjZSk7XG4gICAgY29uc29sZS5sb2coXCJQYXJzZWQgU291cmNlIENvZGU6XCIpO1xuICAgIGNvbnNvbGUubG9nKHN0cmluZ2lmeVRyZWUodC5jdXJzb3IoKSwgc291cmNlLCAwKSk7XG4gICAgY29uc29sZS5sb2coXCJcXG5cIik7XG4gICAgcmV0dXJuIHRyYXZlcnNlUHJvZ3JhbSh0LmN1cnNvcigpLCBzb3VyY2UpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY0RlZihjKSB7XG4gICAgcmV0dXJuIGMudHlwZS5uYW1lID09PSAnRnVuY3Rpb25EZWZpbml0aW9uJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0NsYXNzRGVmKGMpIHtcbiAgICByZXR1cm4gYy50eXBlLm5hbWUgPT09ICdDbGFzc0RlZmluaXRpb24nO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFySW5pdChjKSB7XG4gICAgaWYgKGMudHlwZS5uYW1lICE9PSAnQXNzaWduU3RhdGVtZW50Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGMuZmlyc3RDaGlsZCgpO1xuICAgIGMubmV4dFNpYmxpbmcoKTtcbiAgICB2YXIgaXNUeXBlRGVmID0gKGMubm9kZS50eXBlLm5hbWUgPT09ICdUeXBlRGVmJyk7XG4gICAgYy5wYXJlbnQoKTtcbiAgICByZXR1cm4gaXNUeXBlRGVmO1xufVxuLy8gYyBpcyBub3cgaW4gQXNzaWduU3RhdGVtZW50XG5leHBvcnQgZnVuY3Rpb24gdHJhdmVyc2VWYXJJbml0KGMsIHMpIHtcbiAgICBjLmZpcnN0Q2hpbGQoKTsgLy8gVmFyaWFibGVOYW1lXG4gICAgdmFyIHRWYXIgPSB0cmF2ZXJzZVR5cGVkVmFyKGMsIHMpO1xuICAgIGMubmV4dFNpYmxpbmcoKTsgLy8gVHlwZURlZlxuICAgIGMubmV4dFNpYmxpbmcoKTsgLy8gQXNzaWduT3BcbiAgICB2YXIgbGl0ZXJhbCA9IHRyYXZlcnNlTGl0ZXJhbChjLCBzKTsgLy8gTnVtYmVyXG4gICAgYy5wYXJlbnQoKTtcbiAgICByZXR1cm4geyBuYW1lOiB0VmFyLm5hbWUsIHR5cGU6IHRWYXIudHlwZSwgaW5pdExpdGVyYWw6IGxpdGVyYWwgfTtcbn1cbi8vIFRoZXJlIHdvdWxkIGJlIG11Y2ggbW9yZSB0eXBlcyAoY2xhc3NlcykuXG5leHBvcnQgZnVuY3Rpb24gbm9kZTJ0eXBlKGMsIHMpIHtcbiAgICB2YXIgdHlwZVN0ciA9IHMuc3Vic3RyaW5nKGMuZnJvbSwgYy50byk7XG4gICAgc3dpdGNoICh0eXBlU3RyKSB7XG4gICAgICAgIGNhc2UgJ2ludCc6XG4gICAgICAgICAgICByZXR1cm4gXCJpbnRcIjtcbiAgICAgICAgY2FzZSAnYm9vbCc6XG4gICAgICAgICAgICByZXR1cm4gXCJib29sXCI7XG4gICAgICAgIGNhc2UgJ05vbmUnOlxuICAgICAgICAgICAgcmV0dXJuIFwiTm9uZVwiO1xuICAgICAgICBkZWZhdWx0OiAvLyBXZSdsbCBjaGVjayBpZiB0aGUgdHlwZSBleGlzdHMgaW4gdGhlIHR5cGUgY2hlY2tlclxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0YWc6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgY2xhc3M6IHR5cGVTdHJcbiAgICAgICAgICAgIH07XG4gICAgICAgIC8vIHRocm93IG5ldyBFcnJvcihgUEFSU0UgRVJST1I6IHVua25vd24gdHlwZSAke3R5cGVTdHJ9YCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHRyYXZlcnNlVHlwZWRWYXIoYywgcykge1xuICAgIHZhciBuYW1lID0gcy5zdWJzdHJpbmcoYy5mcm9tLCBjLnRvKTsgLy8gXCJWYXJpYWJsZU5hbWVcIlxuICAgIGMubmV4dFNpYmxpbmcoKTsgLy8gVHlwZURlZlxuICAgIGMuZmlyc3RDaGlsZCgpOyAvLyA6XG4gICAgYy5uZXh0U2libGluZygpOyAvLyBWYXJpYWJsZU5hbWVcbiAgICB2YXIgdHlwZSA9IG5vZGUydHlwZShjLCBzKTtcbiAgICBjLnBhcmVudCgpO1xuICAgIHJldHVybiB7IG5hbWU6IG5hbWUsIHR5cGU6IHR5cGUgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0cmF2ZXJzZUxpdGVyYWwoYywgcykge1xuICAgIHZhciB2YWxTdHIgPSBzLnN1YnN0cmluZyhjLmZyb20sIGMudG8pO1xuICAgIHN3aXRjaCAoYy50eXBlLm5hbWUpIHtcbiAgICAgICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICAgICAgICBpZiAodmFsU3RyID09ICdGYWxzZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0YWc6IFwiYm9vbFwiLCB2YWx1ZTogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHRhZzogXCJib29sXCIsIHZhbHVlOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgICByZXR1cm4geyB0YWc6IFwibnVtXCIsIHZhbHVlOiBwYXJzZUludCh2YWxTdHIpIH07XG4gICAgICAgIGNhc2UgJ05vbmUnOlxuICAgICAgICAgICAgcmV0dXJuIHsgdGFnOiBcIm5vbmVcIiB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQQVJTRSBFUlJPUjogdW5zdXBwb3J0aW5nIGxpdGVyYWwgdHlwZVwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0cmF2ZXJzZUNsYXNzRGVmKGMsIHMpIHtcbiAgICB2YXIgY2xzID0ge1xuICAgICAgICB0YWc6IFwiY2xhc3NcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgZmllbGRzOiBbXSxcbiAgICAgICAgbWV0aG9kczogW10sXG4gICAgfTtcbiAgICBjLmZpcnN0Q2hpbGQoKTsgLy8gY2xhc3Mgbm9kZVxuICAgIGMubmV4dFNpYmxpbmcoKTsgLy8gY2xhc3MgbmFtZVxuICAgIGNscy5uYW1lID0gcy5zdWJzdHJpbmcoYy5mcm9tLCBjLnRvKTsgLy8gYXNzaWduIGNsYXNzIG5hbWVcbiAgICBjLm5leHRTaWJsaW5nKCk7IC8vIFwiQXJnbGlzdFwiID0+IGZpeGVkIHRvIGJlIG9iamVjdFxuICAgIGMubmV4dFNpYmxpbmcoKTsgLy8gXCJCb2R5XCJcbiAgICBjLmZpcnN0Q2hpbGQoKTsgLy8gXCI6XCJcbiAgICBjLm5leHRTaWJsaW5nKCk7IC8vIHJlYWNoIHRoZSBmaXNydCBzdGF0ZW1lbnQgaW4gdGhlIGJvZHlcbiAgICB2YXIgY29kZSA9IHRyYXZlcnNlQ2xhc3NCb2R5KGMsIHMpO1xuICAgIGNscy5maWVsZHMgPSBjb2RlLnZhckluaXRzO1xuICAgIGNscy5tZXRob2RzID0gY29kZS5mdW5jRGVmcztcbiAgICBjLnBhcmVudCgpOyAvLyBiYWNrIHRvIFwiQm9keVwiXG4gICAgYy5wYXJlbnQoKTsgLy8gYmFjayB0byBcIkNsYXNzRGVmaW5pdGlvblwiXG4gICAgcmV0dXJuIGNscztcbn1cbmV4cG9ydCBmdW5jdGlvbiB0cmF2ZXJzZU1ldGhEZWYoYywgcykge1xuICAgIHZhciBmdW5jID0ge1xuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICBwYXJhbXM6IG51bGwsXG4gICAgICAgIHJldFR5cGU6IFwiTm9uZVwiLFxuICAgICAgICB2YXJJbml0czogbnVsbCxcbiAgICAgICAgc3RtdHM6IG51bGxcbiAgICB9O1xuICAgIGMuZmlyc3RDaGlsZCgpOyAvLyBcImRlZlwiXG4gICAgYy5uZXh0U2libGluZygpOyAvLyBtZXRob2QgbmFtZVxuICAgIGZ1bmMubmFtZSA9IHMuc3Vic3RyaW5nKGMuZnJvbSwgYy50byk7XG4gICAgYy5uZXh0U2libGluZygpOyAvLyBcIlBhcmFtTGlzdFwiID0+IGF0IGxlYXN0IDEgcGFyYW1ldGVycyAoc2VsZilcbiAgICBmdW5jLnBhcmFtcyA9IHRyYXZlcnNlTWV0aFBhcmFtcyhjLCBzKTtcbiAgICBjLm5leHRTaWJsaW5nKCk7IC8vIFwiVHlwZURlZlwiIG9yIFwiQm9keVwiXG4gICAgLy8gY2hlY2sgaWYgdGhlIG1ldGhvZCBwcm92aWRlcyBhIHJldHVybiB0eXBlXG4gICAgaWYgKGMudHlwZS5uYW1lID09PSAnVHlwZURlZicpIHtcbiAgICAgICAgYy5maXJzdENoaWxkKCk7XG4gICAgICAgIGZ1bmMucmV0VHlwZSA9IG5vZGUydHlwZShjLCBzKTtcbiAgICAgICAgYy5wYXJlbnQoKTtcbiAgICAgICAgYy5uZXh0U2libGluZygpOyAvLyBcIkJvZHlcIlxuICAgIH1cbiAgICBjLmZpcnN0Q2hpbGQoKTsgLy8gXCI6XCJcbiAgICBjLm5leHRTaWJsaW5nKCk7IC8vIHRoZSBmaXJzdCBib2R5IHN0YXRlbWVudFxuICAgIHZhciBjb2RlID0gdHJhdmVyc2VNZXRoQm9keShjLCBzKTsgLy8gVGhpcyBsaW5lIGlzIHRoZSBvbmx5IGRpZmZlcmVuY2VcbiAgICBmdW5jLnZhckluaXRzID0gY29kZS52YXJJbml0cztcbiAgICBmdW5jLnN0bXRzID0gY29kZS5zdG10cztcbiAgICBjLnBhcmVudCgpOyAvLyBiYWNrIHRvIFwiQm9keVwiXG4gICAgYy5wYXJlbnQoKTsgLy8gYmFjayB0byBcIkNsYXNzRGVmaW5pdGlvblwiXG4gICAgcmV0dXJuIGZ1bmM7XG59XG5leHBvcnQgZnVuY3Rpb24gdHJhdmVyc2VGdW5jRGVmKGMsIHMpIHtcbiAgICB2YXIgZnVuYyA9IHtcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgcGFyYW1zOiBudWxsLFxuICAgICAgICByZXRUeXBlOiBcIk5vbmVcIixcbiAgICAgICAgdmFySW5pdHM6IG51bGwsXG4gICAgICAgIHN0bXRzOiBudWxsXG4gICAgfTtcbiAgICAvLyBmdW5jdGlvbiBuYW1lXG4gICAgYy5maXJzdENoaWxkKCk7XG4gICAgYy5uZXh0U2libGluZygpO1xuICAgIGZ1bmMubmFtZSA9IHMuc3Vic3RyaW5nKGMuZnJvbSwgYy50byk7XG4gICAgLy8gcGFyYW1saXN0ICgwIG9yIG1vcmUpXG4gICAgYy5uZXh0U2libGluZygpO1xuICAgIGZ1bmMucGFyYW1zID0gdHJhdmVyc2VGdW5jUGFyYW1zKGMsIHMpO1xuICAgIC8vIHJldHVybiB0eXBlICgwIG9yIG9uZSlcbiAgICBjLm5leHRTaWJsaW5nKCk7XG4gICAgaWYgKGMudHlwZS5uYW1lID09PSAnVHlwZURlZicpIHtcbiAgICAgICAgYy5maXJzdENoaWxkKCk7XG4gICAgICAgIGZ1bmMucmV0VHlwZSA9IG5vZGUydHlwZShjLCBzKTtcbiAgICAgICAgYy5wYXJlbnQoKTtcbiAgICB9XG4gICAgLy8gcGFyc2UgYm9keVxuICAgIGMubmV4dFNpYmxpbmcoKTtcbiAgICBjLmZpcnN0Q2hpbGQoKTtcbiAgICBjLm5leHRTaWJsaW5nKCk7XG4gICAgdmFyIGNvZGUgPSB0cmF2ZXJzZUZ1bmNCb2R5KGMsIHMpO1xuICAgIGZ1bmMudmFySW5pdHMgPSBjb2RlLnZhckluaXRzO1xuICAgIGZ1bmMuc3RtdHMgPSBjb2RlLnN0bXRzO1xuICAgIGMucGFyZW50KCk7XG4gICAgYy5wYXJlbnQoKTtcbiAgICByZXR1cm4gZnVuYztcbn1cbi8vIHNpbWlsYXIgdG8gdHJhdmVyc2VGdW5jUGFyYW1zLCBidXQgZXNjYXBlIHRoZSBzZWxmIHBhcmFtZXRlclxuZnVuY3Rpb24gdHJhdmVyc2VNZXRoUGFyYW1zKGMsIHMpIHtcbiAgICB2YXIgcGFyYW1zID0gW107XG4gICAgYy5maXJzdENoaWxkKCk7IC8vIFwiKFwiXG4gICAgYy5uZXh0U2libGluZygpOyAvLyBcInNlbGZcIlxuICAgIGMubmV4dFNpYmxpbmcoKTsgLy8gXCJUeXBlRGVmXCJcbiAgICBjLm5leHRTaWJsaW5nKCk7IC8vIFwiLFwiXG4gICAgZG8ge1xuICAgICAgICBpZiAocy5zdWJzdHJpbmcoYy5mcm9tLCBjLnRvKSA9PT0gJyknKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChzLnN1YnN0cmluZyhjLmZyb20sIGMudG8pID09PSAnLCcpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgcGFyYW1zLnB1c2godHJhdmVyc2VUeXBlZFZhcihjLCBzKSk7XG4gICAgfSB3aGlsZSAoYy5uZXh0U2libGluZygpKTtcbiAgICBjLnBhcmVudCgpO1xuICAgIHJldHVybiBwYXJhbXM7XG59XG5mdW5jdGlvbiB0cmF2ZXJzZUZ1bmNQYXJhbXMoYywgcykge1xuICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICBjLmZpcnN0Q2hpbGQoKTtcbiAgICBjLm5leHRTaWJsaW5nKCk7XG4gICAgZG8ge1xuICAgICAgICBpZiAocy5zdWJzdHJpbmcoYy5mcm9tLCBjLnRvKSA9PT0gJyknKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChzLnN1YnN0cmluZyhjLmZyb20sIGMudG8pID09PSAnLCcpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgcGFyYW1zLnB1c2godHJhdmVyc2VUeXBlZFZhcihjLCBzKSk7XG4gICAgfSB3aGlsZSAoYy5uZXh0U2libGluZygpKTtcbiAgICBjLnBhcmVudCgpO1xuICAgIHJldHVybiBwYXJhbXM7XG59XG5mdW5jdGlvbiB0cmF2ZXJzZUNsYXNzQm9keShjLCBzKSB7XG4gICAgdmFyIHZhckluaXRzID0gW107XG4gICAgdmFyIGZ1bmNEZWZzID0gW107XG4gICAgZG8ge1xuICAgICAgICBpZiAoaXNWYXJJbml0KGMpKSB7XG4gICAgICAgICAgICB2YXJJbml0cy5wdXNoKHRyYXZlcnNlVmFySW5pdChjLCBzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRnVuY0RlZihjKSkge1xuICAgICAgICAgICAgZnVuY0RlZnMucHVzaCh0cmF2ZXJzZU1ldGhEZWYoYywgcykpO1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAoYy5uZXh0U2libGluZygpKTtcbiAgICAvLyBBIGNsYXNzIGNvbnNpc3RzIG9mIHZhcmlhYmxlIGluaXRpYWxpemF0aW9ucyBhbmQgbWV0aG9kIGRlZmluaXRpb25zLlxuICAgIHJldHVybiB7IHZhckluaXRzOiB2YXJJbml0cywgY2xhc3NEZWZzOiBbXSwgZnVuY0RlZnM6IGZ1bmNEZWZzLCBzdG10czogW10gfTtcbn1cbi8vIEEgbWV0aG9kIGJvZHkgY29uc2lzdHMgdmFyaWFibGUgZGVmaW5pdGlvbnMgYW5kIHN0YXRlbWVudHMuXG5mdW5jdGlvbiB0cmF2ZXJzZU1ldGhCb2R5KGMsIHMpIHtcbiAgICB2YXIgdmFySW5pdHMgPSBbXTtcbiAgICB2YXIgc3RtdHMgPSBbXTtcbiAgICAvLyB0cmF2ZXJzZSB2YXJpYWJsZSBpbml0aWFsaXphdGlvbnNcbiAgICBkbyB7XG4gICAgICAgIGlmICghaXNWYXJJbml0KGMpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXJJbml0cy5wdXNoKHRyYXZlcnNlVmFySW5pdChjLCBzKSk7XG4gICAgfSB3aGlsZSAoYy5uZXh0U2libGluZygpKTtcbiAgICAvLyBnZXQgYWxsIHN0YXRlbWVudFxuICAgIGRvIHtcbiAgICAgICAgc3RtdHMucHVzaCh0cmF2ZXJzZVN0bXQoYywgcykpO1xuICAgIH0gd2hpbGUgKGMubmV4dFNpYmxpbmcoKSk7XG4gICAgcmV0dXJuIHsgdmFySW5pdHM6IHZhckluaXRzLCBjbGFzc0RlZnM6IFtdLCBzdG10czogc3RtdHMsIGZ1bmNEZWZzOiBbXSB9O1xufVxuZnVuY3Rpb24gdHJhdmVyc2VGdW5jQm9keShjLCBzKSB7XG4gICAgdmFyIHZhckluaXRzID0gW107XG4gICAgdmFyIHN0bXRzID0gW107XG4gICAgZG8ge1xuICAgICAgICBpZiAoIWlzVmFySW5pdChjKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRnVuY0RlZihjKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUEFSU0VSIEVSUk86IG5lc3RlZCBmdW5jdGlvbiBkZWZpbml0aW9uIGlzIG5vdCBhbGxvd2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhckluaXRzLnB1c2godHJhdmVyc2VWYXJJbml0KGMsIHMpKTtcbiAgICB9IHdoaWxlIChjLm5leHRTaWJsaW5nKCkpO1xuICAgIC8vIGdldCBhbGwgc3RhdGVtZW50XG4gICAgZG8ge1xuICAgICAgICBpZiAoaXNGdW5jRGVmKGMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQQVJTRVIgRVJST1I6IG5lc3RlZCBmdW5jdGlvbiBkZWZpbml0aW9uIGlzIG5vdyBhbGxvd2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ZhckluaXQoYykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBBUlNFIEVSUk9SOiBWYXJpYWJsZSBpbml0aWFsaXphdGlvbiBzaG91bGQgZ28gYmVmb3JlIHN0YXRlbWVudHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RtdHMucHVzaCh0cmF2ZXJzZVN0bXQoYywgcykpO1xuICAgIH0gd2hpbGUgKGMubmV4dFNpYmxpbmcoKSk7XG4gICAgcmV0dXJuIHsgdmFySW5pdHM6IHZhckluaXRzLCBjbGFzc0RlZnM6IFtdLCBzdG10czogc3RtdHMsIGZ1bmNEZWZzOiBbXSB9O1xufVxuZnVuY3Rpb24gc3RyMnVuaW9wKG9wU3RyKSB7XG4gICAgc3dpdGNoIChvcFN0cikge1xuICAgICAgICBjYXNlIFwiLVwiOlxuICAgICAgICAgICAgcmV0dXJuIFVuaU9wLk1pbnVzO1xuICAgICAgICBjYXNlIFwibm90XCI6XG4gICAgICAgICAgICByZXR1cm4gVW5pT3AuTm90O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQQVJTRSBFUlJPUjogdW5zdXBwb3J0ZWQgdW5pYXJ5IG9wZXJhdG9yXCIpO1xufVxuZnVuY3Rpb24gc3RyMmJpbm9wKG9wU3RyKSB7XG4gICAgc3dpdGNoIChvcFN0cikge1xuICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgcmV0dXJuIEJpbk9wLlBsdXM7XG4gICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgICByZXR1cm4gQmluT3AuTWludXM7XG4gICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICByZXR1cm4gQmluT3AuTXVsO1xuICAgICAgICBjYXNlIFwiLy9cIjpcbiAgICAgICAgICAgIHJldHVybiBCaW5PcC5EaXY7XG4gICAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgICAgICByZXR1cm4gQmluT3AuTW9kO1xuICAgICAgICBjYXNlIFwiPT1cIjpcbiAgICAgICAgICAgIHJldHVybiBCaW5PcC5FcTtcbiAgICAgICAgY2FzZSBcIiE9XCI6XG4gICAgICAgICAgICByZXR1cm4gQmluT3AuTmVxO1xuICAgICAgICBjYXNlIFwiPD1cIjpcbiAgICAgICAgICAgIHJldHVybiBCaW5PcC5TZXE7XG4gICAgICAgIGNhc2UgXCI+PVwiOlxuICAgICAgICAgICAgcmV0dXJuIEJpbk9wLkxlcTtcbiAgICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgICAgIHJldHVybiBCaW5PcC5TbWw7XG4gICAgICAgIGNhc2UgXCI+XCI6XG4gICAgICAgICAgICByZXR1cm4gQmluT3AuTHJnO1xuICAgICAgICBjYXNlIFwiaXNcIjpcbiAgICAgICAgICAgIHJldHVybiBCaW5PcC5JcztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUEFSU0UgRVJST1I6IHVua25vd24gYmluYXJ5IG9wZXJhdG9yXCIpO1xufVxuZnVuY3Rpb24gdHJhdmVyc2VXaGlsZShjLCBzKSB7XG4gICAgYy5maXJzdENoaWxkKCk7IC8vIHdoaWxlXG4gICAgYy5uZXh0U2libGluZygpOyAvLyBjb25kXG4gICAgdmFyIGNvbmQgPSB0cmF2ZXJzZUV4cHIoYywgcyk7XG4gICAgdmFyIHN0bXRzID0gW107XG4gICAgYy5uZXh0U2libGluZygpO1xuICAgIGMuZmlyc3RDaGlsZCgpO1xuICAgIGMubmV4dFNpYmxpbmcoKTtcbiAgICBkbyB7XG4gICAgICAgIHN0bXRzLnB1c2godHJhdmVyc2VTdG10KGMsIHMpKTtcbiAgICB9IHdoaWxlIChjLm5leHRTaWJsaW5nKCkpO1xuICAgIGMucGFyZW50KCk7XG4gICAgYy5wYXJlbnQoKTtcbiAgICByZXR1cm4geyB0YWc6IFwid2hpbGVcIiwgY29uZDogY29uZCwgc3RtdHM6IHN0bXRzIH07XG59XG5mdW5jdGlvbiB0cmF2ZXJzZUlmKGMsIHMpIHtcbiAgICB2YXIgaWZDbGF1c2UgPSB7XG4gICAgICAgIHRhZzogXCJpZlwiLFxuICAgICAgICBpZk9wOiB7XG4gICAgICAgICAgICBjb25kOiBudWxsLFxuICAgICAgICAgICAgc3RtdHM6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgZWxpZk9wOiB7XG4gICAgICAgICAgICBjb25kOiBudWxsLFxuICAgICAgICAgICAgc3RtdHM6IG51bGwsXG4gICAgICAgIH0sXG4gICAgICAgIGVsc2VPcDoge1xuICAgICAgICAgICAgc3RtdHM6IG51bGxcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gY2hlY2sgaWZcbiAgICBjLmZpcnN0Q2hpbGQoKTsgLy8gaWZcbiAgICBjLm5leHRTaWJsaW5nKCk7XG4gICAgaWZDbGF1c2UuaWZPcC5jb25kID0gdHJhdmVyc2VFeHByKGMsIHMpO1xuICAgIGMubmV4dFNpYmxpbmcoKTtcbiAgICBjLmZpcnN0Q2hpbGQoKTtcbiAgICBjLm5leHRTaWJsaW5nKCk7XG4gICAgaWZDbGF1c2UuaWZPcC5zdG10cyA9IFtdO1xuICAgIGRvIHtcbiAgICAgICAgaWZDbGF1c2UuaWZPcC5zdG10cy5wdXNoKHRyYXZlcnNlU3RtdChjLCBzKSk7XG4gICAgfSB3aGlsZSAoYy5uZXh0U2libGluZygpKTtcbiAgICBjLnBhcmVudCgpO1xuICAgIGlmICghYy5uZXh0U2libGluZygpKSB7XG4gICAgICAgIGMucGFyZW50KCk7XG4gICAgICAgIHJldHVybiBpZkNsYXVzZTtcbiAgICB9XG4gICAgLy8gY2hlY2sgZWxpZiBpZlxuICAgIGlmIChjLnR5cGUubmFtZSA9PSAnZWxpZicpIHtcbiAgICAgICAgYy5uZXh0U2libGluZygpO1xuICAgICAgICBpZkNsYXVzZS5lbGlmT3AuY29uZCA9IHRyYXZlcnNlRXhwcihjLCBzKTtcbiAgICAgICAgYy5uZXh0U2libGluZygpO1xuICAgICAgICBjLmZpcnN0Q2hpbGQoKTtcbiAgICAgICAgYy5uZXh0U2libGluZygpO1xuICAgICAgICBpZkNsYXVzZS5lbGlmT3Auc3RtdHMgPSBbXTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWZDbGF1c2UuZWxpZk9wLnN0bXRzLnB1c2godHJhdmVyc2VTdG10KGMsIHMpKTtcbiAgICAgICAgfSB3aGlsZSAoYy5uZXh0U2libGluZygpKTtcbiAgICAgICAgYy5wYXJlbnQoKTtcbiAgICAgICAgaWYgKCFjLm5leHRTaWJsaW5nKCkpIHtcbiAgICAgICAgICAgIGMucGFyZW50KCk7XG4gICAgICAgICAgICByZXR1cm4gaWZDbGF1c2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY2hlY2sgZWxzZVxuICAgIGlmIChjLnR5cGUubmFtZSA9PSAnZWxzZScpIHtcbiAgICAgICAgYy5uZXh0U2libGluZygpO1xuICAgICAgICBjLmZpcnN0Q2hpbGQoKTtcbiAgICAgICAgYy5uZXh0U2libGluZygpO1xuICAgICAgICBpZkNsYXVzZS5lbHNlT3Auc3RtdHMgPSBbXTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWZDbGF1c2UuZWxzZU9wLnN0bXRzLnB1c2godHJhdmVyc2VTdG10KGMsIHMpKTtcbiAgICAgICAgfSB3aGlsZSAoYy5uZXh0U2libGluZygpKTtcbiAgICAgICAgYy5wYXJlbnQoKTtcbiAgICB9XG4gICAgYy5wYXJlbnQoKTtcbiAgICByZXR1cm4gaWZDbGF1c2U7XG59XG4vKlxuICogSGVscGVyIEZ1bmN0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5VHJlZSh0LCBzb3VyY2UsIGQpIHtcbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB2YXIgc3BhY2VzID0gXCIgXCIucmVwZWF0KGQgKiAyKTtcbiAgICBzdHIgKz0gc3BhY2VzICsgdC50eXBlLm5hbWU7XG4gICAgaWYgKFtcIk51bWJlclwiLCBcIkNhbGxFeHByZXNzaW9uXCIsIFwiQmluYXJ5RXhwcmVzc2lvblwiLCBcIlVuYXJ5RXhwcmVzc2lvblwiXS5pbmNsdWRlcyh0LnR5cGUubmFtZSkpIHtcbiAgICAgICAgc3RyICs9IFwiLS0+XCIgKyBzb3VyY2Uuc3Vic3RyaW5nKHQuZnJvbSwgdC50byk7XG4gICAgfVxuICAgIHN0ciArPSBcIlxcblwiO1xuICAgIGlmICh0LmZpcnN0Q2hpbGQoKSkge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBzdHIgKz0gc3RyaW5naWZ5VHJlZSh0LCBzb3VyY2UsIGQgKyAxKTtcbiAgICAgICAgfSB3aGlsZSAodC5uZXh0U2libGluZygpKTtcbiAgICAgICAgdC5wYXJlbnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbiIsIi8vIFRoaXMgaXMgYSBtYXNodXAgb2YgdHV0b3JpYWxzIGZyb206XG4vL1xuLy8gLSBodHRwczovL2dpdGh1Yi5jb20vQXNzZW1ibHlTY3JpcHQvd2FidC5qcy9cbi8vIC0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWJBc3NlbWJseS9Vc2luZ190aGVfSmF2YVNjcmlwdF9BUElcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5pbXBvcnQgd2FidCBmcm9tICd3YWJ0JztcbmltcG9ydCAqIGFzIGNvbXBpbGVyIGZyb20gJy4vY29tcGlsZXInO1xuaW1wb3J0IHsgcGFyc2UgfSBmcm9tICcuL3BhcnNlcic7XG4vLyBOT1RFKGpvZSk6IFRoaXMgaXMgYSBoYWNrIHRvIGdldCB0aGUgQ0xJIFJlcGwgdG8gcnVuLiBXQUJUIHJlZ2lzdGVycyBhIGdsb2JhbFxuLy8gdW5jYXVnaHQgZXhuIGhhbmRsZXIsIGFuZCB0aGlzIGlzIG5vdCBhbGxvd2VkIHdoZW4gcnVubmluZyB0aGUgUkVQTFxuLy8gKGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvcmVwbC5odG1sI3JlcGxfZ2xvYmFsX3VuY2F1Z2h0X2V4Y2VwdGlvbnMpLiBObyByZWFzb25cbi8vIGlzIGdpdmVuIGZvciB0aGlzIGluIHRoZSBkb2NzIHBhZ2UsIGFuZCBJIGhhdmVuJ3Qgc3BlbnQgdGltZSBvbiB0aGUgZG9tYWluXG4vLyBtb2R1bGUgdG8gZmlndXJlIG91dCB3aGF0J3MgZ29pbmcgb24gaGVyZS4gSXQgZG9lc24ndCBzZWVtIGNyaXRpY2FsIGZvciBXQUJUXG4vLyB0byBoYXZlIHRoaXMgc3VwcG9ydCwgc28gd2UgcGF0Y2ggaXQgYXdheS5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciBvbGRQcm9jZXNzT25fMSA9IHByb2Nlc3Mub247XG4gICAgcHJvY2Vzcy5vbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJnc1swXSA9PT0gXCJ1bmNhdWdodEV4Y2VwdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb2xkUHJvY2Vzc09uXzEuYXBwbHkocHJvY2VzcywgYXJncyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJ1bndhdHNyYyhzb3VyY2UsIGNvbmZpZykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdhYnRJbnRlcmZhY2UsIHBhcnNlZCwgcmV0dXJuVHlwZSwgcmV0dXJuRXhwciwgY29tcGlsZWQsIGltcG9ydE9iamVjdCwgd2FzbVNvdXJjZSwgbXlNb2R1bGUsIGFzQmluYXJ5LCB3YXNtTW9kdWxlLCByZXN1bHQ7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHdhYnQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB3YWJ0SW50ZXJmYWNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBwYXJzZShzb3VyY2UpLnN0bXRzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRXhwciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBpbGVkID0gY29tcGlsZXIuY29tcGlsZShzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRPYmplY3QgPSBjb25maWcuaW1wb3J0T2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICB3YXNtU291cmNlID0gXCIobW9kdWxlXFxuICAgIChmdW5jICRwcmludF9udW0gKGltcG9ydCBcXFwiaW1wb3J0c1xcXCIgXFxcInByaW50X251bVxcXCIpIChwYXJhbSBpMzIpIChyZXN1bHQgaTMyKSlcXG4gICAgKGZ1bmMgJHByaW50X2Jvb2wgKGltcG9ydCBcXFwiaW1wb3J0c1xcXCIgXFxcInByaW50X2Jvb2xcXFwiKSAocGFyYW0gaTMyKSAocmVzdWx0IGkzMikpXFxuICAgIChmdW5jICRwcmludF9ub25lIChpbXBvcnQgXFxcImltcG9ydHNcXFwiIFxcXCJwcmludF9ub25lXFxcIikgKHBhcmFtIGkzMikgKHJlc3VsdCBpMzIpKVxcbiAgICAoZnVuYyAkcHJpbnQgKGltcG9ydCBcXFwiaW1wb3J0c1xcXCIgXFxcInByaW50XFxcIikgKHBhcmFtIGkzMikgKHJlc3VsdCBpMzIpKVxcbiAgICAoZnVuYyAkYWJzIChpbXBvcnQgXFxcImltcG9ydHNcXFwiIFxcXCJhYnNcXFwiKSAocGFyYW0gaTMyKSAocmVzdWx0IGkzMikpXFxuICAgIChmdW5jICRtYXggKGltcG9ydCBcXFwiaW1wb3J0c1xcXCIgXFxcIm1heFxcXCIpIChwYXJhbSBpMzIpIChwYXJhbSBpMzIpIChyZXN1bHQgaTMyKSlcXG4gICAgKGZ1bmMgJG1pbiAoaW1wb3J0IFxcXCJpbXBvcnRzXFxcIiBcXFwibWluXFxcIikgKHBhcmFtIGkzMikgKHBhcmFtIGkzMikgKHJlc3VsdCBpMzIpKVxcbiAgICAoZnVuYyAkcG93IChpbXBvcnQgXFxcImltcG9ydHNcXFwiIFxcXCJwb3dcXFwiKSAocGFyYW0gaTMyKSAocGFyYW0gaTMyKSAocmVzdWx0IGkzMikpXFxuICAgIChtZW1vcnkgKGltcG9ydCBcXFwiaW1wb3J0c1xcXCIgXFxcIm1lbVxcXCIpIDEpXFxuICAgIFwiICsgY29tcGlsZWQud2FzbVNvdXJjZSArIFwiXFxuICApXCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwid2FzbVNvdXJjZTogXCIgKyB3YXNtU291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgbXlNb2R1bGUgPSB3YWJ0SW50ZXJmYWNlLnBhcnNlV2F0KFwidGVzdC53YXRcIiwgd2FzbVNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIGFzQmluYXJ5ID0gbXlNb2R1bGUudG9CaW5hcnkoe30pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShhc0JpbmFyeS5idWZmZXIsIGltcG9ydE9iamVjdCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgd2FzbU1vZHVsZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gd2FzbU1vZHVsZS5pbnN0YW5jZS5leHBvcnRzLmV4cG9ydGVkX2Z1bmMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuIiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmltcG9ydCB7IEJpbk9wLCBVbmlPcCB9IGZyb20gJy4vYXN0JztcbmV4cG9ydCBmdW5jdGlvbiBkZWVwQ29weVZhckVudihlbnYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YXJzOiBuZXcgTWFwKGVudi52YXJzKSxcbiAgICAgICAgY2xhc3NNZXRob2RzOiBuZXcgTWFwKGVudi5jbGFzc01ldGhvZHMpLFxuICAgICAgICBjbGFzc0ZpZWxkczogbmV3IE1hcChlbnYuY2xhc3NGaWVsZHMpLFxuICAgICAgICBmdW5jczogbmV3IE1hcChlbnYuZnVuY3MpLFxuICAgICAgICByZXRUeXBlOiBlbnYucmV0VHlwZVxuICAgIH07XG59XG4vLyBpbml0aWFsaXplIGFuIGVudmlyb25tZW50IHN0dXJjdHVyZVxuZXhwb3J0IGZ1bmN0aW9uIG5ld1R5cGVFbnYoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFyczogbmV3IE1hcCgpLFxuICAgICAgICBjbGFzc01ldGhvZHM6IG5ldyBNYXAoKSxcbiAgICAgICAgY2xhc3NGaWVsZHM6IG5ldyBNYXAoKSxcbiAgICAgICAgZnVuY3M6IG5ldyBNYXAoKSxcbiAgICAgICAgcmV0VHlwZTogXCJOb25lXCJcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwRW52KHByb2dyYW0pIHtcbiAgICB2YXIgZXZuID0gbmV3VHlwZUVudigpO1xuICAgIC8vIGdsb2JhbCB2YXJpYWJsZXNcbiAgICBwcm9ncmFtLnZhckluaXRzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgZXZuLnZhcnMuc2V0KHYubmFtZSwgdi50eXBlKTtcbiAgICB9KTtcbiAgICAvLyBjbGFzcyBkZWZpbml0aW9uc1xuICAgIHByb2dyYW0uY2xhc3NEZWZzLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgaWYgKHMudGFnICE9PSBcImNsYXNzXCIpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiRXJyb3I6IFRZUEUgRVJST1I6IG5vdCBhIGNsYXNzXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRlZmluZSB0aGUgZmllbGRzIChuYW1lIDogdHlwZSlcbiAgICAgICAgdmFyIGZpZWxkcyA9IHMuZmllbGRzO1xuICAgICAgICB2YXIgZmllbGRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICBmaWVsZE1hcC5zZXQoZi5uYW1lLCBmLnR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgZXZuLmNsYXNzRmllbGRzLnNldChzLm5hbWUsIGZpZWxkTWFwKTtcbiAgICAgICAgLy8gZGVmaW5lIHRoZSBtZXRob2RzIChuYW1lIDogYXJncyBhbmQgcmV0dXJuIHR5cGUpXG4gICAgICAgIHZhciBtZXRob2RzID0gcy5tZXRob2RzO1xuICAgICAgICB2YXIgbWV0aG9kTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBtZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIG1ldGhvZE1hcC5zZXQobS5uYW1lLCBbbS5wYXJhbXMubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnR5cGU7IH0pLCBtLnJldFR5cGVdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV2bi5jbGFzc01ldGhvZHMuc2V0KHMubmFtZSwgbWV0aG9kTWFwKTtcbiAgICAgICAgLy8gYWRkIHRoZSBjbGFzcyBpbml0aWFsaXphdGlvbiBmdW5jdGlvbnNcbiAgICAgICAgZXZuLmZ1bmNzLnNldChzLm5hbWUsIFtbXSwgeyB0YWc6IFwib2JqZWN0XCIsIGNsYXNzOiBzLm5hbWUgfV0pO1xuICAgIH0pO1xuICAgIC8vIGZ1bmN0aW9uIGRlZmluaXRpb25zXG4gICAgcHJvZ3JhbS5mdW5jRGVmcy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIGV2bi5mdW5jcy5zZXQoZi5uYW1lLCBbZi5wYXJhbXMubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnR5cGU7IH0pLCBmLnJldFR5cGVdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXZuO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVDaGVja1Byb2dyYW0ocHJvZykge1xuICAgIHZhciBlbnYgPSBzZXR1cEVudihwcm9nKTtcbiAgICB2YXIgcHJvZ1R5cGVkID0ge1xuICAgICAgICB2YXJJbml0czogW10sXG4gICAgICAgIGNsYXNzRGVmczogW10sXG4gICAgICAgIGZ1bmNEZWZzOiBbXSxcbiAgICAgICAgc3RtdHM6IFtdXG4gICAgfTtcbiAgICAvLyBjaGVjayBnbG9iYWwgdmFyaWFibGUgPT4gVGhlIHJocyB2YWx1ZXMgc2hvdWxkIGhhdmUgY29ycmVjdCB0eXBlc1xuICAgIHByb2dUeXBlZC52YXJJbml0cyA9IHR5cGVDaGVja1ZhckluaXQocHJvZy52YXJJbml0cywgZW52KTtcbiAgICAvLyBjaGVjayBjbGFzcyBkZWZpbml0aW9uc1xuICAgIHByb2dUeXBlZC5jbGFzc0RlZnMgPSBwcm9nLmNsYXNzRGVmcy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIHR5cGVDaGVja0NsYXNzRGVmKGMsIGVudik7IH0pO1xuICAgIC8vIGNoZWNrIGZ1bmN0aW9uIGRlZmluaXRpb25zXG4gICAgcHJvZ1R5cGVkLmZ1bmNEZWZzID0gcHJvZy5mdW5jRGVmcy5tYXAoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHR5cGVDaGVja0Z1bmNEZWYoZiwgZW52KTsgfSk7XG4gICAgLy8gY2hlY2sgbWFpbiBib2R5XG4gICAgcHJvZ1R5cGVkLnN0bXRzID0gdHlwZUNoZWNrU3RtdHMocHJvZy5zdG10cywgZW52KTtcbiAgICByZXR1cm4gcHJvZ1R5cGVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVDaGVja1N0bXRzKHN0bXRzLCBlbnYpIHtcbiAgICB2YXIgdHlwZWRTdG10cyA9IFtdO1xuICAgIHN0bXRzLmZvckVhY2goZnVuY3Rpb24gKHN0bXQpIHtcbiAgICAgICAgc3dpdGNoIChzdG10LnRhZykge1xuICAgICAgICAgICAgY2FzZSBcImFzc2lnblwiOiAvLyBlLmcuIGEgPSAwXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHN0bXQgaXMgYW4gXCJpZFwiLCB3ZSB3b3VsZCBjaGVjayBvZiB0aGUgdmFyaWFibGUgZXhpc3RzLlxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzdG10IGlzIGEgXCJnZXRmaWVsZFwiLCB3ZSB3b3VsZCBjaGVjayByZWN1cnNpdmVseSB1bnRpbCBpdCdzIGFuIFwiaWRcIi5cbiAgICAgICAgICAgICAgICB2YXIgbGVmdFR5cGVkVmFsdWUgPSB0eXBlQ2hlY2tFeHByKHN0bXQubmFtZSwgZW52KTtcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHRUeXBlZFZhbHVlID0gdHlwZUNoZWNrRXhwcihzdG10LnZhbHVlLCBlbnYpOyAvLyB0byBnZXQgYVxuICAgICAgICAgICAgICAgIGlmICghaXNTYW1lVHlwZShsZWZ0VHlwZWRWYWx1ZS5hLCByaWdodFR5cGVkVmFsdWUuYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJFcnJvcjogVFlQRSBFUlJPUjogRXhwZWN0ZWQgdHlwZSBcIiArIGxlZnRUeXBlZFZhbHVlLmEgKyBcIjsgZ290IHR5cGUgXCIgKyByaWdodFR5cGVkVmFsdWUuYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR5cGVkU3RtdHMucHVzaChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3RtdCksIHsgYTogXCJOb25lXCIsIG5hbWU6IGxlZnRUeXBlZFZhbHVlLCB2YWx1ZTogcmlnaHRUeXBlZFZhbHVlIH0pKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJleHByXCI6XG4gICAgICAgICAgICAgICAgdmFyIHR5cGVkRXhwciA9IHR5cGVDaGVja0V4cHIoc3RtdC5leHByLCBlbnYpO1xuICAgICAgICAgICAgICAgIHR5cGVkU3RtdHMucHVzaChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3RtdCksIHsgZXhwcjogdHlwZWRFeHByLCBhOiBcIk5vbmVcIiB9KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmV0dXJuXCI6XG4gICAgICAgICAgICAgICAgdmFyIHR5cGVkUmV0ID0gdHlwZUNoZWNrRXhwcihzdG10LmV4cHIsIGVudik7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1NhbWVUeXBlKHR5cGVkUmV0LmEsIGVudi5yZXRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvcjogVFlQRSBFUlJPUjogcmV0dXJuIGV4cGVjdGVkIHR5cGUgXCIgKyBlbnYucmV0VHlwZSArIFwiOyBnb3QgdHlwZSBcIiArIHR5cGVkUmV0LmEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0eXBlZFN0bXRzLnB1c2goX19hc3NpZ24oX19hc3NpZ24oe30sIHN0bXQpLCB7IGV4cHI6IHR5cGVkUmV0LCBhOiB0eXBlZFJldC5hIH0pKTsgLy8gVGhpcyBjYW4gYWxzbyBiZSBcIk5vbmVcIlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInBhc3NcIjpcbiAgICAgICAgICAgICAgICB0eXBlZFN0bXRzLnB1c2goX19hc3NpZ24oX19hc3NpZ24oe30sIHN0bXQpLCB7IGE6IFwiTm9uZVwiIH0pKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ3aGlsZVwiOlxuICAgICAgICAgICAgICAgIHZhciB0eXBlZFdoaWxlID0gdHlwZUNoZWNrV2hpbGUoc3RtdCwgZW52KTtcbiAgICAgICAgICAgICAgICB0eXBlZFN0bXRzLnB1c2goX19hc3NpZ24oX19hc3NpZ24oe30sIHR5cGVkV2hpbGUpLCB7IGE6IFwiTm9uZVwiIH0pKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpZlwiOlxuICAgICAgICAgICAgICAgIHZhciB0eXBlZElmID0gdHlwZUNoZWNrSWYoc3RtdCwgZW52KTtcbiAgICAgICAgICAgICAgICB0eXBlZFN0bXRzLnB1c2goX19hc3NpZ24oX19hc3NpZ24oe30sIHR5cGVkSWYpLCB7IGE6IFwiTm9uZVwiIH0pKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0eXBlZFN0bXRzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVDaGVja0V4cHIoZXhwciwgZW52KSB7XG4gICAgc3dpdGNoIChleHByLnRhZykge1xuICAgICAgICBjYXNlIFwiaWRcIjogLy8gY2hlY2sgaWYgdGhlIHZhcmlhYmxlIGhhcyBiZWVuIGRlZmluZWQgXG4gICAgICAgICAgICBpZiAoIWVudi52YXJzLmhhcyhleHByLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRSBFUlJPUjogbm90IGEgdmFyaWFibGUgXCIgKyBleHByLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlkVHlwZSA9IGVudi52YXJzLmdldChleHByLm5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBleHByKSwgeyBhOiBpZFR5cGUgfSk7XG4gICAgICAgIGNhc2UgXCJiaW5vcFwiOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGVDaGVja0Jpbk9wKGV4cHIsIGVudik7XG4gICAgICAgIGNhc2UgXCJ1bmlvcFwiOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGVDaGVja1VuaU9wKGV4cHIsIGVudik7XG4gICAgICAgIGNhc2UgXCJsaXRlcmFsXCI6XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGV4cHIpLCB7IGE6IHR5cGVDaGVja0xpdGVyYWwoZXhwci5saXRlcmFsKS5hIH0pO1xuICAgICAgICBjYXNlIFwiY2FsbFwiOlxuICAgICAgICAgICAgdmFyIHR5cGVkQ2FsbCA9IHR5cGVDaGVja0NhbGwoZXhwciwgZW52KTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlZENhbGw7XG4gICAgICAgIGNhc2UgXCJnZXRmaWVsZFwiOlxuICAgICAgICAgICAgdmFyIHR5cGVkR2V0ZmllbGQgPSB0eXBlQ2hlY2tGaWVsZChleHByLCBlbnYpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVkR2V0ZmllbGQ7XG4gICAgICAgIGNhc2UgXCJtZXRob2RcIjpcbiAgICAgICAgICAgIHZhciB0eXBlZE1ldGhvZCA9IHR5cGVDaGVja01ldGhvZChleHByLCBlbnYpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVkTWV0aG9kO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB0eXBlQ2hlY2tCaW5PcChleHByLCBlbnYpIHtcbiAgICBpZiAoZXhwci50YWcgIT0gXCJiaW5vcFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEVDSEVDSyAgRVJST1I6IHR5cGVDaGVja0Jpbk9wIG9ubHkgdGFrZSBiaW5hcnkgb3BlcmF0aW9uXCIpO1xuICAgIH1cbiAgICBzd2l0Y2ggKGV4cHIub3ApIHtcbiAgICAgICAgLy8gd29yayBmb3IgaW50XG4gICAgICAgIGNhc2UgQmluT3AuUGx1czpcbiAgICAgICAgY2FzZSBCaW5PcC5NaW51czpcbiAgICAgICAgY2FzZSBCaW5PcC5NdWw6XG4gICAgICAgIGNhc2UgQmluT3AuRGl2OlxuICAgICAgICBjYXNlIEJpbk9wLk1vZDpcbiAgICAgICAgY2FzZSBCaW5PcC5TZXE6XG4gICAgICAgIGNhc2UgQmluT3AuTGVxOlxuICAgICAgICBjYXNlIEJpbk9wLlNtbDpcbiAgICAgICAgY2FzZSBCaW5PcC5Mcmc6XG4gICAgICAgICAgICB2YXIgbGVmdFR5cGVkID0gdHlwZUNoZWNrRXhwcihleHByLmxlZnQsIGVudik7IC8vIGFkZCB0aGUgdHlwZSB0byB0aGUgbGVmdCBleHByZXNzaW9uXG4gICAgICAgICAgICB2YXIgcmlnaHRUeXBlZCA9IHR5cGVDaGVja0V4cHIoZXhwci5yaWdodCwgZW52KTtcbiAgICAgICAgICAgIGlmICghaXNTYW1lVHlwZShsZWZ0VHlwZWQuYSwgcmlnaHRUeXBlZC5hKSB8fCAobGVmdFR5cGVkLmEgIT09IFwiaW50XCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRUNIRUNLIEVSUk9SOiBDYW5ub3QgYXBwbHkgb3BlcmF0b3IgJ1wiICsgZXhwci5vcCArIFwiJyBvbiB0eXBlcyAnXCIgKyBsZWZ0VHlwZWQuYSArIFwiJyBhbmQgdHlwZSAnXCIgKyByaWdodFR5cGVkLmEgKyBcIidcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhwci5vcCA9PT0gQmluT3AuU2VxIHx8IGV4cHIub3AgPT09IEJpbk9wLkxlcSB8fCBleHByLm9wID09PSBCaW5PcC5TbWwgfHwgZXhwci5vcCA9PT0gQmluT3AuTHJnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBleHByKSwgeyBsZWZ0OiBsZWZ0VHlwZWQsIHJpZ2h0OiByaWdodFR5cGVkLCBhOiBcImJvb2xcIiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXhwciksIHsgbGVmdDogbGVmdFR5cGVkLCByaWdodDogcmlnaHRUeXBlZCwgYTogXCJpbnRcIiB9KTtcbiAgICAgICAgLy8gd29yayBmb3IgYm90aCBpbnQgYW5kIGJvb2wsIGJ1dCBub3QgTm9uZVxuICAgICAgICBjYXNlIEJpbk9wLkVxOlxuICAgICAgICBjYXNlIEJpbk9wLk5lcTpcbiAgICAgICAgICAgIHZhciBsZWZ0VHlwZWRFcSA9IHR5cGVDaGVja0V4cHIoZXhwci5sZWZ0LCBlbnYpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0VHlwZWRFcSA9IHR5cGVDaGVja0V4cHIoZXhwci5yaWdodCwgZW52KTtcbiAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgY2xhc3NlcyBhbmQgXCJOb25lXCJcbiAgICAgICAgICAgIGlmICghaXNTYW1lVHlwZShsZWZ0VHlwZWRFcS5hLCByaWdodFR5cGVkRXEuYSkgfHwgaXNPYmplY3QobGVmdFR5cGVkRXEuYSkgfHwgbGVmdFR5cGVkRXEuYSA9PSBcIk5vbmVcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEVDSEVDSyBFUlJPUjogQ2Fubm90IGFwcGx5IG9wZXJhdG9yICdcIiArIGV4cHIub3AgKyBcIicgb24gdHlwZXMgJ1wiICsgbGVmdFR5cGVkRXEuYSArIFwiJyBhbmQgdHlwZSAnXCIgKyByaWdodFR5cGVkRXEuYSArIFwiJ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXhwciksIHsgbGVmdDogbGVmdFR5cGVkRXEsIHJpZ2h0OiByaWdodFR5cGVkRXEsIGE6IFwiYm9vbFwiIH0pO1xuICAgICAgICAvLyB3b3JrIGZvciBOb25lIGFuZCBvdGhlciBjbGFzc2VzXG4gICAgICAgIGNhc2UgQmluT3AuSXM6XG4gICAgICAgICAgICB2YXIgbGVmdFR5cGVkSXMgPSB0eXBlQ2hlY2tFeHByKGV4cHIubGVmdCwgZW52KTtcbiAgICAgICAgICAgIHZhciByaWdodFR5cGVkSXMgPSB0eXBlQ2hlY2tFeHByKGV4cHIucmlnaHQsIGVudik7XG4gICAgICAgICAgICBpZiAobGVmdFR5cGVkSXMuYSA9PT0gXCJpbnRcIiB8fCBsZWZ0VHlwZWRJcy5hID09PSBcImJvb2xcIiB8fCByaWdodFR5cGVkSXMuYSA9PT0gXCJpbnRcIiB8fCByaWdodFR5cGVkSXMuYSA9PT0gXCJib29sXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFQ0hFQ0sgRVJST1I6IENhbm5vdCBhcHBseSBvcGVyYXRvciAnXCIgKyBleHByLm9wICsgXCInIG9uIHR5cGVzICdcIiArIGxlZnRUeXBlZElzLmEgKyBcIicgYW5kIHR5cGUgJ1wiICsgcmlnaHRUeXBlZElzLmEgKyBcIidcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGV4cHIpLCB7IGxlZnQ6IGxlZnRUeXBlZElzLCByaWdodDogcmlnaHRUeXBlZElzLCBhOiBcImJvb2xcIiB9KTtcbiAgICB9XG59XG4vLyBzaG91bGQgcmV0dXJuIHRydWUgaW4gdGhlIGZpcnN0IHN0YXRlbWVudCBpZiBib3RoIGFyZSBub3Qgb2JqZWN0c1xuZXhwb3J0IGZ1bmN0aW9uIGlzU2FtZVR5cGUocywgdCkge1xuICAgIGlmIChzID09PSB0KSB7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBib3RoIFwiaW50XCIsIFwiYm9vbFwiLCBvciBcIk5vbmVcIlxuICAgIH1cbiAgICBlbHNlIGlmIChzID09PSBcImludFwiIHx8IHMgPT09IFwiYm9vbFwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodCA9PT0gXCJpbnRcIiB8fCB0ID09PSBcImJvb2xcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKHQgPT09IFwiTm9uZVwiIHx8IHMgPT09IFwiTm9uZVwiKSB7IC8vIFwiTm9uZVwiIGlzIHRoZSBzYW1lIHR5cGUgYXMgYW55IGNsYXNzZXNcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gKHMudGFnID09PSB0LnRhZyAmJiBzLmNsYXNzID09PSB0LmNsYXNzKTsgLy8gYm90aCBvYmplY3RzXG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHMpIHtcbiAgICBpZiAocyA9PT0gXCJpbnRcIiB8fCBzID09PSBcImJvb2xcIiB8fCBzID09PSBcIk5vbmVcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVDaGVja1VuaU9wKGV4cHIsIGVudikge1xuICAgIGlmIChleHByLnRhZyAhPSBcInVuaW9wXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRUNIRUNLICBFUlJPUjogdHlwZUNoZWNrVW5pT3Agb25seSB0YWtlIHVuYXJ5IG9wZXJhdGlvbnNcIik7XG4gICAgfVxuICAgIHN3aXRjaCAoZXhwci5vcCkge1xuICAgICAgICAvLyB3b3JrIGZvciBpbnRcbiAgICAgICAgY2FzZSBVbmlPcC5NaW51czpcbiAgICAgICAgICAgIHZhciB0eXBlZEV4cHIgPSB0eXBlQ2hlY2tFeHByKGV4cHIuZXhwciwgZW52KTtcbiAgICAgICAgICAgIGlmICh0eXBlZEV4cHIuYSAhPT0gXCJpbnRcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEVDSEVDSyBFUlJPUjogdW5pYXJ5IG9wZXJhdG9yIFwiICsgVW5pT3AuTWludXMgKyBcIiBleHBlY3RlZCBcIiArIFwiaW50XCIgKyBcIjsgZ290IHR5cGUgXCIgKyB0eXBlZEV4cHIuYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGV4cHIpLCB7IGV4cHI6IHR5cGVkRXhwciwgYTogXCJpbnRcIiB9KTtcbiAgICAgICAgLy8gd29yayBmb3IgYm9vbFxuICAgICAgICBjYXNlIFVuaU9wLk5vdDpcbiAgICAgICAgICAgIHZhciBub3RUeXBlZEV4cHIgPSB0eXBlQ2hlY2tFeHByKGV4cHIuZXhwciwgZW52KTtcbiAgICAgICAgICAgIGlmIChub3RUeXBlZEV4cHIuYSAhPT0gXCJib29sXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFQ0hFQ0sgRVJST1I6IHVuaWFyeSBvcGVyYXRvciBcIiArIFVuaU9wLk5vdCArIFwiIGV4cGVjdGVkIFwiICsgXCJib29sXCIgKyBcIjsgZ290IHR5cGUgXCIgKyBub3RUeXBlZEV4cHIuYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGV4cHIpLCB7IGV4cHI6IG5vdFR5cGVkRXhwciwgYTogXCJib29sXCIgfSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFQ0hFQ0sgRVJST1I6IHVuZGVmaW5lZCB1bmFyeSBvcGVyYXRvciBcIiArIGV4cHIgKyBcIi4gVGhpcyBlcnJvciBzaG91bGQgYmUgY2FsbGVkIGluIHBhcnNlclwiKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gdHlwZUNoZWNrV2hpbGUoc3RtdCwgZW52KSB7XG4gICAgaWYgKHN0bXQudGFnICE9PSAnd2hpbGUnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEVDSEVDSyBFUlJPUjogdGhlIGlucHV0IHN0YXRlbWVudCBzaG91bGQgYmUgd2hpbGUgd2hlbiBjYWxsaW5nIHR5cGVDaGVja1doaWxlXCIpO1xuICAgIH1cbiAgICB2YXIgdHlwZWRXaGlsZUNvbmQgPSB0eXBlQ2hlY2tFeHByKHN0bXQuY29uZCwgZW52KTtcbiAgICB2YXIgdHlwZWRXaGlsZUJvZHkgPSB0eXBlQ2hlY2tTdG10cyhzdG10LnN0bXRzLCBlbnYpO1xuICAgIGlmICh0eXBlZFdoaWxlQ29uZC5hICE9PSBcImJvb2xcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFQ0hFQ0sgRVJST1I6IENvbmR0aW9uIGV4cHJlc3Npb24gY2Fubm90IGJlIG9mIHR5cGUgJ1wiICsgdHlwZWRXaGlsZUNvbmQuYSArIFwiJ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYTogXCJOb25lXCIsXG4gICAgICAgIHRhZzogJ3doaWxlJyxcbiAgICAgICAgY29uZDogdHlwZWRXaGlsZUNvbmQsXG4gICAgICAgIHN0bXRzOiB0eXBlZFdoaWxlQm9keVxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdHlwZUNoZWNrSWYoc3RtdCwgZW52KSB7XG4gICAgaWYgKHN0bXQudGFnICE9PSAnaWYnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEVDSEVDSyBFUlJPUjogdGhlIGlucHV0IHN0YXRlbWVudCBzaG91bGQgYmUgaWYgd2hlbiBjYWxsaW5nIHR5cGVDaGVja0lmXCIpO1xuICAgIH1cbiAgICAvLyBjaGVjayBpZlxuICAgIHZhciB0eXBlZElmQ29uZCA9IHR5cGVDaGVja0V4cHIoc3RtdC5pZk9wLmNvbmQsIGVudik7XG4gICAgdmFyIHR5cGVkSWZCb2R5ID0gdHlwZUNoZWNrU3RtdHMoc3RtdC5pZk9wLnN0bXRzLCBlbnYpO1xuICAgIGlmICh0eXBlZElmQ29uZC5hICE9PSBcImJvb2xcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFQ0hFQ0sgRVJST1I6IENvbmR0aW9uIGV4cHJlc3Npb24gY2Fubm90IGJlIG9mIHR5cGUgJ1wiICsgdHlwZWRJZkNvbmQuYSArIFwiJ1wiKTtcbiAgICB9XG4gICAgLy8gY2hlY2sgZWxpZlxuICAgIHZhciB0eXBlZEVsaWZDb25kID0gbnVsbDtcbiAgICB2YXIgdHlwZWRFbGlmQm9keSA9IG51bGw7XG4gICAgaWYgKHN0bXQuZWxpZk9wLmNvbmQgIT09IG51bGwpIHtcbiAgICAgICAgdHlwZWRFbGlmQ29uZCA9IHR5cGVDaGVja0V4cHIoc3RtdC5lbGlmT3AuY29uZCwgZW52KTtcbiAgICAgICAgdHlwZWRFbGlmQm9keSA9IHR5cGVDaGVja1N0bXRzKHN0bXQuZWxpZk9wLnN0bXRzLCBlbnYpO1xuICAgICAgICBpZiAodHlwZWRFbGlmQ29uZC5hICE9PSBcImJvb2xcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRUNIRUNLIEVSUk9SOiBDb25kdGlvbiBleHByZXNzaW9uIGNhbm5vdCBiZSBvZiB0eXBlICdcIiArIHR5cGVkRWxpZkNvbmQuYSArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBjaGVjayBlbHNlOlxuICAgIHZhciB0cHllZEVsc2VCb2R5ID0gbnVsbDtcbiAgICBpZiAoc3RtdC5lbHNlT3Auc3RtdHMgIT09IG51bGwpIHtcbiAgICAgICAgdHB5ZWRFbHNlQm9keSA9IHR5cGVDaGVja1N0bXRzKHN0bXQuZWxzZU9wLnN0bXRzLCBlbnYpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhOiBcIk5vbmVcIixcbiAgICAgICAgdGFnOiBcImlmXCIsXG4gICAgICAgIGlmT3A6IHsgY29uZDogdHlwZWRJZkNvbmQsIHN0bXRzOiB0eXBlZElmQm9keSB9LFxuICAgICAgICBlbGlmT3A6IHsgY29uZDogdHlwZWRFbGlmQ29uZCwgc3RtdHM6IHR5cGVkRWxpZkJvZHkgfSxcbiAgICAgICAgZWxzZU9wOiB7IHN0bXRzOiB0cHllZEVsc2VCb2R5IH1cbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVDaGVja0ZpZWxkKGV4cHIsIGVudikge1xuICAgIGlmIChleHByLnRhZyAhPT0gXCJnZXRmaWVsZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEVDSEVDSyBFUlJPUjogdHlwZUNoZWNrTWV0aG9kIG9ubHkgYWNjZXB0cyBhIGdldGZpZWxkIGFzIGFuIGlucHV0IGV4cHJcIik7XG4gICAgfVxuICAgIHZhciB0eXBlZE9iaiA9IHR5cGVDaGVja0V4cHIoZXhwci5vYmosIGVudik7XG4gICAgaWYgKHR5cGVkT2JqLmEgPT09IFwiaW50XCIgfHwgdHlwZWRPYmouYSA9PT0gXCJib29sXCIgfHwgdHlwZWRPYmouYSA9PT0gXCJOb25lXCIpIHsgLy8gY2Fubm90IGNvbXBpbGUgd2l0aCBpc09iamVjdCgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEVDSEVDSyBFUlJPUjogT25seSBvYmplY3RzIGNhbiBnZXQgZmllbGRzLlwiKTtcbiAgICB9XG4gICAgaWYgKCFlbnYuY2xhc3NGaWVsZHMuaGFzKHR5cGVkT2JqLmEuY2xhc3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEVDSEVDSyBFUlJPUjogVGhlIGNsYXNzIGRvZXNuJ3QgZXhpc3QuXCIpO1xuICAgIH1cbiAgICB2YXIgY2xhc3NGaWVsZHMgPSBlbnYuY2xhc3NGaWVsZHMuZ2V0KHR5cGVkT2JqLmEuY2xhc3MpO1xuICAgIGlmICghY2xhc3NGaWVsZHMuaGFzKGV4cHIubmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRUNIRUNLIEVSUk9SOiBUaGUgZmllbGQgZG9lc24ndCBleGlzdCBpbiB0aGUgY2xhc3MuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGV4cHIpLCB7IG9iajogdHlwZWRPYmosIGE6IGNsYXNzRmllbGRzLmdldChleHByLm5hbWUpIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVDaGVja01ldGhvZChleHByLCBlbnYpIHtcbiAgICBpZiAoZXhwci50YWcgIT09IFwibWV0aG9kXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRUNIRUNLIEVSUk9SOiB0eXBlQ2hlY2tNZXRob2Qgb25seSBhY2NlcHRzIGEgbWV0aG9kIGFzIGFuIGlucHV0IGV4cHJcIik7XG4gICAgfVxuICAgIHZhciB0eXBlZE9iaiA9IHR5cGVDaGVja0V4cHIoZXhwci5vYmosIGVudik7XG4gICAgaWYgKHR5cGVkT2JqLmEgPT09IFwiaW50XCIgfHwgdHlwZWRPYmouYSA9PT0gXCJib29sXCIgfHwgdHlwZWRPYmouYSA9PT0gXCJOb25lXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRUNIRUNLIEVSUk9SOiBPbmx5IGNsYXNzZXMgY2FuIGNhbGwgbWV0aG9kcy5cIik7XG4gICAgfVxuICAgIGlmICghZW52LmNsYXNzTWV0aG9kcy5oYXModHlwZWRPYmouYS5jbGFzcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRUNIRUNLIEVSUk9SOiBUaGUgY2xhc3MgZG9lc24ndCBleGlzdC5cIik7XG4gICAgfVxuICAgIHZhciBjbGFzc01ldGhvZHMgPSBlbnYuY2xhc3NNZXRob2RzLmdldCh0eXBlZE9iai5hLmNsYXNzKTtcbiAgICBpZiAoIWNsYXNzTWV0aG9kcy5oYXMoZXhwci5uYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFQ0hFQ0sgRVJST1I6IFRoZSBtZXRob2QgZG9lc24ndCBleGlzdCBpbiB0aGUgY2xhc3MuXCIpO1xuICAgIH1cbiAgICB2YXIgX2EgPSBjbGFzc01ldGhvZHMuZ2V0KGV4cHIubmFtZSksIGFyZ1R5cHMgPSBfYVswXSwgcmV0VHlwID0gX2FbMV07XG4gICAgdmFyIHR5cGVkQXJncyA9IGV4cHIuYXJncy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHR5cGVDaGVja0V4cHIoYSwgZW52KTsgfSk7XG4gICAgaWYgKGFyZ1R5cHMubGVuZ3RoICE9IHR5cGVkQXJncy5sZW5ndGgpIHsgLy8gV2UgZXNjYXBlZCBcInNlbGZcIiBpbiB0aGUgcGFyc2VyLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFQ0hFQ0sgRVJST1I6IFRoZSBudW1iZXIgb2YgcGFyYW1ldGVycyBpcyBpbmNvcnJlY3QuXCIpO1xuICAgIH1cbiAgICBhcmdUeXBzLmZvckVhY2goZnVuY3Rpb24gKHQsIGkpIHtcbiAgICAgICAgaWYgKCFpc1NhbWVUeXBlKHQsIHR5cGVkQXJnc1tpXS5hKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVFlQRUNIRUNLIEVSUk9SOiBpbmNvcnJlY3QgcGFyYW1ldGVyIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGV4cHIpLCB7IG9iajogdHlwZWRPYmosIGFyZ3M6IHR5cGVkQXJncywgYTogcmV0VHlwIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVDaGVja0NhbGwoZXhwciwgZW52KSB7XG4gICAgaWYgKGV4cHIudGFnICE9PSBcImNhbGxcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFQ0hFQ0sgRVJST1I6IHR5cGVDaGVja0NhbGwgb25seSBhY2NlcHQgYSBjYWxsIGFzIGFuIGlucHV0IGV4cHJcIik7XG4gICAgfVxuICAgIGlmICghZW52LmZ1bmNzLmhhcyhleHByLm5hbWUpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlRZUEVDSEVDSyBXQVJOSU5HOiBJZiB0aGUgXCIgKyBleHByLm5hbWUgKyBcIiBmdW5jdGlvbiBpcyBhbiBpbXBvcnRlZCBvbmUsIHdlIGRvbid0IGRvIGFueSB0eXBlIGNoZWNrLlwiKTsgLy8gZXguIHByaW50KClcbiAgICAgICAgdmFyIHR5cGVkQXJnc18xID0gZXhwci5hcmdzLm1hcChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZUNoZWNrRXhwcihhcmcsIGVudik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGV4cHIpLCB7IGFyZ3M6IHR5cGVkQXJnc18xLCBhOiBcIk5vbmVcIiB9KTtcbiAgICB9XG4gICAgLy8gY2hlY2sgIyBwYXJhbXNcbiAgICB2YXIgcGFyYW1zID0gZW52LmZ1bmNzLmdldChleHByLm5hbWUpWzBdO1xuICAgIHZhciBhcmdzID0gZXhwci5hcmdzO1xuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gcGFyYW1zLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFQ0hFQ0sgRVJST1I6IGNhbGwgZnVuYyBcIiArIGV4cHIubmFtZSArIFwiOyBleHBlY3RlZCBcIiArIHBhcmFtcy5sZW5ndGggKyBcIiBhcmd1bWVudHM7IGdvdCBcIiArIGFyZ3MubGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gY2hlY2sgYXJndW1lbnQgdHlwZVxuICAgIHZhciB0eXBlZEFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBwYXJhbXMubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICB2YXIgdHlwZWRBcmcgPSB0eXBlQ2hlY2tFeHByKGFyZ3NbaWR4XSwgZW52KTtcbiAgICAgICAgaWYgKHR5cGVkQXJnLmEgIT09IHBhcmFtc1tpZHhdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUWVBFQ0hFQ0sgRVJST1I6IGNhbGwgZnVuYyBcIiArIGV4cHIubmFtZSArIFwiOyBleHBlY3RlZCB0eXBlIFwiICsgcGFyYW1zW2lkeF0gKyBcIjsgZ290IHR5cGUgXCIgKyB0eXBlZEFyZy5hICsgXCIgaW4gcGFyYW1ldGVycyBcIiArIGlkeCk7XG4gICAgICAgIH1cbiAgICAgICAgdHlwZWRBcmdzLnB1c2godHlwZWRBcmcpO1xuICAgIH1cbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGV4cHIpLCB7IGFyZ3M6IHR5cGVkQXJncywgYTogZW52LmZ1bmNzLmdldChleHByLm5hbWUpWzFdIH0pOyAvLyB1c2UgdGhlIHJldHVybiB0eXBlXG59XG4vLyBtYWtlIHN1cmUgdGhlIHZhcmlhYmxlIHR5cGUgaXMgZXF1YWwgdG8gdGhlIGxpdGVyYWwgdHlwZVxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVDaGVja1ZhckluaXQoaW5pdHMsIGVudikge1xuICAgIHZhciB0eXBlZEluaXRzID0gW107XG4gICAgdmFyIHNjb3BlVmFyID0gbmV3IFNldCgpO1xuICAgIGluaXRzLmZvckVhY2goZnVuY3Rpb24gKGluaXQpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGxlZnQgaGFuZCB0eXBlIGVxdWFscyB0byB0aGUgcmlnaHQgaGFuZCB0eXBlXG4gICAgICAgIC8vIGV4LiB4OmludCBhbmQgMVxuICAgICAgICB2YXIgdHlwZWRMaXRlcmFsID0gdHlwZUNoZWNrTGl0ZXJhbChpbml0LmluaXRMaXRlcmFsKTtcbiAgICAgICAgaWYgKCFpc1NhbWVUeXBlKGluaXQudHlwZSwgdHlwZWRMaXRlcmFsLmEpICYmICEoaXNPYmplY3QoaW5pdC50eXBlKSAmJiB0eXBlZExpdGVyYWwuYSA9PT0gXCJOb25lXCIpKSB7IC8vIGV4LiByMSA6IFJhdCA9IE5vbmVcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiRXJyb3I6IFRZUEUgRVJST1I6IGluaXQgdHlwZSBkb2VzIG5vdCBtYXRjaCBsaXRlcmFsIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdHlwZWRJbml0cy5wdXNoKF9fYXNzaWduKF9fYXNzaWduKHt9LCBpbml0KSwgeyBhOiBpbml0LnR5cGUsIGluaXRMaXRlcmFsOiB0eXBlZExpdGVyYWwgfSkpOyAvLyBhZGQgdGhlIHR5cGVzIHRvIFZhckluaXRcbiAgICB9KTtcbiAgICByZXR1cm4gdHlwZWRJbml0cztcbn1cbi8qXG5DaGVjayB0aGUgdHlwZSBvZiBjbGFzcyBkZWZpbml0aW9uOlxuKDEpIGFkZCB0aGUgY2xhc3MgdmFyaWFibGVzXG4oMikgY2hlY2sgZWFjaCBmdW5jdGlvblxuKi9cbmV4cG9ydCBmdW5jdGlvbiB0eXBlQ2hlY2tDbGFzc0RlZihjbHMsIGVudikge1xuICAgIGlmIChjbHMudGFnICE9PSBcImNsYXNzXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBpcyBub3QgYSBjbGFzcyBzdGF0ZW1lbnQuXCIpO1xuICAgIH1cbiAgICAvLyBUaGUgbWV0aG9kcyBpbiB0aGUgY2xhc3MgY2FuIGFjY2VzcyB0aGUgZ2xvYmFsIHZhcmlhYmxlcy5cbiAgICB2YXIgbG9jYWxFbnYgPSBkZWVwQ29weVZhckVudihlbnYpOyAvLyBpbmNsdWRlIGdsb2JhbCB2YXJpYWJsZXMgaW4gdGhlIGxvY2FsIGVudmlyb25tZW50XG4gICAgLy8gY2hlY2sgdmFyaWFibGUgaW5pdGlhbGl6YXRpb25zXG4gICAgdmFyIGxvY2FsVHlwZWRJbml0cyA9IHR5cGVDaGVja1ZhckluaXQoY2xzLmZpZWxkcywgbG9jYWxFbnYpOyAvLyBjaGVjayB0aGUgdHlwZVxuICAgIGNscy5maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAobG9jYWxUeXBlZEluaXQpIHtcbiAgICAgICAgbG9jYWxFbnYudmFycy5zZXQoXCJzZWxmLlwiICsgbG9jYWxUeXBlZEluaXQubmFtZSwgbG9jYWxUeXBlZEluaXQudHlwZSk7IC8vIHRvIGRpc3Rpbmd1aXNoIHNlbGYuYSBmcm9tIGFcbiAgICB9KTsgLy8gYWRkIHZhcmlhYmxlcyB0byB0aGUgZW52aXJvbm1lbnRcbiAgICBsb2NhbEVudi52YXJzLnNldChcInNlbGZcIiwgeyB0YWc6IFwib2JqZWN0XCIsIGNsYXNzOiBjbHMubmFtZSB9KTsgLy8gYWRkIHRoZSBcInNlbGZcIiB2YXJpYWJsZSB0byB0aGUgZW52aXJvbm1lbnRcbiAgICAvLyBjaGVjayBtZXRob2QgZGVmaW5pdGlvbnNcbiAgICB2YXIgbG9jYWxUeXBlZE1ldGhvZHMgPSBjbHMubWV0aG9kcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIHR5cGVDaGVja0Z1bmNEZWYobSwgbG9jYWxFbnYpOyB9KTsgLy8gdXNlIHRoZSBzYW1lIGZ1bmN0aW9uXG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBjbHMpLCB7IGE6IFwiTm9uZVwiLCBmaWVsZHM6IGxvY2FsVHlwZWRJbml0cywgbWV0aG9kczogbG9jYWxUeXBlZE1ldGhvZHMgfSk7IC8vIEEgY2xhc3MgZGVmaW5pdGlvbiBkb2Vzbid0IHJlcXVpcmUgYW4gXCJhXCIuXG59XG4vKlxuICogQ2hlY2sgdGhlIHR5cGUgb2YgZnVuY3Rpb24gZGVmaW5pdGlvbjpcbiAqICgxKSBuZWVkIHRvIHVwZGF0ZSB0aGUgdHlwZSB2YXIgZW52IGJlZm9yZSBjaGVja2luZyB0aGUgZnVuYyBib2R5XG4gKiAoMikgbmVlZCB0byBjaGVjayB0aGUgc3RhdGVtZW50c1xuICogKDMpIHRoZSByZXR1cm4gdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHlwZUNoZWNrRnVuY0RlZihmdW5jLCBlbnYpIHtcbiAgICAvLyBUaGUgZ2xvYmFsIHZhcmlhYmxlcyBhcmUgaW5jbHVkZWQgaW4gdGhlIGxvY2FsIGVudmlyb25tZW50LlxuICAgIHZhciBsb2NhbEVudiA9IGRlZXBDb3B5VmFyRW52KGVudik7XG4gICAgLy8gYWRkIHBhcmFtcyB0byBlbnZzXG4gICAgdmFyIHNjb3BlVmFyID0gbmV3IFNldCgpOyAvLyBXZSBuZWVkIHRoaXMgYmVjYXVzZSBsb2NhbEVudiBjb250YWlucyBnbG9iYWwgdmFyaWFibGVzLlxuICAgIHZhciB0eXBlZFBhcmFtcyA9IHR5cGVDaGVja1BhcmFtcyhmdW5jLnBhcmFtcyk7XG4gICAgZnVuYy5wYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgLy8gUGFyYW1zIGFyZSBhZGRlZCBmaXJzdCB0byBjaGVjayBkdXBsaWNhdGUgaW5pdGlhbGl6YXRpb25zLlxuICAgICAgICBpZiAoc2NvcGVWYXIuaGFzKHBhcmFtLm5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImR1cGxpY2F0ZSBwYXJhbSBkZWNsYXJhdGlvbiBpbiB0aGUgc2FtZSBmaWVsZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBzY29wZVZhci5hZGQocGFyYW0ubmFtZSk7XG4gICAgICAgIGxvY2FsRW52LnZhcnMuc2V0KHBhcmFtLm5hbWUsIHBhcmFtLnR5cGUpO1xuICAgIH0pO1xuICAgIC8vIGNoZWNrIGluaXRzIC0+IGFkZCB0byBlbnZzXG4gICAgdmFyIGxvY2FsVHlwZWRJbml0cyA9IHR5cGVDaGVja1ZhckluaXQoZnVuYy52YXJJbml0cywgbG9jYWxFbnYpO1xuICAgIGZ1bmMudmFySW5pdHMuZm9yRWFjaChmdW5jdGlvbiAobG9jYWxUeXBlZEluaXQpIHtcbiAgICAgICAgaWYgKHNjb3BlVmFyLmhhcyhsb2NhbFR5cGVkSW5pdC5uYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgaW5pdCBkZWNsYXJhdGlvbiBpbiB0aGUgc2FtZSBmaWVsZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBzY29wZVZhci5hZGQobG9jYWxUeXBlZEluaXQubmFtZSk7XG4gICAgICAgIGxvY2FsRW52LnZhcnMuc2V0KGxvY2FsVHlwZWRJbml0Lm5hbWUsIGxvY2FsVHlwZWRJbml0LnR5cGUpO1xuICAgIH0pO1xuICAgIC8vIGFkZCByZXR1cm4gdHlwZVxuICAgIGxvY2FsRW52LnJldFR5cGUgPSBmdW5jLnJldFR5cGU7XG4gICAgLy8gY2hlY2sgYm9keSBzdGF0ZW1lbnRzXG4gICAgdmFyIHR5cGVkU3RtdHMgPSB0eXBlQ2hlY2tTdG10cyhmdW5jLnN0bXRzLCBsb2NhbEVudik7XG4gICAgLy8gbWFrZSBzdXJlIGV2ZXJ5IHBhdGggaGFzIHRoZSBleHBlY3RlZCByZXR1cm4gXG4gICAgaWYgKCF0eXBlQ2hlY2tIYXNSZXR1cm4oZnVuYy5zdG10cywgZW52KSAmJiBmdW5jLnJldFR5cGUgIT09IFwiTm9uZVwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEVDSEVDSyBFUlJPUjogQWxsIHBhdGhzIGluIGZ1bmN0aW9uL21ldGhvZCBtdXN0IGhhdmUgYSByZXR1cm4gc3RhdGVtZW50OiBcIiArIGZ1bmMubmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZnVuYyksIHsgcGFyYW1zOiB0eXBlZFBhcmFtcywgdmFySW5pdHM6IGxvY2FsVHlwZWRJbml0cywgc3RtdHM6IHR5cGVkU3RtdHMgfSk7XG59XG4vLyBzaW1wbHkgYXNzaWduIHRoZSB0eXBlIHRvIGFcbmV4cG9ydCBmdW5jdGlvbiB0eXBlQ2hlY2tQYXJhbXMocGFyYW1zKSB7XG4gICAgcmV0dXJuIHBhcmFtcy5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBwKSwgeyBhOiBwLnR5cGUgfSk7IH0pO1xufVxuLy8gVGhlIHRhZ3Mgb2YgbGl0ZXJhbHMgYXJlIHRoZWlyIHR5cGVzLlxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVDaGVja0xpdGVyYWwobGl0ZXJhbCkge1xuICAgIHN3aXRjaCAobGl0ZXJhbC50YWcpIHtcbiAgICAgICAgY2FzZSBcIm51bVwiOlxuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBsaXRlcmFsKSwgeyBhOiBcImludFwiIH0pO1xuICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBsaXRlcmFsKSwgeyBhOiBcImJvb2xcIiB9KTtcbiAgICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbGl0ZXJhbCksIHsgYTogXCJOb25lXCIgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gY2hlY2sgd2hldGhlciB0aGlzIGJvZHkgYXJndW1lbnQgaGFzIHRoZVxuICogZGVzaXJlZCByZXR1cm4gdmFsdWVcbiAqIEBwYXJhbSBib2R5XG4gKiBAcGFyYW0gZW52XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0eXBlQ2hlY2tIYXNSZXR1cm4oYm9keSwgZW52KSB7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgYm9keS5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgIHZhciBzdG10ID0gYm9keVtpZHhdO1xuICAgICAgICBzd2l0Y2ggKHN0bXQudGFnKSB7XG4gICAgICAgICAgICBjYXNlIFwicmV0dXJuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjYXNlIFwiaWZcIjpcbiAgICAgICAgICAgICAgICB2YXIgaWZIYXNSZXQgPSB0eXBlQ2hlY2tIYXNSZXR1cm4oc3RtdC5pZk9wLnN0bXRzLCBlbnYpO1xuICAgICAgICAgICAgICAgIGlmIChzdG10LmVsaWZPcC5jb25kICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmSGFzUmV0ID0gaWZIYXNSZXQgJiYgdHlwZUNoZWNrSGFzUmV0dXJuKHN0bXQuZWxpZk9wLnN0bXRzLCBlbnYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RtdC5lbHNlT3Auc3RtdHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWZIYXNSZXQgPSBpZkhhc1JldCAmJiB0eXBlQ2hlY2tIYXNSZXR1cm4oc3RtdC5lbHNlT3Auc3RtdHMsIGVudik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBhYm92ZSBjb25kaXRpb25zIGFyZSBtZXRcbiAgICAgICAgICAgICAgICBpZiAoaWZIYXNSZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSBcInBhc3NcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIFwiZXhwclwiOlxuICAgICAgICAgICAgY2FzZSBcImFzc2lnblwiOlxuICAgICAgICAgICAgY2FzZSBcIndoaWxlXCI6XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRZUEVDSEVDSyBFUlJPUjogdHlwZUNoZWNrSGFzUmV0dXJuIG1lZXRzIHVua25vd24gc3RhdGVtZW50XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbiIsInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5pbXBvcnQgeyBjb21waWxlIH0gZnJvbSAnLi9jb21waWxlcic7XG5pbXBvcnQgeyBydW53YXRzcmMgfSBmcm9tICcuL3J1bm5lcic7XG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGRpc3BsYXkoYXJnKSB7XG4gICAgICAgIHZhciBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicHJlXCIpO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm91dHB1dFwiKS5hcHBlbmRDaGlsZChlbHQpO1xuICAgICAgICBlbHQuaW5uZXJUZXh0ID0gYXJnO1xuICAgIH1cbiAgICB2YXIgbWVtb3J5LCBpbXBvcnRPYmplY3QsIHJ1bkJ1dHRvbiwgdXNlckNvZGU7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBtZW1vcnkgPSBuZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHsgaW5pdGlhbDogMTAsIG1heGltdW06IDEwMCB9KTtcbiAgICAgICAgaW1wb3J0T2JqZWN0ID0ge1xuICAgICAgICAgICAgaW1wb3J0czoge1xuICAgICAgICAgICAgICAgIHByaW50X251bTogZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvZ2dpbmcgZnJvbSBXQVNNOiBcIiwgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheShTdHJpbmcoYXJnKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcmludF9ib29sOiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXkoXCJGYWxzZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXkoXCJUcnVlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcmludF9ub25lOiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXkoXCJOb25lXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJpbnQ6IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2dnaW5nIGZyb20gV0FTTTogXCIsIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicHJlXCIpO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm91dHB1dFwiKS5hcHBlbmRDaGlsZChlbHQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBlbHQuaW5uZXJUZXh0ID0gYXJnO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbWVtOiBtZW1vcnksXG4gICAgICAgICAgICAgICAgYWJzOiBNYXRoLmFicyxcbiAgICAgICAgICAgICAgICBtYXg6IE1hdGgubWF4LFxuICAgICAgICAgICAgICAgIG1pbjogTWF0aC5taW4sXG4gICAgICAgICAgICAgICAgcG93OiBNYXRoLnBvd1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcnVuQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJydW5cIik7XG4gICAgICAgIHVzZXJDb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ1c2VyLWNvZGVcIik7XG4gICAgICAgIHJ1bkJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwcm9ncmFtLCBvdXRwdXQsIHdhdCwgY29kZSwgcmVzdWx0LCBpMzIsIGksIGVfMTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyYW0gPSB1c2VyQ29kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3V0cHV0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicHJvZ3JhbTogXCIgKyBwcm9ncmFtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCAzLCAsIDRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhdCA9IGNvbXBpbGUocHJvZ3JhbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJnZW5lcmF0ZWQtY29kZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUudGV4dENvbnRlbnQgPSB3YXQud2FzbVNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcnVud2F0c3JjKHByb2dyYW0sIHsgaW1wb3J0T2JqZWN0OiBpbXBvcnRPYmplY3QgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpMzIgPSBuZXcgVWludDMyQXJyYXkobWVtb3J5LmJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiaTMyW1wiICsgaSArIFwiXTogXCIgKyBpMzJbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnRleHRDb250ZW50ICs9IFN0cmluZyhyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiY29sb3I6IGJsYWNrXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZV8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC50ZXh0Q29udGVudCA9IFN0cmluZyhlXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiY29sb3I6IHJlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7IH0pO1xuICAgICAgICB1c2VyQ29kZS52YWx1ZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwicHJvZ3JhbVwiKTtcbiAgICAgICAgdXNlckNvZGUuYWRkRXZlbnRMaXN0ZW5lcihcImtleXByZXNzXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJwcm9ncmFtXCIsIHVzZXJDb2RlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7IH0pO1xuICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgfSk7XG59KTsgfSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHdhYnQ7IiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0aWYoX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSkge1xuXHRcdHJldHVybiBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiBtb2R1bGVbJ2RlZmF1bHQnXSA6XG5cdFx0KCkgPT4gbW9kdWxlO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCIvLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZVxuX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vd2Vic3RhcnQudHNcIik7XG4vLyBUaGlzIGVudHJ5IG1vZHVsZSB1c2VkICdleHBvcnRzJyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4iXSwic291cmNlUm9vdCI6IiJ9